<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    overflow-wrap: break-word;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://docs.npmjs.com/"

    >npm (6.1.0)</a>
</h1>
<h4>a package manager for JavaScript</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm">module npm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.access">
            function <span class="apidocSignatureSpan">npm.</span>access
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata">
            function <span class="apidocSignatureSpan">npm.</span>all_package_metadata
            <span class="apidocSignatureSpan">(staleness)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.and_finish_tracker">
            function <span class="apidocSignatureSpan">npm.</span>and_finish_tracker
            <span class="apidocSignatureSpan">(tracker, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.audit">
            function <span class="apidocSignatureSpan">npm.</span>audit
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.bugs">
            function <span class="apidocSignatureSpan">npm.</span>bugs
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ci">
            function <span class="apidocSignatureSpan">npm.</span>ci
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.completion">
            function <span class="apidocSignatureSpan">npm.</span>completion
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.dedupe">
            function <span class="apidocSignatureSpan">npm.</span>dedupe
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deprecate">
            function <span class="apidocSignatureSpan">npm.</span>deprecate
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deref">
            function <span class="apidocSignatureSpan">npm.</span>deref
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.diff_trees">
            function <span class="apidocSignatureSpan">npm.</span>diff_trees
            <span class="apidocSignatureSpan">(oldTree, newTree, differences, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.edit">
            function <span class="apidocSignatureSpan">npm.</span>edit
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.error_handler">
            function <span class="apidocSignatureSpan">npm.</span>error_handler
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.exists">
            function <span class="apidocSignatureSpan">npm.</span>exists
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.explore">
            function <span class="apidocSignatureSpan">npm.</span>explore
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.extract">
            function <span class="apidocSignatureSpan">npm.</span>extract
            <span class="apidocSignatureSpan">(staging, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.fetch_package_metadata">
            function <span class="apidocSignatureSpan">npm.</span>fetch_package_metadata
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.finalize">
            function <span class="apidocSignatureSpan">npm.</span>finalize
            <span class="apidocSignatureSpan">(staging, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.flatten_tree">
            function <span class="apidocSignatureSpan">npm.</span>flatten_tree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.help">
            function <span class="apidocSignatureSpan">npm.</span>help
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.install">
            function <span class="apidocSignatureSpan">npm.</span>install
            <span class="apidocSignatureSpan">(where, args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.link">
            function <span class="apidocSignatureSpan">npm.</span>link
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.load">
            function <span class="apidocSignatureSpan">npm.</span>load
            <span class="apidocSignatureSpan">(cli, cb_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ls">
            function <span class="apidocSignatureSpan">npm.</span>ls
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.mutate_into_logical_tree">
            function <span class="apidocSignatureSpan">npm.</span>mutate_into_logical_tree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.owner">
            function <span class="apidocSignatureSpan">npm.</span>owner
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack">
            function <span class="apidocSignatureSpan">npm.</span>pack
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.parse_json">
            function <span class="apidocSignatureSpan">npm.</span>parse_json
            <span class="apidocSignatureSpan">(content)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.profile">
            function <span class="apidocSignatureSpan">npm.</span>profile
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.prune">
            function <span class="apidocSignatureSpan">npm.</span>prune
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.publish">
            function <span class="apidocSignatureSpan">npm.</span>publish
            <span class="apidocSignatureSpan">(args, isRetry, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pulse_till_done">
            function <span class="apidocSignatureSpan">npm.</span>pulse_till_done
            <span class="apidocSignatureSpan">(prefix, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap">
            function <span class="apidocSignatureSpan">npm.</span>read_shrinkwrap
            <span class="apidocSignatureSpan">(child, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.rebuild">
            function <span class="apidocSignatureSpan">npm.</span>rebuild
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.repo">
            function <span class="apidocSignatureSpan">npm.</span>repo
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.restart">
            function <span class="apidocSignatureSpan">npm.</span>restart
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.run_script">
            function <span class="apidocSignatureSpan">npm.</span>run_script
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save_stack">
            function <span class="apidocSignatureSpan">npm.</span>save_stack
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.search">
            function <span class="apidocSignatureSpan">npm.</span>search
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.shrinkwrap">
            function <span class="apidocSignatureSpan">npm.</span>shrinkwrap
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.star">
            function <span class="apidocSignatureSpan">npm.</span>star
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.start">
            function <span class="apidocSignatureSpan">npm.</span>start
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.stop">
            function <span class="apidocSignatureSpan">npm.</span>stop
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.team">
            function <span class="apidocSignatureSpan">npm.</span>team
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.token">
            function <span class="apidocSignatureSpan">npm.</span>token
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unbuild">
            function <span class="apidocSignatureSpan">npm.</span>unbuild
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.uninstall">
            function <span class="apidocSignatureSpan">npm.</span>uninstall
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unpublish">
            function <span class="apidocSignatureSpan">npm.</span>unpublish
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.validate_args">
            function <span class="apidocSignatureSpan">npm.</span>validate_args
            <span class="apidocSignatureSpan">(idealTree, args, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.view">
            function <span class="apidocSignatureSpan">npm.</span>view
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.writable">
            function <span class="apidocSignatureSpan">npm.</span>writable
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">npm.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">npm.</span>lockfileVersion</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>actions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>commands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>core</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>deps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>fetch_opts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>fullList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>legacy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>limit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>locker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>metrics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>no_progress_while_running</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>node</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>oauth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>read_user_info</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>rollbacks</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>saml</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>save</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>save_stack.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>sso</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>umask</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>unsupported</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.access">module npm.access</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.access.access">
            function <span class="apidocSignatureSpan">npm.</span>access
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.access.completion">
            function <span class="apidocSignatureSpan">npm.access.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.access.</span>subcommands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.access.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.actions">module npm.actions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.actions.doOne">
            function <span class="apidocSignatureSpan">npm.actions.</span>doOne
            <span class="apidocSignatureSpan">(cmd, staging, pkg, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.actions.doParallel">
            function <span class="apidocSignatureSpan">npm.actions.</span>doParallel
            <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.actions.doReverseSerial">
            function <span class="apidocSignatureSpan">npm.actions.</span>doReverseSerial
            <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.actions.doSerial">
            function <span class="apidocSignatureSpan">npm.actions.</span>doSerial
            <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>actions</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.all_package_metadata">module npm.all_package_metadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata.all_package_metadata">
            function <span class="apidocSignatureSpan">npm.</span>all_package_metadata
            <span class="apidocSignatureSpan">(staleness)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createCacheEntryStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createCacheEntryStream
            <span class="apidocSignatureSpan">(cacheFile, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createCacheWriteStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createCacheWriteStream
            <span class="apidocSignatureSpan">(cacheFile, latest, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createEntryStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createEntryStream
            <span class="apidocSignatureSpan">(cachePath, uri, auth, staleness, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createEntryUpdateStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createEntryUpdateStream
            <span class="apidocSignatureSpan">(all, auth, staleness, latest, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createMergedStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createMergedStream
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.and_finish_tracker">module npm.and_finish_tracker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.and_finish_tracker.and_finish_tracker">
            function <span class="apidocSignatureSpan">npm.</span>and_finish_tracker
            <span class="apidocSignatureSpan">(tracker, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.and_finish_tracker.now">
            function <span class="apidocSignatureSpan">npm.and_finish_tracker.</span>now
            <span class="apidocSignatureSpan">(tracker, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.audit">module npm.audit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.audit.audit">
            function <span class="apidocSignatureSpan">npm.</span>audit
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.audit.completion">
            function <span class="apidocSignatureSpan">npm.audit.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.audit.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.bugs">module npm.bugs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.bugs.bugs">
            function <span class="apidocSignatureSpan">npm.</span>bugs
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.bugs.completion">
            function <span class="apidocSignatureSpan">npm.bugs.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.bugs.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.ci">module npm.ci</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ci.ci">
            function <span class="apidocSignatureSpan">npm.</span>ci
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ci.completion">
            function <span class="apidocSignatureSpan">npm.ci.</span>completion
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.ci.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.completion">module npm.completion</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.completion.completion">
            function <span class="apidocSignatureSpan">npm.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.completion.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.config">module npm.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">npm.config.</span>loaded</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.get">
            function <span class="apidocSignatureSpan">npm.config.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.set">
            function <span class="apidocSignatureSpan">npm.config.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toLifecycle">
            function <span class="apidocSignatureSpan">npm.config.</span>toLifecycle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toPacote">
            function <span class="apidocSignatureSpan">npm.config.</span>toPacote
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.core">module npm.core</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">npm.core.</span>loaded</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">npm.core.</span>usingBuiltin</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.core.Conf">
            function <span class="apidocSignatureSpan">npm.core.</span>Conf
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.core.load">
            function <span class="apidocSignatureSpan">npm.core.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.core.validate">
            function <span class="apidocSignatureSpan">npm.core.</span>validate
            <span class="apidocSignatureSpan">(cl)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.core.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.core.</span>defs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.core.</span>rootConf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.core.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.dedupe">module npm.dedupe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.dedupe.dedupe">
            function <span class="apidocSignatureSpan">npm.</span>dedupe
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.dedupe.Deduper">
            function <span class="apidocSignatureSpan">npm.dedupe.</span>Deduper
            <span class="apidocSignatureSpan">(where, dryrun)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.dedupe.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.defaults">module npm.defaults</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.defaults.Umask">
            function <span class="apidocSignatureSpan">npm.defaults.</span>Umask
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.defaults.</span>shorthands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.defaults.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.deprecate">module npm.deprecate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deprecate.deprecate">
            function <span class="apidocSignatureSpan">npm.</span>deprecate
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deprecate.completion">
            function <span class="apidocSignatureSpan">npm.deprecate.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.deprecate.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.deps">module npm.deps</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps._replaceModuleByName">
            function <span class="apidocSignatureSpan">npm.deps.</span>_replaceModuleByName
            <span class="apidocSignatureSpan">(obj, key, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps._replaceModuleByPath">
            function <span class="apidocSignatureSpan">npm.deps.</span>_replaceModuleByPath
            <span class="apidocSignatureSpan">(obj, key, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.computeMetadata">
            function <span class="apidocSignatureSpan">npm.deps.</span>computeMetadata
            <span class="apidocSignatureSpan">(tree, seen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.computeVersionSpec">
            function <span class="apidocSignatureSpan">npm.deps.</span>computeVersionSpec
            <span class="apidocSignatureSpan">(tree, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.earliestInstallable">
            function <span class="apidocSignatureSpan">npm.deps.</span>earliestInstallable
            <span class="apidocSignatureSpan">(requiredBy, tree, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.failedDependency">
            function <span class="apidocSignatureSpan">npm.deps.</span>failedDependency
            <span class="apidocSignatureSpan">(tree, name, pkg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.findRequirement">
            function <span class="apidocSignatureSpan">npm.deps.</span>findRequirement
            <span class="apidocSignatureSpan">(tree, name, requested, requestor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.getAllMetadata">
            function <span class="apidocSignatureSpan">npm.deps.</span>getAllMetadata
            <span class="apidocSignatureSpan">(args, tree, where, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.loadDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>loadDeps
            <span class="apidocSignatureSpan">(tree, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.loadDevDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>loadDevDeps
            <span class="apidocSignatureSpan">(tree, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.loadExtraneous">
            function <span class="apidocSignatureSpan">npm.deps.</span>loadExtraneous
            <span class="apidocSignatureSpan">(tree, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.loadRequestedDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>loadRequestedDeps
            <span class="apidocSignatureSpan">(args, tree, saveToDependencies, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.prefetchDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>prefetchDeps
            <span class="apidocSignatureSpan">(tree, deps, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.removeDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>removeDeps
            <span class="apidocSignatureSpan">(args, tree, saveToDependencies, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.removeExtraneous">
            function <span class="apidocSignatureSpan">npm.deps.</span>removeExtraneous
            <span class="apidocSignatureSpan">(args, tree, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.removeObsoleteDep">
            function <span class="apidocSignatureSpan">npm.deps.</span>removeObsoleteDep
            <span class="apidocSignatureSpan">(child, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.updatePhantomChildren">
            function <span class="apidocSignatureSpan">npm.deps.</span>updatePhantomChildren
            <span class="apidocSignatureSpan">(current, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.validateAllPeerDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>validateAllPeerDeps
            <span class="apidocSignatureSpan">(tree, onInvalid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.validatePeerDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>validatePeerDeps
            <span class="apidocSignatureSpan">(tree, onInvalid)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.diff_trees">module npm.diff_trees</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.diff_trees.diff_trees">
            function <span class="apidocSignatureSpan">npm.</span>diff_trees
            <span class="apidocSignatureSpan">(oldTree, newTree, differences, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.diff_trees._diffTrees">
            function <span class="apidocSignatureSpan">npm.diff_trees.</span>_diffTrees
            <span class="apidocSignatureSpan">(oldTree, newTree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.diff_trees.sortActions">
            function <span class="apidocSignatureSpan">npm.diff_trees.</span>sortActions
            <span class="apidocSignatureSpan">(differences)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.edit">module npm.edit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.edit.edit">
            function <span class="apidocSignatureSpan">npm.</span>edit
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.edit.completion">
            function <span class="apidocSignatureSpan">npm.edit.</span>completion
            <span class="apidocSignatureSpan">(opts, filter, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.edit.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.error_handler">module npm.error_handler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.error_handler.error_handler">
            function <span class="apidocSignatureSpan">npm.</span>error_handler
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.error_handler.exit">
            function <span class="apidocSignatureSpan">npm.error_handler.</span>exit
            <span class="apidocSignatureSpan">(code, noLog)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.exists">module npm.exists</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.exists.exists">
            function <span class="apidocSignatureSpan">npm.</span>exists
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.exists.fsAccessImplementation">
            function <span class="apidocSignatureSpan">npm.exists.</span>fsAccessImplementation
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.exists.fsStatImplementation">
            function <span class="apidocSignatureSpan">npm.exists.</span>fsStatImplementation
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.explore">module npm.explore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.explore.explore">
            function <span class="apidocSignatureSpan">npm.</span>explore
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.explore.completion">
            function <span class="apidocSignatureSpan">npm.explore.</span>completion
            <span class="apidocSignatureSpan">(opts, filter, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.explore.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.extract">module npm.extract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.extract.extract">
            function <span class="apidocSignatureSpan">npm.</span>extract
            <span class="apidocSignatureSpan">(staging, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.extract.init">
            function <span class="apidocSignatureSpan">npm.extract.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.extract.teardown">
            function <span class="apidocSignatureSpan">npm.extract.</span>teardown
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.fetch_opts">module npm.fetch_opts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.fetch_opts.fromPacote">
            function <span class="apidocSignatureSpan">npm.fetch_opts.</span>fromPacote
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.fetch_package_metadata">module npm.fetch_package_metadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.fetch_package_metadata.fetch_package_metadata">
            function <span class="apidocSignatureSpan">npm.</span>fetch_package_metadata
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.fetch_package_metadata.addBundled">
            function <span class="apidocSignatureSpan">npm.fetch_package_metadata.</span>addBundled
            <span class="apidocSignatureSpan">(pkg, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.finalize">module npm.finalize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.finalize.finalize">
            function <span class="apidocSignatureSpan">npm.</span>finalize
            <span class="apidocSignatureSpan">(staging, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.finalize.rollback">
            function <span class="apidocSignatureSpan">npm.finalize.</span>rollback
            <span class="apidocSignatureSpan">(top, staging, pkg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.flatten_tree">module npm.flatten_tree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.flatten_tree.flatten_tree">
            function <span class="apidocSignatureSpan">npm.</span>flatten_tree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.flatten_tree.flatName">
            function <span class="apidocSignatureSpan">npm.flatten_tree.</span>flatName
            <span class="apidocSignatureSpan">(path, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.flatten_tree.flatNameFromTree">
            function <span class="apidocSignatureSpan">npm.flatten_tree.</span>flatNameFromTree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.help">module npm.help</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.help.help">
            function <span class="apidocSignatureSpan">npm.</span>help
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.help.completion">
            function <span class="apidocSignatureSpan">npm.help.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.install">module npm.install</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.install.install">
            function <span class="apidocSignatureSpan">npm.</span>install
            <span class="apidocSignatureSpan">(where, args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.install.Installer">
            function <span class="apidocSignatureSpan">npm.install.</span>Installer
            <span class="apidocSignatureSpan">(where, dryrun, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.install.completion">
            function <span class="apidocSignatureSpan">npm.install.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.install.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.legacy">module npm.legacy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.legacy.login">
            function <span class="apidocSignatureSpan">npm.legacy.</span>login
            <span class="apidocSignatureSpan">(creds, registry, scope, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.link">module npm.link</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.link.link">
            function <span class="apidocSignatureSpan">npm.</span>link
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.link.completion">
            function <span class="apidocSignatureSpan">npm.link.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.link.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.locker">module npm.locker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.locker.lock">
            function <span class="apidocSignatureSpan">npm.locker.</span>lock
            <span class="apidocSignatureSpan">(base, name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.locker.unlock">
            function <span class="apidocSignatureSpan">npm.locker.</span>unlock
            <span class="apidocSignatureSpan">(base, name, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.ls">module npm.ls</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ls.ls">
            function <span class="apidocSignatureSpan">npm.</span>ls
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ls.completion">
            function <span class="apidocSignatureSpan">npm.ls.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ls.fromTree">
            function <span class="apidocSignatureSpan">npm.ls.</span>fromTree
            <span class="apidocSignatureSpan">(dir, physicalTree, args, silent, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.ls.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.metrics">module npm.metrics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.metrics.save">
            function <span class="apidocSignatureSpan">npm.metrics.</span>save
            <span class="apidocSignatureSpan">(itWorked)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.metrics.send">
            function <span class="apidocSignatureSpan">npm.metrics.</span>send
            <span class="apidocSignatureSpan">(metricsFile, metricsRegistry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.metrics.start">
            function <span class="apidocSignatureSpan">npm.metrics.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.metrics.stop">
            function <span class="apidocSignatureSpan">npm.metrics.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.mutate_into_logical_tree">module npm.mutate_into_logical_tree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.mutate_into_logical_tree.mutate_into_logical_tree">
            function <span class="apidocSignatureSpan">npm.</span>mutate_into_logical_tree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.mutate_into_logical_tree.asReadInstalled">
            function <span class="apidocSignatureSpan">npm.mutate_into_logical_tree.</span>asReadInstalled
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.no_progress_while_running">module npm.no_progress_while_running</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.no_progress_while_running.startRunning">
            function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>startRunning
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.no_progress_while_running.stopRunning">
            function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>stopRunning
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.no_progress_while_running.tillDone">
            function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>tillDone
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.node">module npm.node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.node.create">
            function <span class="apidocSignatureSpan">npm.node.</span>create
            <span class="apidocSignatureSpan">(node, template, isNotTop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.node.reset">
            function <span class="apidocSignatureSpan">npm.node.</span>reset
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.oauth">module npm.oauth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.oauth.login">
            function <span class="apidocSignatureSpan">npm.oauth.</span>login
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.owner">module npm.owner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.owner.owner">
            function <span class="apidocSignatureSpan">npm.</span>owner
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.owner.completion">
            function <span class="apidocSignatureSpan">npm.owner.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.owner.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.pack">module npm.pack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.pack">
            function <span class="apidocSignatureSpan">npm.</span>pack
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.completion">
            function <span class="apidocSignatureSpan">npm.pack.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.getContents">
            function <span class="apidocSignatureSpan">npm.pack.</span>getContents
            <span class="apidocSignatureSpan">(pkg, target, filename, silent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.logContents">
            function <span class="apidocSignatureSpan">npm.pack.</span>logContents
            <span class="apidocSignatureSpan">(tarball)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.packDirectory">
            function <span class="apidocSignatureSpan">npm.pack.</span>packDirectory
            <span class="apidocSignatureSpan">(mani, dir, target, filename, logIt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.packGitDep">
            function <span class="apidocSignatureSpan">npm.pack.</span>packGitDep
            <span class="apidocSignatureSpan">(manifest, dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.prepareDirectory">
            function <span class="apidocSignatureSpan">npm.pack.</span>prepareDirectory
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.pack.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.parse_json">module npm.parse_json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.parse_json.parse_json">
            function <span class="apidocSignatureSpan">npm.</span>parse_json
            <span class="apidocSignatureSpan">(content)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.parse_json.noExceptions">
            function <span class="apidocSignatureSpan">npm.parse_json.</span>noExceptions
            <span class="apidocSignatureSpan">(content)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.profile">module npm.profile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.profile.profile">
            function <span class="apidocSignatureSpan">npm.</span>profile
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.profile.completion">
            function <span class="apidocSignatureSpan">npm.profile.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.profile.</span>subcommands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.profile.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.prune">module npm.prune</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.prune.prune">
            function <span class="apidocSignatureSpan">npm.</span>prune
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.prune.Pruner">
            function <span class="apidocSignatureSpan">npm.prune.</span>Pruner
            <span class="apidocSignatureSpan">(where, dryrun, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.prune.completion">
            function <span class="apidocSignatureSpan">npm.prune.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.prune.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.publish">module npm.publish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.publish.publish">
            function <span class="apidocSignatureSpan">npm.</span>publish
            <span class="apidocSignatureSpan">(args, isRetry, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.publish.completion">
            function <span class="apidocSignatureSpan">npm.publish.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.publish.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.pulse_till_done">module npm.pulse_till_done</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pulse_till_done.pulse_till_done">
            function <span class="apidocSignatureSpan">npm.</span>pulse_till_done
            <span class="apidocSignatureSpan">(prefix, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pulse_till_done.withPromise">
            function <span class="apidocSignatureSpan">npm.pulse_till_done.</span>withPromise
            <span class="apidocSignatureSpan">(prefix, promise)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.read_shrinkwrap">module npm.read_shrinkwrap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap.read_shrinkwrap">
            function <span class="apidocSignatureSpan">npm.</span>read_shrinkwrap
            <span class="apidocSignatureSpan">(child, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap._isDiff">
            function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>_isDiff
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap._parsePkgLock">
            function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>_parsePkgLock
            <span class="apidocSignatureSpan">(str, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap.andInflate">
            function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>andInflate
            <span class="apidocSignatureSpan">(child, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.read_user_info">module npm.read_user_info</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_user_info.email">
            function <span class="apidocSignatureSpan">npm.read_user_info.</span>email
            <span class="apidocSignatureSpan">(msg, email, opts, isRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_user_info.otp">
            function <span class="apidocSignatureSpan">npm.read_user_info.</span>otp
            <span class="apidocSignatureSpan">(msg, otp, isRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_user_info.password">
            function <span class="apidocSignatureSpan">npm.read_user_info.</span>password
            <span class="apidocSignatureSpan">(msg, password, isRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_user_info.username">
            function <span class="apidocSignatureSpan">npm.read_user_info.</span>username
            <span class="apidocSignatureSpan">(msg, username, opts, isRetry)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.rebuild">module npm.rebuild</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.rebuild.rebuild">
            function <span class="apidocSignatureSpan">npm.</span>rebuild
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.rebuild.completion">
            function <span class="apidocSignatureSpan">npm.rebuild.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.rebuild.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.repo">module npm.repo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.repo.repo">
            function <span class="apidocSignatureSpan">npm.</span>repo
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.repo.completion">
            function <span class="apidocSignatureSpan">npm.repo.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.repo.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.restart">module npm.restart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.restart.restart">
            function <span class="apidocSignatureSpan">npm.</span>restart
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.restart.completion">
            function <span class="apidocSignatureSpan">npm.restart.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.restart.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.run_script">module npm.run_script</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.run_script.run_script">
            function <span class="apidocSignatureSpan">npm.</span>run_script
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.run_script.completion">
            function <span class="apidocSignatureSpan">npm.run_script.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.run_script.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.saml">module npm.saml</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.saml.login">
            function <span class="apidocSignatureSpan">npm.saml.</span>login
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.save">module npm.save</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save.getSaveType">
            function <span class="apidocSignatureSpan">npm.save.</span>getSaveType
            <span class="apidocSignatureSpan">(tree, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save.saveRequested">
            function <span class="apidocSignatureSpan">npm.save.</span>saveRequested
            <span class="apidocSignatureSpan">(tree, andReturn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save.saveShrinkwrap">
            function <span class="apidocSignatureSpan">npm.save.</span>saveShrinkwrap
            <span class="apidocSignatureSpan">(tree, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.save_stack">module npm.save_stack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save_stack.save_stack">
            function <span class="apidocSignatureSpan">npm.</span>save_stack
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save_stack.super_">
            function <span class="apidocSignatureSpan">npm.save_stack.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.save_stack.prototype">module npm.save_stack.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save_stack.prototype.completeWith">
            function <span class="apidocSignatureSpan">npm.save_stack.prototype.</span>completeWith
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.search">module npm.search</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.search.search">
            function <span class="apidocSignatureSpan">npm.</span>search
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.search.completion">
            function <span class="apidocSignatureSpan">npm.search.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.search.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.shrinkwrap">module npm.shrinkwrap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.shrinkwrap.shrinkwrap">
            function <span class="apidocSignatureSpan">npm.</span>shrinkwrap
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.shrinkwrap.createShrinkwrap">
            function <span class="apidocSignatureSpan">npm.shrinkwrap.</span>createShrinkwrap
            <span class="apidocSignatureSpan">(tree, opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.shrinkwrap.treeToShrinkwrap">
            function <span class="apidocSignatureSpan">npm.shrinkwrap.</span>treeToShrinkwrap
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.shrinkwrap.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.sso">module npm.sso</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.sso.login">
            function <span class="apidocSignatureSpan">npm.sso.</span>login
            <span class="apidocSignatureSpan">(creds, registry, scope, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.star">module npm.star</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.star.star">
            function <span class="apidocSignatureSpan">npm.</span>star
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.star.completion">
            function <span class="apidocSignatureSpan">npm.star.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.star.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.start">module npm.start</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.start.start">
            function <span class="apidocSignatureSpan">npm.</span>start
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.start.completion">
            function <span class="apidocSignatureSpan">npm.start.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.start.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.stop">module npm.stop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.stop.stop">
            function <span class="apidocSignatureSpan">npm.</span>stop
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.stop.completion">
            function <span class="apidocSignatureSpan">npm.stop.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.stop.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.team">module npm.team</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.team.team">
            function <span class="apidocSignatureSpan">npm.</span>team
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.team.completion">
            function <span class="apidocSignatureSpan">npm.team.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.team.</span>subcommands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.team.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.token">module npm.token</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.token.token">
            function <span class="apidocSignatureSpan">npm.</span>token
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.token._validateCIDRList">
            function <span class="apidocSignatureSpan">npm.token.</span>_validateCIDRList
            <span class="apidocSignatureSpan">(cidrs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.token.completion">
            function <span class="apidocSignatureSpan">npm.token.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.token.</span>subcommands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.token.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.umask">module npm.umask</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.umask.fromString">
            function <span class="apidocSignatureSpan">npm.umask.</span>fromString
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.umask.toString">
            function <span class="apidocSignatureSpan">npm.umask.</span>toString
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.umask.validate">
            function <span class="apidocSignatureSpan">npm.umask.</span>validate
            <span class="apidocSignatureSpan">(data, k, val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.unbuild">module npm.unbuild</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unbuild.unbuild">
            function <span class="apidocSignatureSpan">npm.</span>unbuild
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unbuild.rmStuff">
            function <span class="apidocSignatureSpan">npm.unbuild.</span>rmStuff
            <span class="apidocSignatureSpan">(pkg, folder, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.unbuild.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.uninstall">module npm.uninstall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.uninstall.uninstall">
            function <span class="apidocSignatureSpan">npm.</span>uninstall
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.uninstall.Uninstaller">
            function <span class="apidocSignatureSpan">npm.uninstall.</span>Uninstaller
            <span class="apidocSignatureSpan">(where, dryrun, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.uninstall.completion">
            function <span class="apidocSignatureSpan">npm.uninstall.</span>completion
            <span class="apidocSignatureSpan">(opts, filter, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.uninstall.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.unpublish">module npm.unpublish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unpublish.unpublish">
            function <span class="apidocSignatureSpan">npm.</span>unpublish
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unpublish.completion">
            function <span class="apidocSignatureSpan">npm.unpublish.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.unpublish.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.unsupported">module npm.unsupported</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unsupported.checkForBrokenNode">
            function <span class="apidocSignatureSpan">npm.unsupported.</span>checkForBrokenNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unsupported.checkForUnsupportedNode">
            function <span class="apidocSignatureSpan">npm.unsupported.</span>checkForUnsupportedNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unsupported.checkVersion">
            function <span class="apidocSignatureSpan">npm.unsupported.</span>checkVersion
            <span class="apidocSignatureSpan">(version)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.validate_args">module npm.validate_args</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.validate_args.validate_args">
            function <span class="apidocSignatureSpan">npm.</span>validate_args
            <span class="apidocSignatureSpan">(idealTree, args, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.validate_args.isInstallable">
            function <span class="apidocSignatureSpan">npm.validate_args.</span>isInstallable
            <span class="apidocSignatureSpan">(pkg, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.view">module npm.view</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.view.view">
            function <span class="apidocSignatureSpan">npm.</span>view
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.view.completion">
            function <span class="apidocSignatureSpan">npm.view.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.view.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.writable">module npm.writable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.writable.writable">
            function <span class="apidocSignatureSpan">npm.</span>writable
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.writable.fsAccessImplementation">
            function <span class="apidocSignatureSpan">npm.writable.</span>fsAccessImplementation
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.writable.fsOpenImplementation">
            function <span class="apidocSignatureSpan">npm.writable.</span>fsOpenImplementation
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm" id="apidoc.module.npm">module npm</a></h1>


    <h2>
        <a href="#apidoc.element.npm.access" id="apidoc.element.npm.access">
        function <span class="apidocSignatureSpan">npm.</span>access
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function access(args, cb) {
  var cmd = args.shift()
  var params
  return parseParams(cmd, args, function (err, p) {
    if (err) { return cb(err) }
    params = p
    return mapToRegistry(params.package, npm.config, invokeCmd)
  })

  function invokeCmd (err, uri, auth, base) {
    if (err) { return cb(err) }
    params.auth = auth
    try {
      return npm.registry.access(cmd, uri, params, function (err, data) {
        if (!err &amp;&amp; data) {
          output(JSON.stringify(data, undefined, 2))
        }
        cb(err, data)
      })
    } catch (e) {
      cb(e.message + &apos;\n\nUsage:\n&apos; + access.usage)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return mapToRegistry(params.package, npm.config, invokeCmd)
})

function invokeCmd (err, uri, auth, base) {
  if (err) { return cb(err) }
  params.auth = auth
  try {
    return npm.registry.<span class="apidocCodeKeywordSpan">access</span>(cmd, uri, params, function (err, data) {
      if (!err &amp;&amp; data) {
        output(JSON.stringify(data, undefined, 2))
      }
      cb(err, data)
    })
  } catch (e) {
    cb(e.message + &apos;\n\nUsage:\n&apos; + access.usage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata" id="apidoc.element.npm.all_package_metadata">
        function <span class="apidocSignatureSpan">npm.</span>all_package_metadata
        <span class="apidocSignatureSpan">(staleness)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allPackageMetadata(staleness) {
  var stream = ms.through.obj()

  mapToRegistry(&apos;-/all&apos;, npm.config, function (er, uri, auth) {
    if (er) return stream.emit(&apos;error&apos;, er)

    var cacheBase = cacheFile(npm.config.get(&apos;cache&apos;))(uri)
    var cachePath = path.join(cacheBase, &apos;.cache.json&apos;)

    createEntryStream(cachePath, uri, auth, staleness, function (err, entryStream, latest, newEntries) {
      if (err) return stream.emit(&apos;error&apos;, err)
      log.silly(&apos;all-package-metadata&apos;, &apos;entry stream created&apos;)
      if (entryStream &amp;&amp; newEntries) {
        createCacheWriteStream(cachePath, latest, function (err, writeStream) {
          if (err) return stream.emit(&apos;error&apos;, err)
          log.silly(&apos;all-package-metadata&apos;, &apos;output stream created&apos;)
          ms.pipeline.obj(entryStream, writeStream, stream)
        })
      } else if (entryStream) {
        ms.pipeline.obj(entryStream, stream)
      } else {
        stream.emit(&apos;error&apos;, new Error(&apos;No search sources available&apos;))
      }
    })
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.and_finish_tracker" id="apidoc.element.npm.and_finish_tracker">
        function <span class="apidocSignatureSpan">npm.</span>and_finish_tracker
        <span class="apidocSignatureSpan">(tracker, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and_finish_tracker = function (tracker, cb) {
  validate(&apos;OF&apos;, [tracker, cb])
  return function () {
    tracker.finish()
    cb.apply(null, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.audit" id="apidoc.element.npm.audit">
        function <span class="apidocSignatureSpan">npm.</span>audit
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auditCmd(args, cb) {
  if (npm.config.get(&apos;global&apos;)) {
    const err = new Error(&apos;`npm audit` does not support testing globals&apos;)
    err.code = &apos;EAUDITGLOBAL&apos;
    throw err
  }
  if (args.length &amp;&amp; args[0] !== &apos;fix&apos;) {
    return cb(new Error(&apos;Invalid audit subcommand: `&apos; + args[0] + &apos;`\n\nUsage:\n&apos; + auditCmd.usage))
  }
  return Bluebird.all([
    maybeReadFile(&apos;npm-shrinkwrap.json&apos;),
    maybeReadFile(&apos;package-lock.json&apos;),
    maybeReadFile(&apos;package.json&apos;)
  ]).spread((shrinkwrap, lockfile, pkgJson) =&gt; {
    const sw = shrinkwrap || lockfile
    if (!pkgJson) {
      const err = new Error(&apos;No package.json found: Cannot audit a project without a package.json&apos;)
      err.code = &apos;EAUDITNOPJSON&apos;
      throw err
    }
    if (!sw) {
      const err = new Error(&apos;Neither npm-shrinkwrap.json nor package-lock.json found: Cannot audit a project without a lockfile&apos;)
      err.code = &apos;EAUDITNOLOCK&apos;
      throw err
    } else if (shrinkwrap &amp;&amp; lockfile) {
      log.warn(&apos;audit&apos;, &apos;Both npm-shrinkwrap.json and package-lock.json exist, using npm-shrinkwrap.json.&apos;)
    }
    const requires = Object.assign(
      {},
      (pkgJson &amp;&amp; pkgJson.dependencies) || {},
      (pkgJson &amp;&amp; pkgJson.devDependencies) || {}
    )
    return lockVerify(npm.prefix).then(result =&gt; {
      if (result.status) return audit.generate(sw, requires)

      const lockFile = shrinkwrap ? &apos;npm-shrinkwrap.json&apos; : &apos;package-lock.json&apos;
      const err = new Error(`Errors were found in your ${lockFile}, run  npm install  to fix them.\n    ` +
        result.errors.join(&apos;\n    &apos;))
      err.code = &apos;ELOCKVERIFY&apos;
      throw err
    })
  }).then((auditReport) =&gt; {
    return audit.submitForFullReport(auditReport)
  }).catch(err =&gt; {
    if (err.statusCode === 404 || err.statusCode &gt;= 500) {
      const ne = new Error(`Your configured registry (${npm.config.get(&apos;registry&apos;)}) does not support audit requests.`)
      ne.code = &apos;ENOAUDIT&apos;
      ne.wrapped = err
      throw ne
    }
    throw err
  }).then((auditResult) =&gt; {
    if (args[0] === &apos;fix&apos;) {
      const actions = (auditResult.actions || []).reduce((acc, action) =&gt; {
        action = filterEnv(action)
        if (!action) { return acc }
        if (action.isMajor) {
          acc.major.add(`${action.module}@${action.target}`)
          action.resolves.forEach(({id, path}) =&gt; acc.majorFixes.add(`${id}::${path}`))
        } else if (action.action === &apos;install&apos;) {
          acc.install.add(`${action.module}@${action.target}`)
          action.resolves.forEach(({id, path}) =&gt; acc.installFixes.add(`${id}::${path}`))
        } else if (action.action === &apos;update&apos;) {
          const name = action.module
          const version = action.target
          action.resolves.forEach(vuln =&gt; {
            acc.updateFixes.add(`${vuln.id}::${vuln.path}`)
            const modPath = vuln.path.split(&apos;&gt;&apos;)
            const newPath = modPath.slice(
              0, modPath.indexOf(name)
            ).concat(`${name}@${version}`)
            if (newPath.length === 1) {
              acc.install.add(newPath[0])
            } else {
              acc.update.add(newPath.join(&apos;&gt;&apos;))
            }
          })
        } else if (action.action === &apos;review&apos;) {
          action.resolves.forEach(({id, path}) =&gt; acc.review.add(`${id}::${path}`))
        }
        return acc
      }, {
        install: new Set(),
        installFixes: new Set(),
        update: new Set(),
        updateFixes: new Set(),
        major: new Set(),
        majorFixes: new Set(),
        review: new Set()
      })
      return Bluebird.try(() =&gt; {
        const installMajor = npm.config.get(&apos;force&apos;)
        const installCount = actions.install.size + (installMajor ? actions.major.size : 0) + actions.update.si...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.bugs" id="apidoc.element.npm.bugs">
        function <span class="apidocSignatureSpan">npm.</span>bugs
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bugs(args, cb) {
  var n = args.length ? args[0] : &apos;.&apos;
  fetchPackageMetadata(n, &apos;.&apos;, {fullMetadata: true}, function (er, d) {
    if (er) return cb(er)

    var url = d.bugs &amp;&amp; ((typeof d.bugs === &apos;string&apos;) ? d.bugs : d.bugs.url)
    if (!url) {
      url = &apos;https://www.npmjs.org/package/&apos; + d.name
    }
    log.silly(&apos;bugs&apos;, &apos;url&apos;, url)
    openUrl(url, &apos;bug list available at the following URL&apos;, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ci" id="apidoc.element.npm.ci">
        function <span class="apidocSignatureSpan">npm.</span>ci
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ci(args, cb) {
  return new Installer({
    config: npm.config,
    log: npmlog
  })
    .run()
    .then(
      (details) =&gt; {
        npmlog.disableProgress()
        console.error(`added ${details.pkgCount} packages in ${
          details.runTime / 1000
        }s`)
      }
    )
    .then(() =&gt; cb(), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.completion" id="apidoc.element.npm.completion">
        function <span class="apidocSignatureSpan">npm.</span>completion
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function completion(args, cb) {
  if (isWindowsShell) {
    var e = new Error(&apos;npm completion supported only in MINGW / Git bash on Windows&apos;)
    e.code = &apos;ENOTSUP&apos;
    e.errno = require(&apos;constants&apos;).ENOTSUP // eslint-disable-line node/no-deprecated-api
    return cb(e)
  }

  // if the COMP_* isn&apos;t in the env, then just dump the script.
  if (process.env.COMP_CWORD === undefined ||
      process.env.COMP_LINE === undefined ||
      process.env.COMP_POINT === undefined) {
    return dumpScript(cb)
  }

  console.error(process.env.COMP_CWORD)
  console.error(process.env.COMP_LINE)
  console.error(process.env.COMP_POINT)

  // get the partial line and partial word,
  // if the point isn&apos;t at the end.
  // ie, tabbing at: npm foo b|ar
  var w = +process.env.COMP_CWORD
  var words = args.map(unescape)
  var word = words[w]
  var line = process.env.COMP_LINE
  var point = +process.env.COMP_POINT
  var partialLine = line.substr(0, point)
  var partialWords = words.slice(0, w)

  // figure out where in that last word the point is.
  var partialWord = args[w]
  var i = partialWord.length
  while (partialWord.substr(0, i) !== partialLine.substr(-1 * i) &amp;&amp; i &gt; 0) {
    i--
  }
  partialWord = unescape(partialWord.substr(0, i))
  partialWords.push(partialWord)

  var opts = {
    words: words,
    w: w,
    word: word,
    line: line,
    lineLength: line.length,
    point: point,
    partialLine: partialLine,
    partialWords: partialWords,
    partialWord: partialWord,
    raw: args
  }

  cb = wrapCb(cb, opts)

  console.error(opts)

  if (partialWords.slice(0, -1).indexOf(&apos;--&apos;) === -1) {
    if (word.charAt(0) === &apos;-&apos;) return configCompl(opts, cb)
    if (words[w - 1] &amp;&amp;
        words[w - 1].charAt(0) === &apos;-&apos; &amp;&amp;
        !isFlag(words[w - 1])) {
      // awaiting a value for a non-bool config.
      // don&apos;t even try to do this for now
      console.error(&apos;configValueCompl&apos;)
      return configValueCompl(opts, cb)
    }
  }

  // try to find the npm command.
  // it&apos;s the first thing after all the configs.
  // take a little shortcut and use npm&apos;s arg parsing logic.
  // don&apos;t have to worry about the last arg being implicitly
  // boolean&apos;ed, since the last block will catch that.
  var parsed = opts.conf =
    nopt(configTypes, shorthands, partialWords.slice(0, -1), 0)
  // check if there&apos;s a command already.
  console.error(parsed)
  var cmd = parsed.argv.remain[1]
  if (!cmd) return cmdCompl(opts, cb)

  Object.keys(parsed).forEach(function (k) {
    npm.config.set(k, parsed[k])
  })

  // at this point, if words[1] is some kind of npm command,
  // then complete on it.
  // otherwise, do nothing
  cmd = npm.commands[cmd]
  if (cmd &amp;&amp; cmd.completion) return cmd.completion(opts, cb)

  // nothing to do.
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.dedupe" id="apidoc.element.npm.dedupe">
        function <span class="apidocSignatureSpan">npm.</span>dedupe
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dedupe(args, cb) {
  validate(&apos;AF&apos;, arguments)
  // the /path/to/node_modules/..
  var where = path.resolve(npm.dir, &apos;..&apos;)
  var dryrun = false
  if (npm.command.match(/^find/)) dryrun = true
  if (npm.config.get(&apos;dry-run&apos;)) dryrun = true
  if (dryrun &amp;&amp; !npm.config.get(&apos;json&apos;)) npm.config.set(&apos;parseable&apos;, true)

  new Deduper(where, dryrun).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deprecate" id="apidoc.element.npm.deprecate">
        function <span class="apidocSignatureSpan">npm.</span>deprecate
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecate(args, cb) {
  var pkg = args[0]
  var msg = args[1]
  if (msg === undefined) return cb(&apos;Usage: &apos; + deprecate.usage)

  // fetch the data and make sure it exists.
  var p = npa(pkg)

  // npa makes the default spec &quot;latest&quot;, but for deprecation
  // &quot;*&quot; is the appropriate default.
  var spec = p.rawSpec === &apos;&apos; ? &apos;*&apos; : p.fetchSpec

  mapToRegistry(p.name, npm.config, function (er, uri, auth) {
    if (er) return cb(er)

    var params = {
      version: spec,
      message: msg,
      auth: auth
    }
    npm.registry.deprecate(uri, params, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (er) return cb(er)

    var params = {
      version: spec,
      message: msg,
      auth: auth
    }
    npm.registry.<span class="apidocCodeKeywordSpan">deprecate</span>(uri, params, cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deref" id="apidoc.element.npm.deref">
        function <span class="apidocSignatureSpan">npm.</span>deref
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deref = function (c) {
  if (!c) return &apos;&apos;
  if (c.match(/[A-Z]/)) {
    c = c.replace(/([A-Z])/g, function (m) {
      return &apos;-&apos; + m.toLowerCase()
    })
  }
  if (plumbing.indexOf(c) !== -1) return c
  var a = abbrevs[c]
  while (aliases[a]) {
    a = aliases[a]
  }
  return a
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  process.argv.splice(1, 1, &apos;npm&apos;, &apos;-g&apos;)
}

log.verbose(&apos;cli&apos;, process.argv)

var conf = nopt(types, shorthands)
npm.argv = conf.argv.remain
if (npm.<span class="apidocCodeKeywordSpan">deref</span>(npm.argv[0])) npm.command = npm.argv.shift()
else conf.usage = true

if (conf.version) {
  console.log(npm.version)
  return errorHandler.exit(0)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.diff_trees" id="apidoc.element.npm.diff_trees">
        function <span class="apidocSignatureSpan">npm.</span>diff_trees
        <span class="apidocSignatureSpan">(oldTree, newTree, differences, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff_trees = function (oldTree, newTree, differences, log, next) {
  validate(&apos;OOAOF&apos;, arguments)
  pushAll(differences, sortActions(diffTrees(oldTree, newTree)))
  log.finish()
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.edit" id="apidoc.element.npm.edit">
        function <span class="apidocSignatureSpan">npm.</span>edit
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function edit(args, cb) {
  var p = args[0]
  if (args.length !== 1 || !p) return cb(edit.usage)
  var e = npm.config.get(&apos;editor&apos;)
  if (!e) {
    return cb(new Error(
      &quot;No editor set.  Set the &apos;editor&apos; config, or $EDITOR environ.&quot;
    ))
  }
  p = p.split(&apos;/&apos;)
    .join(&apos;/node_modules/&apos;)
    .replace(/(\/node_modules)+/, &apos;/node_modules&apos;)
  var f = path.resolve(npm.dir, p)
  fs.lstat(f, function (er) {
    if (er) return cb(er)
    editor(f, { editor: e }, noProgressTillDone(function (er) {
      if (er) return cb(er)
      npm.commands.rebuild(args, cb)
    }))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.error_handler" id="apidoc.element.npm.error_handler">
        function <span class="apidocSignatureSpan">npm.</span>error_handler
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errorHandler(er) {
  log.disableProgress()
  if (!npm.config || !npm.config.loaded) {
    // logging won&apos;t work unless we pretend that it&apos;s ready
    er = er || new Error(&apos;Exit prior to config file resolving.&apos;)
    console.error(er.stack || er.message)
  }

  if (cbCalled) {
    er = er || new Error(&apos;Callback called more than once.&apos;)
  }

  cbCalled = true
  if (!er) return exit(0)
  if (typeof er === &apos;string&apos;) {
    log.error(&apos;&apos;, er)
    return exit(1, true)
  } else if (!(er instanceof Error)) {
    log.error(&apos;weird error&apos;, er)
    return exit(1, true)
  }

  var m = er.code || er.message.match(/^(?:Error: )?(E[A-Z]+)/)
  if (m &amp;&amp; !er.code) {
    er.code = m
  }

  ;[
    &apos;type&apos;,
    &apos;stack&apos;,
    &apos;statusCode&apos;,
    &apos;pkgid&apos;
  ].forEach(function (k) {
    var v = er[k]
    if (!v) return
    log.verbose(k, v)
  })

  log.verbose(&apos;cwd&apos;, process.cwd())

  var os = require(&apos;os&apos;)
  log.verbose(&apos;&apos;, os.type() + &apos; &apos; + os.release())
  log.verbose(&apos;argv&apos;, process.argv.map(JSON.stringify).join(&apos; &apos;))
  log.verbose(&apos;node&apos;, process.version)
  log.verbose(&apos;npm &apos;, &apos;v&apos; + npm.version)

  ;[
    &apos;file&apos;,
    &apos;path&apos;,
    &apos;code&apos;,
    &apos;errno&apos;,
    &apos;syscall&apos;
  ].forEach(function (k) {
    var v = er[k]
    if (v) log.error(k, v)
  })

  var msg = errorMessage(er)
  msg.summary.concat(msg.detail).forEach(function (errline) {
    log.error.apply(log, errline)
  })
  if (npm.config.get(&apos;json&apos;)) {
    var error = {
      error: {
        code: er.code,
        summary: messageText(msg.summary),
        detail: messageText(msg.detail)
      }
    }
    console.log(JSON.stringify(error, null, 2))
  }

  exit(typeof er.errno === &apos;number&apos; ? er.errno : 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.exists" id="apidoc.element.npm.exists">
        function <span class="apidocSignatureSpan">npm.</span>exists
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight(&apos;exists:&apos; + dir, done)
  if (!done) return
  fs.access(dir, fs.F_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.explore" id="apidoc.element.npm.explore">
        function <span class="apidocSignatureSpan">npm.</span>explore
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function explore(args, cb) {
  if (args.length &lt; 1 || !args[0]) return cb(explore.usage)
  var p = args.shift()

  var cwd = path.resolve(npm.dir, p)
  var opts = {cwd: cwd, stdio: &apos;inherit&apos;}

  var shellArgs = []
  if (args) {
    if (isWindowsShell) {
      var execCmd = escapeExecPath(args.shift())
      var execArgs = [execCmd].concat(args.map(escapeArg))
      opts.windowsVerbatimArguments = true
      shellArgs = [&apos;/d&apos;, &apos;/s&apos;, &apos;/c&apos;].concat(execArgs)
    } else {
      shellArgs.unshift(&apos;-c&apos;)
      shellArgs = [&apos;-c&apos;, args.map(escapeArg).join(&apos; &apos;).trim()]
    }
  }

  var sh = npm.config.get(&apos;shell&apos;)
  fs.stat(cwd, function (er, s) {
    if (er || !s.isDirectory()) {
      return cb(new Error(
        &quot;It doesn&apos;t look like &quot; + p + &apos; is installed.&apos;
      ))
    }

    if (!shellArgs.length) {
      output(
        &apos;\nExploring &apos; + cwd + &apos;\n&apos; +
          &quot;Type &apos;exit&apos; or ^D when finished\n&quot;
      )
    }

    var shell = spawn(sh, shellArgs, opts)
    shell.on(&apos;close&apos;, function (er) {
      // only fail if non-interactive.
      if (!shellArgs.length) return cb()
      cb(er)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.extract" id="apidoc.element.npm.extract">
        function <span class="apidocSignatureSpan">npm.</span>extract
        <span class="apidocSignatureSpan">(staging, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extract(staging, pkg, log) {
  log.silly(&apos;extract&apos;, packageId(pkg))
  const extractTo = moduleStagingPath(staging, pkg)
  if (!pacoteOpts) {
    pacoteOpts = require(&apos;../../config/pacote&apos;)
  }
  const opts = pacoteOpts({
    integrity: pkg.package._integrity,
    resolved: pkg.package._resolved
  })
  const args = [
    pkg.package._requested,
    extractTo,
    opts
  ]
  return BB.fromNode((cb) =&gt; {
    let launcher = localWorker
    let msg = args
    const spec = typeof args[0] === &apos;string&apos; ? npa(args[0]) : args[0]
    args[0] = spec.raw
    if (ENABLE_WORKERS &amp;&amp; (isRegistry(spec) || spec.type === &apos;remote&apos;)) {
      // We can&apos;t serialize these options
      opts.loglevel = opts.log.level
      opts.log = null
      opts.dirPacker = null
      // workers will run things in parallel!
      launcher = workers
      try {
        msg = JSON.stringify(msg)
      } catch (e) {
        return cb(e)
      }
    }
    launcher(msg, cb)
  }).then(() =&gt; {
    if (pkg.package.bundleDependencies || anyBundled(pkg)) {
      return readBundled(pkg, staging, extractTo)
    }
  }).then(() =&gt; {
    return gentlyRm(path.join(extractTo, &apos;node_modules&apos;))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  })
}

cache.unpack = unpack
function unpack (pkg, ver, unpackTarget, dmode, fmode, uid, gid) {
  return unbuild([unpackTarget], true).then(() =&gt; {
    const opts = pacoteOpts({dmode, fmode, uid, gid, offline: true})
    return pacote.<span class="apidocCodeKeywordSpan">extract</span>(npa.resolve(pkg, ver), unpackTarget, opts)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.fetch_package_metadata" id="apidoc.element.npm.fetch_package_metadata">
        function <span class="apidocSignatureSpan">npm.</span>fetch_package_metadata
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function limited() {
  var self = this
  var args = Array.prototype.slice.call(arguments)
  if (running &gt;= maxRunning) {
    queue.push({self: this, args: args})
    return
  }
  var cb = typeof args[args.length-1] === &apos;function&apos; &amp;&amp; args.pop()
  ++ running
  args.push(function () {
    var cbargs = arguments
    -- running
    cb &amp;&amp; process.nextTick(function () {
      cb.apply(self, cbargs)
    })
    if (queue.length) {
      var next = queue.shift()
      limited.apply(next.self, next.args)
    }
  })
  func.apply(self, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.finalize" id="apidoc.element.npm.finalize">
        function <span class="apidocSignatureSpan">npm.</span>finalize
        <span class="apidocSignatureSpan">(staging, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function (staging, pkg, log) {
  log.silly(&apos;finalize&apos;, pkg.realpath)

  const extractedTo = moduleStagingPath(staging, pkg)

  const delpath = path.join(path.dirname(pkg.realpath), &apos;.&apos; + path.basename(pkg.realpath) + &apos;.DELETE&apos;)
  let movedDestAway = false

  const requested = pkg.package._requested || getRequested(pkg)
  if (requested.type === &apos;directory&apos;) {
    const relative = path.relative(path.dirname(pkg.path), pkg.realpath)
    return makeParentPath(pkg.path)
      .then(() =&gt; symlink(relative, pkg.path, &apos;junction&apos;))
      .catch((ex) =&gt; {
        return rimraf(pkg.path).then(() =&gt; symlink(relative, pkg.path, &apos;junction&apos;))
      })
  } else {
    return makeParentPath(pkg.realpath)
      .then(moveStagingToDestination)
      .then(restoreOldNodeModules)
      .catch((err) =&gt; {
        if (movedDestAway) {
          return rimraf(pkg.realpath).then(moveOldDestinationBack).then(() =&gt; {
            throw err
          })
        } else {
          throw err
        }
      })
      .then(() =&gt; rimraf(delpath))
  }

  function makeParentPath (dir) {
    return mkdirp(path.dirname(dir))
  }

  function moveStagingToDestination () {
    return destinationIsClear()
      .then(actuallyMoveStaging)
      .catch(() =&gt; moveOldDestinationAway().then(actuallyMoveStaging))
  }

  function destinationIsClear () {
    return lstat(pkg.realpath).then(() =&gt; {
      throw new Error(&apos;destination exists&apos;)
    }, () =&gt; {})
  }

  function actuallyMoveStaging () {
    return move(extractedTo, pkg.realpath, moveOpts)
  }

  function moveOldDestinationAway () {
    return rimraf(delpath).then(() =&gt; {
      return move(pkg.realpath, delpath, moveOpts)
    }).then(() =&gt; { movedDestAway = true })
  }

  function moveOldDestinationBack () {
    return move(delpath, pkg.realpath, moveOpts).then(() =&gt; { movedDestAway = false })
  }

  function restoreOldNodeModules () {
    if (!movedDestAway) return
    return readdir(path.join(delpath, &apos;node_modules&apos;)).catch(() =&gt; []).then((modules) =&gt; {
      if (!modules.length) return
      return mkdirp(path.join(pkg.realpath, &apos;node_modules&apos;)).then(() =&gt; Bluebird.map(modules, (file) =&gt; {
        const from = path.join(delpath, &apos;node_modules&apos;, file)
        const to = path.join(pkg.realpath, &apos;node_modules&apos;, file)
        return move(from, to, moveOpts)
      }))
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.flatten_tree" id="apidoc.element.npm.flatten_tree">
        function <span class="apidocSignatureSpan">npm.</span>flatten_tree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenTree(tree) {
  validate(&apos;O&apos;, arguments)
  var seen = new Set()
  var flat = {}
  var todo = [[tree, &apos;/&apos;]]
  while (todo.length) {
    var next = todo.shift()
    var pkg = next[0]
    seen.add(pkg)
    var path = next[1]
    flat[path] = pkg
    if (path !== &apos;/&apos;) path += &apos;/&apos;
    for (var ii = 0; ii &lt; pkg.children.length; ++ii) {
      var child = pkg.children[ii]
      if (!seen.has(child)) {
        todo.push([child, flatName(path, child)])
      }
    }
  }
  return flat
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.help" id="apidoc.element.npm.help">
        function <span class="apidocSignatureSpan">npm.</span>help
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function help(args, cb) {
  var argv = npm.config.get(&apos;argv&apos;).cooked

  var argnum = 0
  if (args.length === 2 &amp;&amp; ~~args[0]) {
    argnum = ~~args.shift()
  }

  // npm help foo bar baz: search topics
  if (args.length &gt; 1 &amp;&amp; args[0]) {
    return npm.commands[&apos;help-search&apos;](args, argnum, cb)
  }

  var section = npm.deref(args[0]) || args[0]

  // npm help &lt;noargs&gt;:  show basic usage
  if (!section) {
    var valid = argv[0] === &apos;help&apos; ? 0 : 1
    return npmUsage(valid, cb)
  }

  // npm &lt;command&gt; -h: show command usage
  if (npm.config.get(&apos;usage&apos;) &amp;&amp;
      npm.commands[section] &amp;&amp;
      npm.commands[section].usage) {
    npm.config.set(&apos;loglevel&apos;, &apos;silent&apos;)
    log.level = &apos;silent&apos;
    output(npm.commands[section].usage)
    return cb()
  }

  // npm apihelp &lt;section&gt;: Prefer section 3 over section 1
  var apihelp = argv.length &amp;&amp; argv[0].indexOf(&apos;api&apos;) !== -1
  var pref = apihelp ? [3, 1, 5, 7] : [1, 3, 5, 7]
  if (argnum) {
    pref = [ argnum ].concat(pref.filter(function (n) {
      return n !== argnum
    }))
  }

  // npm help &lt;section&gt;: Try to find the path
  var manroot = path.resolve(__dirname, &apos;..&apos;, &apos;man&apos;)

  // legacy
  if (section === &apos;global&apos;) section = &apos;folders&apos;
  else if (section === &apos;json&apos;) section = &apos;package.json&apos;

  // find either /section.n or /npm-section.n
  // The glob is used in the glob.  The regexp is used much
  // further down.  Globs and regexps are different
  var compextglob = &apos;.+(gz|bz2|lzma|[FYzZ]|xz)&apos;
  var compextre = &apos;\\.(gz|bz2|lzma|[FYzZ]|xz)$&apos;
  var f = &apos;+(npm-&apos; + section + &apos;|&apos; + section + &apos;).[0-9]?(&apos; + compextglob + &apos;)&apos;
  return glob(manroot + &apos;/*/&apos; + f, function (er, mans) {
    if (er) return cb(er)

    if (!mans.length) return npm.commands[&apos;help-search&apos;](args, cb)

    mans = mans.map(function (man) {
      var ext = path.extname(man)
      if (man.match(new RegExp(compextre))) man = path.basename(man, ext)

      return man
    })

    viewMan(pickMan(mans, pref), cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    hits: found,
    totalHits: totalHits
  })
})

// if only one result, then just show that help section.
if (results.length === 1) {
  return npm.commands.<span class="apidocCodeKeywordSpan">help</span>([results[0].file.replace(/\.md$/, &apos;&apos;)], cb)
}

if (results.length === 0) {
  output(&apos;No results for &apos; + args.map(JSON.stringify).join(&apos; &apos;))
  return cb()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.install" id="apidoc.element.npm.install">
        function <span class="apidocSignatureSpan">npm.</span>install
        <span class="apidocSignatureSpan">(where, args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function install(where, args, cb) {
  if (!cb) {
    cb = args
    args = where
    where = null
  }
  var globalTop = path.resolve(npm.globalDir, &apos;..&apos;)
  if (!where) {
    where = npm.config.get(&apos;global&apos;)
      ? globalTop
      : npm.prefix
  }
  validate(&apos;SAF&apos;, [where, args, cb])
  // the /path/to/node_modules/..
  var dryrun = !!npm.config.get(&apos;dry-run&apos;)

  if (npm.config.get(&apos;dev&apos;)) {
    log.warn(&apos;install&apos;, &apos;Usage of the `--dev` option is deprecated. Use `--only=dev` instead.&apos;)
  }

  if (where === globalTop &amp;&amp; !args.length) {
    args = [&apos;.&apos;]
  }
  args = args.filter(function (a) {
    return path.resolve(a) !== npm.prefix
  })

  new Installer(where, dryrun, args).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// if it&apos;s a folder, a random not-installed thing, or not a scoped package,
// then link or install it first
if (pkg[0] !== &apos;@&apos; &amp;&amp; (pkg.indexOf(&apos;/&apos;) !== -1 || pkg.indexOf(&apos;\\&apos;) !== -1)) {
  return fs.lstat(path.resolve(pkg), function (er, st) {
    if (er || !st.isDirectory()) {
      npm.commands.<span class="apidocCodeKeywordSpan">install</span>(t, pkg, n)
    } else {
      rp = path.resolve(pkg)
      linkPkg(rp, n)
    }
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.link" id="apidoc.element.npm.link">
        function <span class="apidocSignatureSpan">npm.</span>link
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function link(args, cb) {
  if (process.platform === &apos;win32&apos;) {
    var semver = require(&apos;semver&apos;)
    if (!semver.gte(process.version, &apos;0.7.9&apos;)) {
      var msg = &apos;npm link not supported on windows prior to node 0.7.9&apos;
      var e = new Error(msg)
      e.code = &apos;ENOTSUP&apos;
      e.errno = require(&apos;constants&apos;).ENOTSUP // eslint-disable-line node/no-deprecated-api
      return cb(e)
    }
  }

  if (npm.config.get(&apos;global&apos;)) {
    return cb(new Error(
      &apos;link should never be --global.\n&apos; +
      &apos;Please re-run this command with --local&apos;
    ))
  }

  if (args.length === 1 &amp;&amp; args[0] === &apos;.&apos;) args = []
  if (args.length) return linkInstall(args, cb)
  linkPkg(npm.prefix, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.load" id="apidoc.element.npm.load">
        function <span class="apidocSignatureSpan">npm.</span>load
        <span class="apidocSignatureSpan">(cli, cb_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (cli, cb_) {
  if (!cb_ &amp;&amp; typeof cli === &apos;function&apos;) {
    cb_ = cli
    cli = {}
  }
  if (!cb_) cb_ = function () {}
  if (!cli) cli = {}
  loadListeners.push(cb_)
  if (loaded || loadErr) return cb(loadErr)
  if (loading) return
  loading = true
  var onload = true

  function cb (er) {
    if (loadErr) return
    loadErr = er
    if (er) return cb_(er)
    if (npm.config.get(&apos;force&apos;)) {
      log.warn(&apos;using --force&apos;, &apos;I sure hope you know what you are doing.&apos;)
    }
    npm.config.loaded = true
    loaded = true
    loadCb(loadErr = er)
    onload = onload &amp;&amp; npm.config.get(&apos;onload-script&apos;)
    if (onload) {
      try {
        require(onload)
      } catch (err) {
        log.warn(&apos;onload-script&apos;, &apos;failed to require onload script&apos;, onload)
        log.warn(&apos;onload-script&apos;, err)
      }
      onload = false
    }
  }

  log.pause()

  load(npm, cli, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.argv.unshift(npm.command)
  npm.command = &apos;help&apos;
}

// now actually fire up npm and run the command.
// this is how to use npm programmatically:
conf._exit = true
npm.<span class="apidocCodeKeywordSpan">load</span>(conf, function (er) {
  if (er) return errorHandler(er)
  if (!unsupported.checkVersion(process.version).unsupported) {
    const pkg = require(&apos;../package.json&apos;)
    let notifier = require(&apos;update-notifier&apos;)({pkg})
    if (
      notifier.update &amp;&amp;
      notifier.update.latest !== pkg.version
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ls" id="apidoc.element.npm.ls">
        function <span class="apidocSignatureSpan">npm.</span>ls
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ls(args, silent, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }
  var dir = path.resolve(npm.dir, &apos;..&apos;)
  readPackageTree(dir, function (_, physicalTree) {
    if (!physicalTree) physicalTree = {package: {}, path: dir}
    physicalTree.isTop = true
    readShrinkwrap.andInflate(physicalTree, function () {
      lsFromTree(dir, computeMetadata(physicalTree), args, silent, cb)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        npm.config.get(&apos;unicode&apos;) ? &apos;  &apos; : &apos; -&gt; &apos;
      } ${hook.endpoint}`)
    }
  })
}

function ls (pkg) {
return hookApi.<span class="apidocCodeKeywordSpan">ls</span>(pkg, config())
  .then((hooks) =&gt; {
    if (npm.config.get(&apos;json&apos;)) {
      output(JSON.stringify(hooks, null, 2))
    } else if (!hooks.length) {
      output(&quot;You don&apos;t have any hooks configured yet.&quot;)
    } else {
      if (hooks.length === 1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.mutate_into_logical_tree" id="apidoc.element.npm.mutate_into_logical_tree">
        function <span class="apidocSignatureSpan">npm.</span>mutate_into_logical_tree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mutate_into_logical_tree = function (tree) {
  validate(&apos;O&apos;, arguments)

  validateAllPeerDeps(tree, function (tree, pkgname, version) {
    if (!tree.missingPeers) tree.missingPeers = {}
    tree.missingPeers[pkgname] = version
  })

  var flat = flattenTree(tree)

  Object.keys(flat).sort().forEach(function (flatname) {
    var node = flat[flatname]
    if (!(node.requiredBy &amp;&amp; node.requiredBy.length)) return

    if (node.parent) {
      // If a node is a cycle that never reaches the root of the logical
      // tree then we&apos;ll leave it attached to the root, or else it
      // would go missing. Further we&apos;ll note that this is the node in the
      // cycle that we picked arbitrarily to be the one attached to the root.
      // others will fall
      if (isDisconnectedCycle(node)) {
        node.cycleTop = true
      // Nor do we want to disconnect non-cyclical extraneous modules from the tree.
      } else if (node.requiredBy.length) {
        // regular deps though, we do, as we&apos;re moving them into the capable
        // hands of the modules that require them.
        node.parent.children = without(node.parent.children, node)
      }
    }

    node.requiredBy.forEach(function (parentNode) {
      parentNode.children = union(parentNode.children, [node])
    })
  })
  return tree
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.owner" id="apidoc.element.npm.owner">
        function <span class="apidocSignatureSpan">npm.</span>owner
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function owner(args, cb) {
  var action = args.shift()
  switch (action) {
    case &apos;ls&apos;: case &apos;list&apos;: return ls(args[0], cb)
    case &apos;add&apos;: return add(args[0], args[1], cb)
    case &apos;rm&apos;: case &apos;remove&apos;: return rm(args[0], args[1], cb)
    default: return unknown(action, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack" id="apidoc.element.npm.pack">
        function <span class="apidocSignatureSpan">npm.</span>pack
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pack(args, silent, cb) {
  const cwd = process.cwd()
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }

  if (args.length === 0) args = [&apos;.&apos;]

  BB.all(
    args.map((arg) =&gt; pack_(arg, cwd))
  ).then((tarballs) =&gt; {
    if (!silent &amp;&amp; npm.config.get(&apos;json&apos;)) {
      output(JSON.stringify(tarballs, null, 2))
    } else if (!silent) {
      tarballs.forEach(logContents)
      output(tarballs.map((f) =&gt; path.relative(cwd, f.filename)).join(&apos;\n&apos;))
    }
    return tarballs
  }).nodeify(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.parse_json" id="apidoc.element.npm.parse_json">
        function <span class="apidocSignatureSpan">npm.</span>parse_json
        <span class="apidocSignatureSpan">(content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_json = function (content) {
  return parseJsonWithErrors(stripBOM(content))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.profile" id="apidoc.element.npm.profile">
        function <span class="apidocSignatureSpan">npm.</span>profile
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function profileCmd(args, cb) {
  if (args.length === 0) return cb(new Error(profileCmd.usage))
  log.gauge.show(&apos;profile&apos;)
  switch (args[0]) {
    case &apos;enable-2fa&apos;:
    case &apos;enable-tfa&apos;:
    case &apos;enable2fa&apos;:
    case &apos;enabletfa&apos;:
      withCb(enable2fa(args.slice(1)), cb)
      break
    case &apos;disable-2fa&apos;:
    case &apos;disable-tfa&apos;:
    case &apos;disable2fa&apos;:
    case &apos;disabletfa&apos;:
      withCb(disable2fa(), cb)
      break
    case &apos;get&apos;:
      withCb(get(args.slice(1)), cb)
      break
    case &apos;set&apos;:
      withCb(set(args.slice(1)), cb)
      break
    default:
      cb(new Error(&apos;Unknown profile command: &apos; + args[0]))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.prune" id="apidoc.element.npm.prune">
        function <span class="apidocSignatureSpan">npm.</span>prune
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prune(args, cb) {
  var dryrun = !!npm.config.get(&apos;dry-run&apos;)
  new Pruner(&apos;.&apos;, dryrun, args).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.publish" id="apidoc.element.npm.publish">
        function <span class="apidocSignatureSpan">npm.</span>publish
        <span class="apidocSignatureSpan">(args, isRetry, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(args, isRetry, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = isRetry
    isRetry = false
  }
  if (args.length === 0) args = [&apos;.&apos;]
  if (args.length !== 1) return cb(publish.usage)

  log.verbose(&apos;publish&apos;, args)

  const t = npm.config.get(&apos;tag&apos;).trim()
  if (semver.validRange(t)) {
    return cb(new Error(&apos;Tag name must not be a valid SemVer range: &apos; + t))
  }

  return publish_(args[0])
    .then((tarball) =&gt; {
      const silent = log.level === &apos;silent&apos;
      if (!silent &amp;&amp; npm.config.get(&apos;json&apos;)) {
        output(JSON.stringify(tarball, null, 2))
      } else if (!silent) {
        output(`+ ${tarball.id}`)
      }
    })
    .nodeify(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (npm.config.get(&apos;dry-run&apos;)) {
  log.verbose(&apos;publish&apos;, &apos;--dry-run mode enabled. Skipping upload.&apos;)
  return BB.resolve()
}

log.showProgress(&apos;publish:&apos; + pkg._id)
return BB.fromNode((cb) =&gt; {
  registry.<span class="apidocCodeKeywordSpan">publish</span>(registryBase, params, cb)
}).catch((err) =&gt; {
  if (
    err.code === &apos;EPUBLISHCONFLICT&apos; &amp;&amp;
    npm.config.get(&apos;force&apos;) &amp;&amp;
    !isRetry
  ) {
    log.warn(&apos;publish&apos;, &apos;Forced publish over &apos; + pkg._id)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pulse_till_done" id="apidoc.element.npm.pulse_till_done">
        function <span class="apidocSignatureSpan">npm.</span>pulse_till_done
        <span class="apidocSignatureSpan">(prefix, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pulse_till_done = function (prefix, cb) {
  validate(&apos;SF&apos;, [prefix, cb])
  if (!prefix) prefix = &apos;network&apos;
  pulseStart(prefix)
  return function () {
    pulseStop()
    cb.apply(null, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap" id="apidoc.element.npm.read_shrinkwrap">
        function <span class="apidocSignatureSpan">npm.</span>read_shrinkwrap
        <span class="apidocSignatureSpan">(child, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readShrinkwrap(child, next) {
  if (child.package._shrinkwrap) return process.nextTick(next)
  BB.join(
    maybeReadFile(&apos;npm-shrinkwrap.json&apos;, child),
    // Don&apos;t read non-root lockfiles
    child.isTop &amp;&amp; maybeReadFile(&apos;package-lock.json&apos;, child),
    child.isTop &amp;&amp; maybeReadFile(&apos;package.json&apos;, child),
    (shrinkwrap, lockfile, pkgJson) =&gt; {
      if (shrinkwrap &amp;&amp; lockfile) {
        log.warn(&apos;read-shrinkwrap&apos;, &apos;Ignoring package-lock.json because there is already an npm-shrinkwrap.json. Please use only
 one of the two.&apos;)
      }
      const name = shrinkwrap ? &apos;npm-shrinkwrap.json&apos; : &apos;package-lock.json&apos;
      const parsed = parsePkgLock(shrinkwrap || lockfile, name)
      if (parsed &amp;&amp; parsed.lockfileVersion !== PKGLOCK_VERSION) {
        log.warn(&apos;read-shrinkwrap&apos;, `This version of npm is compatible with lockfileVersion@${PKGLOCK_VERSION}, but ${name} was
generated for lockfileVersion@${parsed.lockfileVersion || 0}. I&apos;ll try to do my best with it!`)
      }
      child.package._shrinkwrap = parsed
    }
  ).then(() =&gt; next(), next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.rebuild" id="apidoc.element.npm.rebuild">
        function <span class="apidocSignatureSpan">npm.</span>rebuild
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rebuild(args, cb) {
  var opt = { depth: npm.config.get(&apos;depth&apos;), dev: true }
  readInstalled(npm.prefix, opt, function (er, data) {
    log.info(&apos;readInstalled&apos;, typeof data)
    if (er) return cb(er)
    var set = filter(data, args)
    var folders = Object.keys(set).filter(function (f) {
      return f !== npm.prefix
    })
    if (!folders.length) return cb()
    log.silly(&apos;rebuild set&apos;, folders)
    cleanBuild(folders, set, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .join(&apos;/node_modules/&apos;)
    .replace(/(\/node_modules)+/, &apos;/node_modules&apos;)
  var f = path.resolve(npm.dir, p)
  fs.lstat(f, function (er) {
    if (er) return cb(er)
    editor(f, { editor: e }, noProgressTillDone(function (er) {
      if (er) return cb(er)
      npm.commands.<span class="apidocCodeKeywordSpan">rebuild</span>(args, cb)
    }))
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.repo" id="apidoc.element.npm.repo">
        function <span class="apidocSignatureSpan">npm.</span>repo
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repo(args, cb) {
  var n = args.length ? args[0] : &apos;.&apos;
  fetchPackageMetadata(n, &apos;.&apos;, {fullMetadata: true}, function (er, d) {
    if (er) return cb(er)
    getUrlAndOpen(d, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.restart" id="apidoc.element.npm.restart">
        function <span class="apidocSignatureSpan">npm.</span>restart
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands[&apos;run-script&apos;]([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.run_script" id="apidoc.element.npm.run_script">
        function <span class="apidocSignatureSpan">npm.</span>run_script
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runScript(args, cb) {
  if (!args.length) return list(cb)

  var pkgdir = npm.localPrefix
  var cmd = args.shift()

  readJson(path.resolve(pkgdir, &apos;package.json&apos;), function (er, d) {
    if (er) return cb(er)
    run(d, pkgdir, cmd, args, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.save_stack" id="apidoc.element.npm.save_stack">
        function <span class="apidocSignatureSpan">npm.</span>save_stack
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SaveStack(fn) {
  Error.call(this)
  Error.captureStackTrace(this, fn || SaveStack)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.search" id="apidoc.element.npm.search">
        function <span class="apidocSignatureSpan">npm.</span>search
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function search(args, cb) {
  var searchOpts = {
    description: npm.config.get(&apos;description&apos;),
    exclude: prepareExcludes(npm.config.get(&apos;searchexclude&apos;)),
    include: prepareIncludes(args, npm.config.get(&apos;searchopts&apos;)),
    limit: npm.config.get(&apos;searchlimit&apos;),
    log: log,
    staleness: npm.config.get(&apos;searchstaleness&apos;),
    unicode: npm.config.get(&apos;unicode&apos;)
  }

  if (searchOpts.include.length === 0) {
    return cb(new Error(&apos;search must be called with arguments&apos;))
  }

  // Used later to figure out whether we had any packages go out
  var anyOutput = false

  var entriesStream = ms.through.obj()

  var esearchWritten = false
  esearch(searchOpts).on(&apos;data&apos;, function (pkg) {
    entriesStream.write(pkg)
    !esearchWritten &amp;&amp; (esearchWritten = true)
  }).on(&apos;error&apos;, function (e) {
    if (esearchWritten) {
      // If esearch errored after already starting output, we can&apos;t fall back.
      return entriesStream.emit(&apos;error&apos;, e)
    }
    log.warn(&apos;search&apos;, &apos;fast search endpoint errored. Using old search.&apos;)
    allPackageSearch(searchOpts).on(&apos;data&apos;, function (pkg) {
      entriesStream.write(pkg)
    }).on(&apos;error&apos;, function (e) {
      entriesStream.emit(&apos;error&apos;, e)
    }).on(&apos;end&apos;, function () {
      entriesStream.end()
    })
  }).on(&apos;end&apos;, function () {
    entriesStream.end()
  })

  // Grab a configured output stream that will spit out packages in the
  // desired format.
  var outputStream = formatPackageStream({
    args: args, // --searchinclude options are not highlighted
    long: npm.config.get(&apos;long&apos;),
    description: npm.config.get(&apos;description&apos;),
    json: npm.config.get(&apos;json&apos;),
    parseable: npm.config.get(&apos;parseable&apos;),
    color: npm.color
  })
  outputStream.on(&apos;data&apos;, function (chunk) {
    if (!anyOutput) { anyOutput = true }
    output(chunk.toString(&apos;utf8&apos;))
  })

  log.silly(&apos;search&apos;, &apos;searching packages&apos;)
  ms.pipe(entriesStream, outputStream, function (er) {
    if (er) return cb(er)
    if (!anyOutput &amp;&amp; !npm.config.get(&apos;json&apos;) &amp;&amp; !npm.config.get(&apos;parseable&apos;)) {
      output(&apos;No matches found for &apos; + (args.map(JSON.stringify).join(&apos; &apos;)))
    }
    log.silly(&apos;search&apos;, &apos;search completed&apos;)
    log.clearProgress()
    cb(null, {})
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.shrinkwrap" id="apidoc.element.npm.shrinkwrap">
        function <span class="apidocSignatureSpan">npm.</span>shrinkwrap
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shrinkwrap(args, silent, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }

  if (args.length) {
    log.warn(&apos;shrinkwrap&apos;, &quot;doesn&apos;t take positional args&quot;)
  }

  move(
    path.resolve(npm.prefix, PKGLOCK),
    path.resolve(npm.prefix, SHRINKWRAP),
    { Promise: BB }
  ).then(() =&gt; {
    log.notice(&apos;&apos;, `${PKGLOCK} has been renamed to ${SHRINKWRAP}. ${SHRINKWRAP} will be used for future installations.`)
    return readFile(path.resolve(npm.prefix, SHRINKWRAP)).then((d) =&gt; {
      return JSON.parse(d)
    })
  }, (err) =&gt; {
    if (err.code !== &apos;ENOENT&apos;) {
      throw err
    } else {
      return readPackageTree(npm.localPrefix).then(
        id.computeMetadata
      ).then((tree) =&gt; {
        return BB.fromNode((cb) =&gt; {
          createShrinkwrap(tree, {
            silent,
            defaultFile: SHRINKWRAP
          }, cb)
        })
      })
    }
  }).then((data) =&gt; cb(null, data), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.star" id="apidoc.element.npm.star">
        function <span class="apidocSignatureSpan">npm.</span>star
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function star(args, cb) {
  if (!args.length) return cb(star.usage)
  var s = npm.config.get(&apos;unicode&apos;) ? &apos;\u2605 &apos; : &apos;(*)&apos;
  var u = npm.config.get(&apos;unicode&apos;) ? &apos;\u2606 &apos; : &apos;( )&apos;
  var using = !(npm.command.match(/^un/))
  if (!using) s = u
  asyncMap(args, function (pkg, cb) {
    mapToRegistry(pkg, npm.config, function (er, uri, auth) {
      if (er) return cb(er)

      var params = {
        starred: using,
        auth: auth
      }
      npm.registry.star(uri, params, function (er, data, raw, req) {
        if (!er) {
          output(s + &apos; &apos; + pkg)
          log.verbose(&apos;star&apos;, data)
        }
        cb(er, data, raw, req)
      })
    })
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
mapToRegistry(pkg, npm.config, function (er, uri, auth) {
  if (er) return cb(er)

  var params = {
    starred: using,
    auth: auth
  }
  npm.registry.<span class="apidocCodeKeywordSpan">star</span>(uri, params, function (er, data, raw, req) {
    if (!er) {
      output(s + &apos; &apos; + pkg)
      log.verbose(&apos;star&apos;, data)
    }
    cb(er, data, raw, req)
  })
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.start" id="apidoc.element.npm.start">
        function <span class="apidocSignatureSpan">npm.</span>start
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands[&apos;run-script&apos;]([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.stop" id="apidoc.element.npm.stop">
        function <span class="apidocSignatureSpan">npm.</span>stop
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands[&apos;run-script&apos;]([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.team" id="apidoc.element.npm.team">
        function <span class="apidocSignatureSpan">npm.</span>team
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function team(args, cb) {
  // Entities are in the format &lt;scope&gt;:&lt;team&gt;
  var cmd = args.shift()
  var entity = (args.shift() || &apos;&apos;).split(&apos;:&apos;)
  return mapToRegistry(&apos;/&apos;, npm.config, function (err, uri, auth) {
    if (err) { return cb(err) }
    try {
      return npm.registry.team(cmd, uri, {
        auth: auth,
        scope: entity[0].replace(/^@/, &apos;&apos;), // &apos;@&apos; prefix on scope is optional.
        team: entity[1],
        user: args.shift()
      }, function (err, data) {
        !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))
        cb(err, data)
      })
    } catch (e) {
      cb(e.message + &apos;\n\nUsage:\n&apos; + team.usage)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function team (args, cb) {
// Entities are in the format &lt;scope&gt;:&lt;team&gt;
var cmd = args.shift()
var entity = (args.shift() || &apos;&apos;).split(&apos;:&apos;)
return mapToRegistry(&apos;/&apos;, npm.config, function (err, uri, auth) {
  if (err) { return cb(err) }
  try {
    return npm.registry.<span class="apidocCodeKeywordSpan">team</span>(cmd, uri, {
      auth: auth,
      scope: entity[0].replace(/^@/, &apos;&apos;), // &apos;@&apos; prefix on scope is optional.
      team: entity[1],
      user: args.shift()
    }, function (err, data) {
      !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))
      cb(err, data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.token" id="apidoc.element.npm.token">
        function <span class="apidocSignatureSpan">npm.</span>token
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(args, cb) {
  log.gauge.show(&apos;token&apos;)
  if (args.length === 0) return withCb(list([]), cb)
  switch (args[0]) {
    case &apos;list&apos;:
    case &apos;ls&apos;:
      withCb(list(), cb)
      break
    case &apos;delete&apos;:
    case &apos;revoke&apos;:
    case &apos;remove&apos;:
    case &apos;rm&apos;:
      withCb(rm(args.slice(1)), cb)
      break
    case &apos;create&apos;:
      withCb(create(args.slice(1)), cb)
      break
    default:
      cb(new Error(&apos;Unknown profile command: &apos; + args[0]))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unbuild" id="apidoc.element.npm.unbuild">
        function <span class="apidocSignatureSpan">npm.</span>unbuild
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unbuild(args, silent, cb) {
  if (typeof silent === &apos;function&apos;) {
    cb = silent
    silent = false
  }
  asyncMap(args, unbuild_(silent), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.uninstall" id="apidoc.element.npm.uninstall">
        function <span class="apidocSignatureSpan">npm.</span>uninstall
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uninstall(args, cb) {
  validate(&apos;AF&apos;, arguments)
  // the /path/to/node_modules/..
  const dryrun = !!npm.config.get(&apos;dry-run&apos;)

  if (args.length === 1 &amp;&amp; args[0] === &apos;.&apos;) args = []

  const where = npm.config.get(&apos;global&apos;) || !args.length
    ? path.resolve(npm.globalDir, &apos;..&apos;)
    : npm.prefix

  args = args.filter(function (a) {
    return path.resolve(a) !== where
  })

  if (args.length) {
    new Uninstaller(where, dryrun, args).run(cb)
  } else {
    // remove this package from the global space, if it&apos;s installed there
    readJson(path.resolve(npm.localPrefix, &apos;package.json&apos;), function (er, pkg) {
      if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
      if (er) return cb(uninstall.usage)
      new Uninstaller(where, dryrun, [pkg.name]).run(cb)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unpublish" id="apidoc.element.npm.unpublish">
        function <span class="apidocSignatureSpan">npm.</span>unpublish
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unpublish(args, cb) {
  if (args.length &gt; 1) return cb(unpublish.usage)

  var thing = args.length ? npa(args[0]) : {}
  var project = thing.name
  var version = thing.rawSpec

  log.silly(&apos;unpublish&apos;, &apos;args[0]&apos;, args[0])
  log.silly(&apos;unpublish&apos;, &apos;thing&apos;, thing)
  if (!version &amp;&amp; !npm.config.get(&apos;force&apos;)) {
    return cb(
      &apos;Refusing to delete entire project.\n&apos; +
      &apos;Run with --force to do this.\n&apos; +
      unpublish.usage
    )
  }

  if (!project || path.resolve(project) === npm.localPrefix) {
    // if there&apos;s a package.json in the current folder, then
    // read the package name and version out of that.
    var cwdJson = path.join(npm.localPrefix, &apos;package.json&apos;)
    return readJson(cwdJson, function (er, data) {
      if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
      if (er) return cb(&apos;Usage:\n&apos; + unpublish.usage)
      log.verbose(&apos;unpublish&apos;, data)
      gotProject(data.name, data.version, data.publishConfig, cb)
    })
  }
  return gotProject(project, version, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (
  err.code === &apos;EPUBLISHCONFLICT&apos; &amp;&amp;
  npm.config.get(&apos;force&apos;) &amp;&amp;
  !isRetry
) {
  log.warn(&apos;publish&apos;, &apos;Forced publish over &apos; + pkg._id)
  return BB.fromNode((cb) =&gt; {
    npm.commands.<span class="apidocCodeKeywordSpan">unpublish</span>([pkg._id], cb)
  }).finally(() =&gt; {
    // ignore errors.  Use the force.  Reach out with your feelings.
    return upload(arg, pkg, true, cached).catch(() =&gt; {
      // but if it fails again, then report the first error.
      throw err
    })
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.validate_args" id="apidoc.element.npm.validate_args">
        function <span class="apidocSignatureSpan">npm.</span>validate_args
        <span class="apidocSignatureSpan">(idealTree, args, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_args = function (idealTree, args, next) {
  validate(&apos;OAF&apos;, arguments)
  var force = npm.config.get(&apos;force&apos;)

  asyncMap(args, function (pkg, done) {
    chain([
      [hasMinimumFields, pkg],
      [checkSelf, idealTree, pkg, force],
      [isInstallable, pkg]
    ], done)
  }, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.view" id="apidoc.element.npm.view">
        function <span class="apidocSignatureSpan">npm.</span>view
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function view(args, silent, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }

  if (!args.length) args = [&apos;.&apos;]

  var pkg = args.shift()
  var nv
  if (/^[.]@/.test(pkg)) {
    nv = npa.resolve(null, pkg.slice(2))
  } else {
    nv = npa(pkg)
  }
  var name = nv.name
  var local = (name === &apos;.&apos; || !name)

  if (npm.config.get(&apos;global&apos;) &amp;&amp; local) {
    return cb(new Error(&apos;Cannot use view command in global mode.&apos;))
  }

  if (local) {
    var dir = npm.prefix
    readJson(path.resolve(dir, &apos;package.json&apos;), function (er, d) {
      d = d || {}
      if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
      if (!d.name) return cb(new Error(&apos;Invalid package.json&apos;))

      var p = d.name
      nv = npa(p)
      if (pkg &amp;&amp; ~pkg.indexOf(&apos;@&apos;)) {
        nv.rawSpec = pkg.split(&apos;@&apos;)[pkg.indexOf(&apos;@&apos;)]
      }

      fetchAndRead(nv, args, silent, cb)
    })
  } else {
    fetchAndRead(nv, args, silent, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.writable" id="apidoc.element.npm.writable">
        function <span class="apidocSignatureSpan">npm.</span>writable
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight(&apos;writable:&apos; + dir, done)
  if (!done) return
  fs.access(dir, fs.W_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.access" id="apidoc.module.npm.access">module npm.access</a></h1>


    <h2>
        <a href="#apidoc.element.npm.access.access" id="apidoc.element.npm.access.access">
        function <span class="apidocSignatureSpan">npm.</span>access
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function access(args, cb) {
  var cmd = args.shift()
  var params
  return parseParams(cmd, args, function (err, p) {
    if (err) { return cb(err) }
    params = p
    return mapToRegistry(params.package, npm.config, invokeCmd)
  })

  function invokeCmd (err, uri, auth, base) {
    if (err) { return cb(err) }
    params.auth = auth
    try {
      return npm.registry.access(cmd, uri, params, function (err, data) {
        if (!err &amp;&amp; data) {
          output(JSON.stringify(data, undefined, 2))
        }
        cb(err, data)
      })
    } catch (e) {
      cb(e.message + &apos;\n\nUsage:\n&apos; + access.usage)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return mapToRegistry(params.package, npm.config, invokeCmd)
})

function invokeCmd (err, uri, auth, base) {
  if (err) { return cb(err) }
  params.auth = auth
  try {
    return npm.registry.<span class="apidocCodeKeywordSpan">access</span>(cmd, uri, params, function (err, data) {
      if (!err &amp;&amp; data) {
        output(JSON.stringify(data, undefined, 2))
      }
      cb(err, data)
    })
  } catch (e) {
    cb(e.message + &apos;\n\nUsage:\n&apos; + access.usage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.access.completion" id="apidoc.element.npm.access.completion">
        function <span class="apidocSignatureSpan">npm.access.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain
  if (argv.length === 2) {
    return cb(null, access.subcommands)
  }

  switch (argv[2]) {
    case &apos;grant&apos;:
      if (argv.length === 3) {
        return cb(null, [&apos;read-only&apos;, &apos;read-write&apos;])
      } else {
        return cb(null, [])
      }
    case &apos;public&apos;:
    case &apos;restricted&apos;:
    case &apos;ls-packages&apos;:
    case &apos;ls-collaborators&apos;:
    case &apos;edit&apos;:
      return cb(null, [])
    case &apos;revoke&apos;:
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + &apos; not recognized&apos;))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.actions" id="apidoc.module.npm.actions">module npm.actions</a></h1>


    <h2>
        <a href="#apidoc.element.npm.actions.doOne" id="apidoc.element.npm.actions.doOne">
        function <span class="apidocSignatureSpan">npm.actions.</span>doOne
        <span class="apidocSignatureSpan">(cmd, staging, pkg, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doOne(cmd, staging, pkg, log, next) {
  validate(&apos;SSOOF&apos;, arguments)
  const prepped = prepareAction([cmd, pkg], staging, log)
  return withInit(actions[cmd], () =&gt; {
    return execAction(prepped)
  }).nodeify(next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.actions.doParallel" id="apidoc.element.npm.actions.doParallel">
        function <span class="apidocSignatureSpan">npm.actions.</span>doParallel
        <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doParallel(type, staging, actionsToRun, log, next) {
  validate(&apos;SSAOF&apos;, arguments)
  const acts = actionsToRun.reduce((acc, todo) =&gt; {
    if (todo[0] === type) {
      acc.push(prepareAction(todo, staging, log))
    }
    return acc
  }, [])
  log.silly(&apos;doParallel&apos;, type + &apos; &apos; + acts.length)
  time(log)
  if (!acts.length) { return next() }
  return withInit(actions[type], () =&gt; {
    return BB.map(acts, execAction, {
      concurrency: npm.limit.action
    })
  }).nodeify((err) =&gt; {
    log.finish()
    timeEnd(log)
    next(err)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.actions.doReverseSerial" id="apidoc.element.npm.actions.doReverseSerial">
        function <span class="apidocSignatureSpan">npm.actions.</span>doReverseSerial
        <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doReverseSerial(type, staging, actionsToRun, log, next) {
  validate(&apos;SSAOF&apos;, arguments)
  log.silly(&apos;doReverseSerial&apos;, &apos;%s %d&apos;, type, actionsToRun.length)
  runSerial(type, staging, [].concat(actionsToRun).reverse(), log, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.actions.doSerial" id="apidoc.element.npm.actions.doSerial">
        function <span class="apidocSignatureSpan">npm.actions.</span>doSerial
        <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doSerial(type, staging, actionsToRun, log, next) {
  validate(&apos;SSAOF&apos;, arguments)
  log.silly(&apos;doSerial&apos;, &apos;%s %d&apos;, type, actionsToRun.length)
  runSerial(type, staging, actionsToRun, log, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.all_package_metadata" id="apidoc.module.npm.all_package_metadata">module npm.all_package_metadata</a></h1>


    <h2>
        <a href="#apidoc.element.npm.all_package_metadata.all_package_metadata" id="apidoc.element.npm.all_package_metadata.all_package_metadata">
        function <span class="apidocSignatureSpan">npm.</span>all_package_metadata
        <span class="apidocSignatureSpan">(staleness)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allPackageMetadata(staleness) {
  var stream = ms.through.obj()

  mapToRegistry(&apos;-/all&apos;, npm.config, function (er, uri, auth) {
    if (er) return stream.emit(&apos;error&apos;, er)

    var cacheBase = cacheFile(npm.config.get(&apos;cache&apos;))(uri)
    var cachePath = path.join(cacheBase, &apos;.cache.json&apos;)

    createEntryStream(cachePath, uri, auth, staleness, function (err, entryStream, latest, newEntries) {
      if (err) return stream.emit(&apos;error&apos;, err)
      log.silly(&apos;all-package-metadata&apos;, &apos;entry stream created&apos;)
      if (entryStream &amp;&amp; newEntries) {
        createCacheWriteStream(cachePath, latest, function (err, writeStream) {
          if (err) return stream.emit(&apos;error&apos;, err)
          log.silly(&apos;all-package-metadata&apos;, &apos;output stream created&apos;)
          ms.pipeline.obj(entryStream, writeStream, stream)
        })
      } else if (entryStream) {
        ms.pipeline.obj(entryStream, stream)
      } else {
        stream.emit(&apos;error&apos;, new Error(&apos;No search sources available&apos;))
      }
    })
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createCacheEntryStream" id="apidoc.element.npm.all_package_metadata._createCacheEntryStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createCacheEntryStream
        <span class="apidocSignatureSpan">(cacheFile, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCacheEntryStream(cacheFile, cb) {
  log.verbose(&apos;all-package-metadata&apos;, &apos;creating entry stream from local cache&apos;)
  log.verbose(&apos;all-package-metadata&apos;, cacheFile)
  fs.stat(cacheFile, function (err, stat) {
    if (err) return cb(err)
    // TODO - This isn&apos;t very helpful if `cacheFile` is empty or just `{}`
    var entryStream = ms.pipeline.obj(
      fs.createReadStream(cacheFile),
      jsonstream.parse(&apos;*&apos;),
      // I believe this passthrough is necessary cause `jsonstream` returns
      // weird custom streams that behave funny sometimes.
      ms.through.obj()
    )
    extractUpdated(entryStream, &apos;cached-entry-stream&apos;, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createCacheWriteStream" id="apidoc.element.npm.all_package_metadata._createCacheWriteStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createCacheWriteStream
        <span class="apidocSignatureSpan">(cacheFile, latest, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCacheWriteStream(cacheFile, latest, cb) {
  _ensureCacheDirExists(cacheFile, function (err) {
    if (err) return cb(err)
    log.silly(&apos;all-package-metadata&apos;, &apos;creating output stream&apos;)
    var outStream = _createCacheOutStream()
    var cacheFileStream = writeStreamAtomic(cacheFile)
    var inputStream = _createCacheInStream(cacheFileStream, outStream, latest)

    // Glue together the various streams so they fail together.
    // `cacheFileStream` errors are already handled by the `inputStream`
    // pipeline
    var errEmitted = false
    linkStreams(inputStream, outStream, function () { errEmitted = true })

    cacheFileStream.on(&apos;close&apos;, function () { !errEmitted &amp;&amp; outStream.end() })

    cb(null, ms.duplex.obj(inputStream, outStream))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createEntryStream" id="apidoc.element.npm.all_package_metadata._createEntryStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createEntryStream
        <span class="apidocSignatureSpan">(cachePath, uri, auth, staleness, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createEntryStream(cachePath, uri, auth, staleness, cb) {
  createCacheEntryStream(cachePath, function (err, cacheStream, cacheLatest) {
    cacheLatest = cacheLatest || 0
    if (err) {
      log.warn(&apos;&apos;, &apos;Failed to read search cache. Rebuilding&apos;)
      log.silly(&apos;all-package-metadata&apos;, &apos;cache read error: &apos;, err)
    }
    createEntryUpdateStream(uri, auth, staleness, cacheLatest, function (err, updateStream, updatedLatest) {
      updatedLatest = updatedLatest || 0
      var latest = updatedLatest || cacheLatest
      if (!cacheStream &amp;&amp; !updateStream) {
        return cb(new Error(&apos;No search sources available&apos;))
      }
      if (err) {
        log.warn(&apos;&apos;, &apos;Search data request failed, search might be stale&apos;)
        log.silly(&apos;all-package-metadata&apos;, &apos;update request error: &apos;, err)
      }
      if (cacheStream &amp;&amp; updateStream) {
        // Deduped, unioned, sorted stream from the combination of both.
        cb(null,
          createMergedStream(cacheStream, updateStream),
          latest,
          !!updatedLatest)
      } else {
        // Either one works if one or the other failed
        cb(null, cacheStream || updateStream, latest, !!updatedLatest)
      }
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createEntryUpdateStream" id="apidoc.element.npm.all_package_metadata._createEntryUpdateStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createEntryUpdateStream
        <span class="apidocSignatureSpan">(all, auth, staleness, latest, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createEntryUpdateStream(all, auth, staleness, latest, cb) {
  log.verbose(&apos;all-package-metadata&apos;, &apos;creating remote entry stream&apos;)
  var params = {
    timeout: 600,
    follow: true,
    staleOk: true,
    auth: auth,
    streaming: true
  }
  var partialUpdate = false
  if (latest &amp;&amp; (Date.now() - latest &lt; (staleness * 1000))) {
    // Skip the request altogether if our `latest` isn&apos;t stale.
    log.verbose(&apos;all-package-metadata&apos;, &apos;Local data up to date, skipping update&apos;)
    return cb(null)
  } else if (latest === 0) {
    log.warn(&apos;&apos;, &apos;Building the local index for the first time, please be patient&apos;)
    log.verbose(&apos;all-package-metadata&apos;, &apos;No cached data: requesting full metadata db&apos;)
  } else {
    log.verbose(&apos;all-package-metadata&apos;, &apos;Cached data present with timestamp:&apos;, latest, &apos;requesting partial index update&apos;)
    all += &apos;/since?stale=update_after&amp;startkey=&apos; + latest
    partialUpdate = true
  }
  npm.registry.request(all, params, function (er, res) {
    if (er) return cb(er)
    log.silly(&apos;all-package-metadata&apos;, &apos;request stream opened, code:&apos;, res.statusCode)
    // NOTE - The stream returned by `request` seems to be very persnickety
    //        and this is almost a magic incantation to get it to work.
    //        Modify how `res` is used here at your own risk.
    var entryStream = ms.pipeline.obj(
      res,
      ms.through(function (chunk, enc, cb) {
        cb(null, chunk)
      }),
      gunzip(),
      jsonstream.parse(&apos;*&apos;, function (pkg, key) {
        if (key[0] === &apos;_updated&apos; || key[0][0] !== &apos;_&apos;) {
          return pkg
        }
      })
    )
    if (partialUpdate) {
      // The `/all/since` endpoint doesn&apos;t return `_updated`, so we
      // just use the request&apos;s own timestamp.
      cb(null, entryStream, Date.parse(res.headers.date))
    } else {
      extractUpdated(entryStream, &apos;entry-update-stream&apos;, cb)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createMergedStream" id="apidoc.element.npm.all_package_metadata._createMergedStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createMergedStream
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMergedStream(a, b) {
  linkStreams(a, b)
  return sortedUnionStream(b, a, function (pkg) { return pkg.name })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.and_finish_tracker" id="apidoc.module.npm.and_finish_tracker">module npm.and_finish_tracker</a></h1>


    <h2>
        <a href="#apidoc.element.npm.and_finish_tracker.and_finish_tracker" id="apidoc.element.npm.and_finish_tracker.and_finish_tracker">
        function <span class="apidocSignatureSpan">npm.</span>and_finish_tracker
        <span class="apidocSignatureSpan">(tracker, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and_finish_tracker = function (tracker, cb) {
  validate(&apos;OF&apos;, [tracker, cb])
  return function () {
    tracker.finish()
    cb.apply(null, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.and_finish_tracker.now" id="apidoc.element.npm.and_finish_tracker.now">
        function <span class="apidocSignatureSpan">npm.and_finish_tracker.</span>now
        <span class="apidocSignatureSpan">(tracker, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">now = function (tracker, cb) {
  validate(&apos;OF&apos;, [tracker, cb])
  tracker.finish()
  cb.apply(null, Array.prototype.slice.call(arguments, 2))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.packageLockOnly = opts.packageLockOnly != null
  ? opts.packageLockOnly : npm.config.get(&apos;package-lock-only&apos;)
this.rollback = opts.rollback != null ? opts.rollback : npm.config.get(&apos;rollback&apos;)
this.link = opts.link != null ? opts.link : npm.config.get(&apos;link&apos;)
this.saveOnlyLock = opts.saveOnlyLock
this.global = opts.global != null ? opts.global : this.where === path.resolve(npm.globalDir, &apos;..&apos;)
this.audit = npm.config.get(&apos;audit&apos;) &amp;&amp; !this.global
this.started = Date.<span class="apidocCodeKeywordSpan">now</span>()
}
Installer.prototype = {}

Installer.prototype.run = function (_cb) {
validate(&apos;F|&apos;, arguments)

var result
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.audit" id="apidoc.module.npm.audit">module npm.audit</a></h1>


    <h2>
        <a href="#apidoc.element.npm.audit.audit" id="apidoc.element.npm.audit.audit">
        function <span class="apidocSignatureSpan">npm.</span>audit
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function auditCmd(args, cb) {
  if (npm.config.get(&apos;global&apos;)) {
    const err = new Error(&apos;`npm audit` does not support testing globals&apos;)
    err.code = &apos;EAUDITGLOBAL&apos;
    throw err
  }
  if (args.length &amp;&amp; args[0] !== &apos;fix&apos;) {
    return cb(new Error(&apos;Invalid audit subcommand: `&apos; + args[0] + &apos;`\n\nUsage:\n&apos; + auditCmd.usage))
  }
  return Bluebird.all([
    maybeReadFile(&apos;npm-shrinkwrap.json&apos;),
    maybeReadFile(&apos;package-lock.json&apos;),
    maybeReadFile(&apos;package.json&apos;)
  ]).spread((shrinkwrap, lockfile, pkgJson) =&gt; {
    const sw = shrinkwrap || lockfile
    if (!pkgJson) {
      const err = new Error(&apos;No package.json found: Cannot audit a project without a package.json&apos;)
      err.code = &apos;EAUDITNOPJSON&apos;
      throw err
    }
    if (!sw) {
      const err = new Error(&apos;Neither npm-shrinkwrap.json nor package-lock.json found: Cannot audit a project without a lockfile&apos;)
      err.code = &apos;EAUDITNOLOCK&apos;
      throw err
    } else if (shrinkwrap &amp;&amp; lockfile) {
      log.warn(&apos;audit&apos;, &apos;Both npm-shrinkwrap.json and package-lock.json exist, using npm-shrinkwrap.json.&apos;)
    }
    const requires = Object.assign(
      {},
      (pkgJson &amp;&amp; pkgJson.dependencies) || {},
      (pkgJson &amp;&amp; pkgJson.devDependencies) || {}
    )
    return lockVerify(npm.prefix).then(result =&gt; {
      if (result.status) return audit.generate(sw, requires)

      const lockFile = shrinkwrap ? &apos;npm-shrinkwrap.json&apos; : &apos;package-lock.json&apos;
      const err = new Error(`Errors were found in your ${lockFile}, run  npm install  to fix them.\n    ` +
        result.errors.join(&apos;\n    &apos;))
      err.code = &apos;ELOCKVERIFY&apos;
      throw err
    })
  }).then((auditReport) =&gt; {
    return audit.submitForFullReport(auditReport)
  }).catch(err =&gt; {
    if (err.statusCode === 404 || err.statusCode &gt;= 500) {
      const ne = new Error(`Your configured registry (${npm.config.get(&apos;registry&apos;)}) does not support audit requests.`)
      ne.code = &apos;ENOAUDIT&apos;
      ne.wrapped = err
      throw ne
    }
    throw err
  }).then((auditResult) =&gt; {
    if (args[0] === &apos;fix&apos;) {
      const actions = (auditResult.actions || []).reduce((acc, action) =&gt; {
        action = filterEnv(action)
        if (!action) { return acc }
        if (action.isMajor) {
          acc.major.add(`${action.module}@${action.target}`)
          action.resolves.forEach(({id, path}) =&gt; acc.majorFixes.add(`${id}::${path}`))
        } else if (action.action === &apos;install&apos;) {
          acc.install.add(`${action.module}@${action.target}`)
          action.resolves.forEach(({id, path}) =&gt; acc.installFixes.add(`${id}::${path}`))
        } else if (action.action === &apos;update&apos;) {
          const name = action.module
          const version = action.target
          action.resolves.forEach(vuln =&gt; {
            acc.updateFixes.add(`${vuln.id}::${vuln.path}`)
            const modPath = vuln.path.split(&apos;&gt;&apos;)
            const newPath = modPath.slice(
              0, modPath.indexOf(name)
            ).concat(`${name}@${version}`)
            if (newPath.length === 1) {
              acc.install.add(newPath[0])
            } else {
              acc.update.add(newPath.join(&apos;&gt;&apos;))
            }
          })
        } else if (action.action === &apos;review&apos;) {
          action.resolves.forEach(({id, path}) =&gt; acc.review.add(`${id}::${path}`))
        }
        return acc
      }, {
        install: new Set(),
        installFixes: new Set(),
        update: new Set(),
        updateFixes: new Set(),
        major: new Set(),
        majorFixes: new Set(),
        review: new Set()
      })
      return Bluebird.try(() =&gt; {
        const installMajor = npm.config.get(&apos;force&apos;)
        const installCount = actions.install.size + (installMajor ? actions.major.size : 0) + actions.update.si...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.audit.completion" id="apidoc.element.npm.audit.completion">
        function <span class="apidocSignatureSpan">npm.audit.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  const argv = opts.conf.argv.remain

  switch (argv[2]) {
    case &apos;audit&apos;:
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + &apos; not recognized&apos;))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.bugs" id="apidoc.module.npm.bugs">module npm.bugs</a></h1>


    <h2>
        <a href="#apidoc.element.npm.bugs.bugs" id="apidoc.element.npm.bugs.bugs">
        function <span class="apidocSignatureSpan">npm.</span>bugs
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bugs(args, cb) {
  var n = args.length ? args[0] : &apos;.&apos;
  fetchPackageMetadata(n, &apos;.&apos;, {fullMetadata: true}, function (er, d) {
    if (er) return cb(er)

    var url = d.bugs &amp;&amp; ((typeof d.bugs === &apos;string&apos;) ? d.bugs : d.bugs.url)
    if (!url) {
      url = &apos;https://www.npmjs.org/package/&apos; + d.name
    }
    log.silly(&apos;bugs&apos;, &apos;url&apos;, url)
    openUrl(url, &apos;bug list available at the following URL&apos;, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.bugs.completion" id="apidoc.element.npm.bugs.completion">
        function <span class="apidocSignatureSpan">npm.bugs.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.ci" id="apidoc.module.npm.ci">module npm.ci</a></h1>


    <h2>
        <a href="#apidoc.element.npm.ci.ci" id="apidoc.element.npm.ci.ci">
        function <span class="apidocSignatureSpan">npm.</span>ci
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ci(args, cb) {
  return new Installer({
    config: npm.config,
    log: npmlog
  })
    .run()
    .then(
      (details) =&gt; {
        npmlog.disableProgress()
        console.error(`added ${details.pkgCount} packages in ${
          details.runTime / 1000
        }s`)
      }
    )
    .then(() =&gt; cb(), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ci.completion" id="apidoc.element.npm.ci.completion">
        function <span class="apidocSignatureSpan">npm.ci.</span>completion
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cb) =&gt; cb(null, [])</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.completion" id="apidoc.module.npm.completion">module npm.completion</a></h1>


    <h2>
        <a href="#apidoc.element.npm.completion.completion" id="apidoc.element.npm.completion.completion">
        function <span class="apidocSignatureSpan">npm.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  if (opts.w &gt; 3) return cb()

  var fs = require(&apos;graceful-fs&apos;)
  var path = require(&apos;path&apos;)
  var bashExists = null
  var zshExists = null
  fs.stat(path.resolve(process.env.HOME, &apos;.bashrc&apos;), function (er) {
    bashExists = !er
    next()
  })
  fs.stat(path.resolve(process.env.HOME, &apos;.zshrc&apos;), function (er) {
    zshExists = !er
    next()
  })
  function next () {
    if (zshExists === null || bashExists === null) return
    var out = []
    if (zshExists) out.push(&apos;~/.zshrc&apos;)
    if (bashExists) out.push(&apos;~/.bashrc&apos;)
    if (opts.w === 2) {
      out = out.map(function (m) {
        return [&apos;&gt;&gt;&apos;, m]
      })
    }
    cb(null, out)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.config" id="apidoc.module.npm.config">module npm.config</a></h1>




    <h2>
        <a href="#apidoc.element.npm.config.get" id="apidoc.element.npm.config.get">
        function <span class="apidocSignatureSpan">npm.config.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const pkg = require(&apos;../package.json&apos;)
let notifier = require(&apos;update-notifier&apos;)({pkg})
if (
  notifier.update &amp;&amp;
  notifier.update.latest !== pkg.version
) {
  const color = require(&apos;ansicolors&apos;)
  const useColor = npm.config.<span class="apidocCodeKeywordSpan">get</span>(&apos;color&apos;)
  const useUnicode = npm.config.get(&apos;unicode&apos;)
  const old = notifier.update.current
  const latest = notifier.update.latest
  let type = notifier.update.type
  if (useColor) {
    switch (type) {
      case &apos;major&apos;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.set" id="apidoc.element.npm.config.set">
        function <span class="apidocSignatureSpan">npm.config.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } catch (e) {
    return cb(new Error(&apos;no such auth module&apos;))
  }
  auth.login(creds, registry, scope, function (err, newCreds) {
    if (err) return cb(err)

    npm.config.del(&apos;_token&apos;, &apos;user&apos;) // prevent legacy pollution
    if (scope) npm.config.<span class="apidocCodeKeywordSpan">set</span>(scope + &apos;:registry&apos;, registry, &apos;user&apos
;)
    npm.config.setCredentialsByURI(registry, newCreds)
    npm.config.save(&apos;user&apos;, cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.toLifecycle" id="apidoc.element.npm.config.toLifecycle">
        function <span class="apidocSignatureSpan">npm.config.</span>toLifecycle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.toPacote" id="apidoc.element.npm.config.toPacote">
        function <span class="apidocSignatureSpan">npm.config.</span>toPacote
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.core" id="apidoc.module.npm.core">module npm.core</a></h1>






    <h2>
        <a href="#apidoc.element.npm.core.Conf" id="apidoc.element.npm.core.Conf">
        function <span class="apidocSignatureSpan">npm.core.</span>Conf
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Conf(base) {
  if (!(this instanceof Conf)) return new Conf(base)

  CC.call(this)

  if (base) {
    if (base instanceof Conf) {
      this.root = base.list[0] || base.root
    } else {
      this.root = base
    }
  } else {
    this.root = configDefs.defaults
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.core.load" id="apidoc.element.npm.core.load">
        function <span class="apidocSignatureSpan">npm.core.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load() {
  var cli, builtin, cb
  for (var i = 0; i &lt; arguments.length; i++) {
    switch (typeof arguments[i]) {
      case &apos;string&apos;: builtin = arguments[i]; break
      case &apos;object&apos;: cli = arguments[i]; break
      case &apos;function&apos;: cb = arguments[i]; break
    }
  }

  if (!cb) cb = function () {}

  if (exports.loaded) {
    var ret = exports.loaded
    if (cli) {
      ret = new Conf(ret)
      ret.unshift(cli)
    }
    return process.nextTick(cb.bind(null, null, ret))
  }

  // either a fresh object, or a clone of the passed in obj
  if (!cli) {
    cli = {}
  } else {
    cli = Object.keys(cli).reduce(function (c, k) {
      c[k] = cli[k]
      return c
    }, {})
  }

  loadCbs.push(cb)
  if (loading) return

  loading = true

  cb = once(function (er, conf) {
    if (!er) {
      exports.loaded = conf
      loading = false
    }
    loadCbs.forEach(function (fn) {
      fn(er, conf)
    })
    loadCbs.length = 0
  })

  // check for a builtin if provided.
  exports.usingBuiltin = !!builtin
  var rc = exports.rootConf = new Conf()
  if (builtin) {
    rc.addFile(builtin, &apos;builtin&apos;)
  } else {
    rc.add({}, &apos;builtin&apos;)
  }

  rc.on(&apos;load&apos;, function () {
    load_(builtin, rc, cli, cb)
  })
  rc.on(&apos;error&apos;, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.argv.unshift(npm.command)
  npm.command = &apos;help&apos;
}

// now actually fire up npm and run the command.
// this is how to use npm programmatically:
conf._exit = true
npm.<span class="apidocCodeKeywordSpan">load</span>(conf, function (er) {
  if (er) return errorHandler(er)
  if (!unsupported.checkVersion(process.version).unsupported) {
    const pkg = require(&apos;../package.json&apos;)
    let notifier = require(&apos;update-notifier&apos;)({pkg})
    if (
      notifier.update &amp;&amp;
      notifier.update.latest !== pkg.version
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.core.validate" id="apidoc.element.npm.core.validate">
        function <span class="apidocSignatureSpan">npm.core.</span>validate
        <span class="apidocSignatureSpan">(cl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(cl) {
  // warn about invalid configs at every level.
  cl.list.forEach(function (conf) {
    nopt.clean(conf, configDefs.types)
  })

  nopt.clean(cl.root, configDefs.types)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.warn(m + &apos; &apos; + util.format.apply(util, [].slice.call(arguments, 1)))
  } }
}

exports.Umask = Umask
function Umask () {}
function validateUmask (data, k, val) {
  return umask.<span class="apidocCodeKeywordSpan">validate</span>(data, k, val)
}

function validateSemver (data, k, val) {
  if (!semver.valid(val)) return false
  data[k] = semver.valid(val)
}
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.dedupe" id="apidoc.module.npm.dedupe">module npm.dedupe</a></h1>


    <h2>
        <a href="#apidoc.element.npm.dedupe.dedupe" id="apidoc.element.npm.dedupe.dedupe">
        function <span class="apidocSignatureSpan">npm.</span>dedupe
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dedupe(args, cb) {
  validate(&apos;AF&apos;, arguments)
  // the /path/to/node_modules/..
  var where = path.resolve(npm.dir, &apos;..&apos;)
  var dryrun = false
  if (npm.command.match(/^find/)) dryrun = true
  if (npm.config.get(&apos;dry-run&apos;)) dryrun = true
  if (dryrun &amp;&amp; !npm.config.get(&apos;json&apos;)) npm.config.set(&apos;parseable&apos;, true)

  new Deduper(where, dryrun).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.dedupe.Deduper" id="apidoc.element.npm.dedupe.Deduper">
        function <span class="apidocSignatureSpan">npm.dedupe.</span>Deduper
        <span class="apidocSignatureSpan">(where, dryrun)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deduper(where, dryrun) {
  validate(&apos;SB&apos;, arguments)
  Installer.call(this, where, dryrun, [])
  this.noPackageJsonOk = true
  this.topLevelLifecycles = false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.defaults" id="apidoc.module.npm.defaults">module npm.defaults</a></h1>


    <h2>
        <a href="#apidoc.element.npm.defaults.Umask" id="apidoc.element.npm.defaults.Umask">
        function <span class="apidocSignatureSpan">npm.defaults.</span>Umask
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Umask() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.deprecate" id="apidoc.module.npm.deprecate">module npm.deprecate</a></h1>


    <h2>
        <a href="#apidoc.element.npm.deprecate.deprecate" id="apidoc.element.npm.deprecate.deprecate">
        function <span class="apidocSignatureSpan">npm.</span>deprecate
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecate(args, cb) {
  var pkg = args[0]
  var msg = args[1]
  if (msg === undefined) return cb(&apos;Usage: &apos; + deprecate.usage)

  // fetch the data and make sure it exists.
  var p = npa(pkg)

  // npa makes the default spec &quot;latest&quot;, but for deprecation
  // &quot;*&quot; is the appropriate default.
  var spec = p.rawSpec === &apos;&apos; ? &apos;*&apos; : p.fetchSpec

  mapToRegistry(p.name, npm.config, function (er, uri, auth) {
    if (er) return cb(er)

    var params = {
      version: spec,
      message: msg,
      auth: auth
    }
    npm.registry.deprecate(uri, params, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (er) return cb(er)

    var params = {
      version: spec,
      message: msg,
      auth: auth
    }
    npm.registry.<span class="apidocCodeKeywordSpan">deprecate</span>(uri, params, cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deprecate.completion" id="apidoc.element.npm.deprecate.completion">
        function <span class="apidocSignatureSpan">npm.deprecate.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // first, get a list of remote packages this user owns.
  // once we have a user account, then don&apos;t complete anything.
  if (opts.conf.argv.remain.length &gt; 2) return cb()
  // get the list of packages by user
  var path = &apos;/-/by-user/&apos;
  mapToRegistry(path, npm.config, function (er, uri, c) {
    if (er) return cb(er)

    if (!(c &amp;&amp; c.username)) return cb()

    var params = {
      timeout: 60000,
      auth: c
    }
    npm.registry.get(uri + c.username, params, function (er, list) {
      if (er) return cb()
      console.error(list)
      return cb(null, list[c.username])
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.deps" id="apidoc.module.npm.deps">module npm.deps</a></h1>


    <h2>
        <a href="#apidoc.element.npm.deps._replaceModuleByName" id="apidoc.element.npm.deps._replaceModuleByName">
        function <span class="apidocSignatureSpan">npm.deps.</span>_replaceModuleByName
        <span class="apidocSignatureSpan">(obj, key, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceModuleByName(obj, key, child) {
  var childName = moduleName(child)
  return replaceModule(obj, key, child, function (replacing, child) {
    return moduleName(replacing) === childName
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps._replaceModuleByPath" id="apidoc.element.npm.deps._replaceModuleByPath">
        function <span class="apidocSignatureSpan">npm.deps.</span>_replaceModuleByPath
        <span class="apidocSignatureSpan">(obj, key, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceModuleByPath(obj, key, child) {
  return replaceModule(obj, key, child, function (replacing, child) {
    return replacing.path === child.path
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.computeMetadata" id="apidoc.element.npm.deps.computeMetadata">
        function <span class="apidocSignatureSpan">npm.deps.</span>computeMetadata
        <span class="apidocSignatureSpan">(tree, seen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeMetadata(tree, seen) {
  if (!seen) seen = new Set()
  if (!tree || seen.has(tree)) return
  seen.add(tree)
  if (tree.parent == null) {
    resetMetadata(tree)
    tree.isTop = true
  }
  tree.location = flatNameFromTree(tree)

  function findChild (name, spec, kind) {
    try {
      var req = childDependencySpecifier(tree, name, spec)
    } catch (err) {
      return
    }
    var child = findRequirement(tree, req.name, req)
    if (child) {
      resolveWithExistingModule(child, tree)
      return true
    }
  }

  const deps = tree.package.dependencies || {}
  const reqs = tree.swRequires || {}
  for (let name of Object.keys(deps)) {
    if (findChild(name, deps[name])) continue
    if (name in reqs &amp;&amp; findChild(name, reqs[name])) continue
    tree.missingDeps[name] = deps[name]
  }
  if (tree.isTop) {
    const devDeps = tree.package.devDependencies || {}
    for (let name of Object.keys(devDeps)) {
      if (findChild(name, devDeps[name])) continue
      tree.missingDevDeps[name] = devDeps[name]
    }
  }

  tree.children.filter((child) =&gt; !child.removed).forEach((child) =&gt; computeMetadata(child, seen))

  return tree
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.computeVersionSpec" id="apidoc.element.npm.deps.computeVersionSpec">
        function <span class="apidocSignatureSpan">npm.deps.</span>computeVersionSpec
        <span class="apidocSignatureSpan">(tree, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeVersionSpec(tree, child) {
  validate(&apos;OO&apos;, arguments)
  var requested
  var childReq = child.package._requested
  if (child.isLink) {
    requested = npa.resolve(child.package.name, &apos;file:&apos; + child.realpath, getTop(tree).path)
  } else if (childReq &amp;&amp; (isNotEmpty(childReq.saveSpec) || (isNotEmpty(childReq.rawSpec) &amp;&amp; isNotEmpty(childReq.fetchSpec)))) {
    requested = child.package._requested
  } else if (child.package._from) {
    requested = npa(child.package._from, tree.path)
  } else {
    requested = npa.resolve(child.package.name, child.package.version)
  }
  if (isRegistry(requested)) {
    var version = child.package.version
    var rangeDescriptor = &apos;&apos;
    if (semver.valid(version, true) &amp;&amp;
        semver.gte(version, &apos;0.1.0&apos;, true) &amp;&amp;
        !npm.config.get(&apos;save-exact&apos;)) {
      rangeDescriptor = npm.config.get(&apos;save-prefix&apos;)
    }
    return rangeDescriptor + version
  } else if (requested.type === &apos;directory&apos; || requested.type === &apos;file&apos;) {
    return &apos;file:&apos; + unixFormatPath(path.relative(getTop(tree).path, requested.fetchSpec))
  } else {
    return requested.saveSpec || requested.rawSpec
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.earliestInstallable" id="apidoc.element.npm.deps.earliestInstallable">
        function <span class="apidocSignatureSpan">npm.deps.</span>earliestInstallable
        <span class="apidocSignatureSpan">(requiredBy, tree, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">earliestInstallable = function (requiredBy, tree, pkg, log) {
  validate(&apos;OOOO&apos;, arguments)

  function undeletedModuleMatches (child) {
    return !child.removed &amp;&amp; moduleName(child) === pkg.name
  }
  const undeletedMatches = tree.children.filter(undeletedModuleMatches)
  if (undeletedMatches.length) {
    // if there&apos;s a conflict with another child AT THE SAME level then we&apos;re replacing it, so
    // mark it as removed and continue with resolution normally.
    if (tree === requiredBy) {
      undeletedMatches.forEach((pkg) =&gt; {
        if (pkg.fromBundle) reportBundleOverride(pkg, log)
        removeObsoleteDep(pkg, log)
      })
    } else {
      return null
    }
  }

  // If any of the children of this tree have conflicting
  // binaries then we need to decline to install this package here.
  var binaryMatches = pkg.bin &amp;&amp; tree.children.some(function (child) {
    if (child.removed || !child.package.bin) return false
    return Object.keys(child.package.bin).some(function (bin) {
      return pkg.bin[bin]
    })
  })

  if (binaryMatches) return null

  // if this tree location requested the same module then we KNOW it
  // isn&apos;t compatible because if it were findRequirement would have
  // found that version.
  var deps = tree.package.dependencies || {}
  if (!tree.removed &amp;&amp; requiredBy !== tree &amp;&amp; deps[pkg.name]) {
    return null
  }

  var devDeps = tree.package.devDependencies || {}
  if (tree.isTop &amp;&amp; devDeps[pkg.name]) {
    var requested = childDependencySpecifier(tree, pkg.name, devDeps[pkg.name])
    if (!doesChildVersionMatch({package: pkg}, requested, tree)) {
      return null
    }
  }

  if (tree.phantomChildren &amp;&amp; tree.phantomChildren[pkg.name]) return null

  if (tree.isTop) return tree
  if (tree.isGlobal) return tree

  if (npm.config.get(&apos;global-style&apos;) &amp;&amp; tree.parent.isTop) return tree
  if (npm.config.get(&apos;legacy-bundling&apos;)) return tree

  if (!preserveSymlinks() &amp;&amp; /^[.][.][\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return tree

  return (earliestInstallable(requiredBy, tree.parent, pkg, log) || tree)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.failedDependency" id="apidoc.element.npm.deps.failedDependency">
        function <span class="apidocSignatureSpan">npm.deps.</span>failedDependency
        <span class="apidocSignatureSpan">(tree, name, pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function failedDependency(tree, name, pkg) {
  if (name) {
    if (isDepOptional(tree, name, pkg || {})) {
      return false
    }
  }

  tree.failed = true

  if (tree.isTop) return true

  if (tree.userRequired) return true

  if (!tree.requiredBy) return false

  let anyFailed = false
  for (var ii = 0; ii &lt; tree.requiredBy.length; ++ii) {
    var requireParent = tree.requiredBy[ii]
    if (failedDependency(requireParent, moduleName(tree), tree)) {
      anyFailed = true
    }
  }
  return anyFailed
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.findRequirement" id="apidoc.element.npm.deps.findRequirement">
        function <span class="apidocSignatureSpan">npm.deps.</span>findRequirement
        <span class="apidocSignatureSpan">(tree, name, requested, requestor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findRequirement = function (tree, name, requested, requestor) {
  validate(&apos;OSO&apos;, [tree, name, requested])
  if (!requestor) requestor = tree
  var nameMatch = function (child) {
    return moduleName(child) === name &amp;&amp; child.parent &amp;&amp; !child.removed
  }
  var versionMatch = function (child) {
    return doesChildVersionMatch(child, requested, requestor)
  }
  if (nameMatch(tree)) {
    // this *is* the module, but it doesn&apos;t match the version, so a
    // new copy will have to be installed
    return versionMatch(tree) ? tree : null
  }

  var matches = tree.children.filter(nameMatch)
  if (matches.length) {
    matches = matches.filter(versionMatch)
    // the module exists as a dependent, but the version doesn&apos;t match, so
    // a new copy will have to be installed above here
    if (matches.length) return matches[0]
    return null
  }
  if (tree.isTop) return null
  if (!preserveSymlinks() &amp;&amp; /^[.][.][\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return null
  return findRequirement(tree.parent, name, requested, requestor)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.getAllMetadata" id="apidoc.element.npm.deps.getAllMetadata">
        function <span class="apidocSignatureSpan">npm.deps.</span>getAllMetadata
        <span class="apidocSignatureSpan">(args, tree, where, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllMetadata = function (args, tree, where, next) {
  asyncMap(args, function (arg, done) {
    let spec
    try {
      spec = npa(arg)
    } catch (e) {
      return done(e)
    }
    if (spec.type !== &apos;file&apos; &amp;&amp; spec.type !== &apos;directory&apos; &amp;&amp; (spec.name == null || spec.rawSpec === &apos;&apos;)) {
      return fs.stat(path.join(arg, &apos;package.json&apos;), (err) =&gt; {
        if (err) {
          var version = matchingDep(tree, spec.name)
          if (version) {
            try {
              return fetchPackageMetadata(npa.resolve(spec.name, version), where, done)
            } catch (e) {
              return done(e)
            }
          } else {
            return fetchPackageMetadata(spec, where, done)
          }
        } else {
          try {
            return fetchPackageMetadata(npa(&apos;file:&apos; + arg), where, done)
          } catch (e) {
            return done(e)
          }
        }
      })
    } else {
      return fetchPackageMetadata(spec, where, done)
    }
  }, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.loadDeps" id="apidoc.element.npm.deps.loadDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>loadDeps
        <span class="apidocSignatureSpan">(tree, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadDeps(tree, log, next) {
  validate(&apos;OOF&apos;, arguments)
  if (tree.loaded || (tree.parent &amp;&amp; tree.parent.failed) || tree.removed) return andFinishTracker.now(log, next)
  if (tree.parent) tree.loaded = true
  if (!tree.package.dependencies) tree.package.dependencies = {}
  asyncMap(Object.keys(tree.package.dependencies), function (dep, done) {
    var version = tree.package.dependencies[dep]
    addDependency(dep, version, tree, log.newGroup(&apos;loadDep:&apos; + dep), andHandleOptionalErrors(log, tree, dep, done))
  }, andForEachChild(loadDeps, andFinishTracker(log, next)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.loadDevDeps" id="apidoc.element.npm.deps.loadDevDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>loadDevDeps
        <span class="apidocSignatureSpan">(tree, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDevDeps = function (tree, log, next) {
  validate(&apos;OOF&apos;, arguments)
  if (!tree.package.devDependencies) return andFinishTracker.now(log, next)
  asyncMap(Object.keys(tree.package.devDependencies), function (dep, done) {
    // things defined as both dev dependencies and regular dependencies are treated
    // as the former
    if (tree.package.dependencies[dep]) return done()

    var logGroup = log.newGroup(&apos;loadDevDep:&apos; + dep)
    addDependency(dep, tree.package.devDependencies[dep], tree, logGroup, andHandleOptionalErrors(log, tree, dep, done))
  }, andForEachChild(loadDeps, andFinishTracker(log, next)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.loadExtraneous" id="apidoc.element.npm.deps.loadExtraneous">
        function <span class="apidocSignatureSpan">npm.deps.</span>loadExtraneous
        <span class="apidocSignatureSpan">(tree, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadExtraneous = function (tree, log, next) {
  var seen = new Set()

  function loadExtraneous (tree) {
    if (seen.has(tree)) return
    seen.add(tree)
    for (var child of tree.children) {
      if (child.loaded) continue
      resolveWithExistingModule(child, tree)
      loadExtraneous(child)
    }
  }
  loadExtraneous(tree)
  log.finish()
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.loadRequestedDeps" id="apidoc.element.npm.deps.loadRequestedDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>loadRequestedDeps
        <span class="apidocSignatureSpan">(args, tree, saveToDependencies, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadRequestedDeps = function (args, tree, saveToDependencies, log, next) {
  validate(&apos;AOOF&apos;, [args, tree, log, next])
  asyncMap(args, function (pkg, done) {
    var depLoaded = andAddParentToErrors(tree, done)
    resolveWithNewModule(pkg, tree, log.newGroup(&apos;loadRequestedDeps&apos;), iferr(depLoaded, function (child, tracker) {
      validate(&apos;OO&apos;, arguments)
      if (npm.config.get(&apos;global&apos;)) {
        child.isGlobal = true
      }
      var childName = moduleName(child)
      child.saveSpec = computeVersionSpec(tree, child)
      child.userRequired = true
      child.save = getSaveType(tree, child)
      const types = [&apos;dependencies&apos;, &apos;devDependencies&apos;, &apos;optionalDependencies&apos;]
      if (child.save) {
        tree.package[child.save][childName] = child.saveSpec
        // Astute readers might notice that this exact same code exists in
        // save.js under a different guise. That code is responsible for deps
        // being removed from the final written `package.json`. The removal in
        // this function is specifically to prevent &quot;installed as both X and Y&quot;
        // warnings when moving an existing dep between different dep fields.
        //
        // Or, try it by removing this loop, and do `npm i -P x &amp;&amp; npm i -D x`
        for (let saveType of types) {
          if (child.save !== saveType) {
            delete tree.package[saveType][childName]
          }
        }
        if (child.save === &apos;optionalDependencies&apos;) tree.package.dependencies[childName] = child.saveSpec
      }

      // For things the user asked to install, that aren&apos;t a dependency (or
      // won&apos;t be when we&apos;re done), flag it as &quot;depending&quot; on the user
      // themselves, so we don&apos;t remove it as a dep that no longer exists
      var childIsDep = addRequiredDep(tree, child)
      if (!childIsDep) child.userRequired = true
      depLoaded(null, child, tracker)
    }))
  }, andForEachChild(loadDeps, andFinishTracker(log, next)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.prefetchDeps" id="apidoc.element.npm.deps.prefetchDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>prefetchDeps
        <span class="apidocSignatureSpan">(tree, deps, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prefetchDeps(tree, deps, log, next) {
  validate(&apos;OOOF&apos;, arguments)
  var skipOptional = !npm.config.get(&apos;optional&apos;)
  var seen = new Set()
  const finished = andFinishTracker(log, next)
  const fpm = BB.promisify(fetchPackageMetadata)
  resolveBranchDeps(tree.package, deps).then(
    () =&gt; finished(), finished
  )

  function resolveBranchDeps (pkg, deps) {
    return BB.resolve(null).then(() =&gt; {
      var allDependencies = Object.keys(deps).map((dep) =&gt; {
        return npa.resolve(dep, deps[dep])
      }).filter((dep) =&gt; {
        return isRegistry(dep) &amp;&amp;
               !seen.has(dep.toString()) &amp;&amp;
               !findRequirement(tree, dep.name, dep)
      })
      if (skipOptional) {
        var optDeps = pkg.optionalDependencies || {}
        allDependencies = allDependencies.filter((dep) =&gt; !optDeps[dep.name])
      }
      return BB.map(allDependencies, (dep) =&gt; {
        seen.add(dep.toString())
        return fpm(dep, &apos;&apos;, {tracker: log.newItem(&apos;fetchMetadata&apos;)}).then(
          (pkg) =&gt; {
            return pkg &amp;&amp; pkg.dependencies &amp;&amp; resolveBranchDeps(pkg, pkg.dependencies)
          },
          () =&gt; null
        )
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.removeDeps" id="apidoc.element.npm.deps.removeDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>removeDeps
        <span class="apidocSignatureSpan">(args, tree, saveToDependencies, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDeps = function (args, tree, saveToDependencies, next) {
  validate(&apos;AOSF|AOZF&apos;, [args, tree, saveToDependencies, next])
  for (let pkg of args) {
    var pkgName = moduleName(pkg)
    var toRemove = tree.children.filter(moduleNameMatches(pkgName))
    var pkgToRemove = toRemove[0] || createChild({package: {name: pkgName}})
    var saveType = getSaveType(tree, pkg) || &apos;dependencies&apos;
    if (tree.isTop &amp;&amp; saveToDependencies) {
      pkgToRemove.save = saveType
    }
    if (tree.package[saveType][pkgName]) {
      delete tree.package[saveType][pkgName]
      if (saveType === &apos;optionalDependencies&apos; &amp;&amp; tree.package.dependencies[pkgName]) {
        delete tree.package.dependencies[pkgName]
      }
    }
    replaceModuleByPath(tree, &apos;removedChildren&apos;, pkgToRemove)
    for (let parent of pkgToRemove.requiredBy) {
      parent.requires = parent.requires.filter((child) =&gt; child !== pkgToRemove)
    }
    pkgToRemove.requiredBy = pkgToRemove.requiredBy.filter((parent) =&gt; parent !== tree)
    flagAsRemoving(pkgToRemove)
  }
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.removeExtraneous" id="apidoc.element.npm.deps.removeExtraneous">
        function <span class="apidocSignatureSpan">npm.deps.</span>removeExtraneous
        <span class="apidocSignatureSpan">(args, tree, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeExtraneous = function (args, tree, next) {
  for (let pkg of args) {
    var pkgName = moduleName(pkg)
    var toRemove = tree.children.filter(moduleNameMatches(pkgName))
    if (toRemove.length) {
      removeObsoleteDep(toRemove[0])
    }
  }
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.removeObsoleteDep" id="apidoc.element.npm.deps.removeObsoleteDep">
        function <span class="apidocSignatureSpan">npm.deps.</span>removeObsoleteDep
        <span class="apidocSignatureSpan">(child, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeObsoleteDep(child, log) {
  if (child.removed) return
  child.removed = true
  if (log) {
    log.silly(&apos;removeObsoleteDep&apos;, &apos;removing &apos; + packageId(child) +
      &apos; from the tree as its been replaced by a newer version or is no longer required&apos;)
  }
  // remove from physical tree
  if (child.parent) {
    child.parent.children = child.parent.children.filter(function (pchild) { return pchild !== child })
  }
  // remove from logical tree
  var requires = child.requires || []
  requires.forEach(function (requirement) {
    requirement.requiredBy = requirement.requiredBy.filter(function (reqBy) { return reqBy !== child })
    // we don&apos;t just check requirement.requires because that doesn&apos;t account
    // for circular deps.  isExtraneous does.
    if (isExtraneous(requirement)) removeObsoleteDep(requirement, log)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.updatePhantomChildren" id="apidoc.element.npm.deps.updatePhantomChildren">
        function <span class="apidocSignatureSpan">npm.deps.</span>updatePhantomChildren
        <span class="apidocSignatureSpan">(current, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updatePhantomChildren = function (current, child) {
  validate(&apos;OO&apos;, arguments)
  while (current &amp;&amp; current !== child.parent) {
    if (!current.phantomChildren) current.phantomChildren = {}
    current.phantomChildren[moduleName(child)] = child
    current = current.parent
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.validateAllPeerDeps" id="apidoc.element.npm.deps.validateAllPeerDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>validateAllPeerDeps
        <span class="apidocSignatureSpan">(tree, onInvalid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAllPeerDeps = function (tree, onInvalid) {
  validateAllPeerDeps(tree, onInvalid, new Set())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.validatePeerDeps" id="apidoc.element.npm.deps.validatePeerDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>validatePeerDeps
        <span class="apidocSignatureSpan">(tree, onInvalid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatePeerDeps = function (tree, onInvalid) {
  if (!tree.package.peerDependencies) return
  Object.keys(tree.package.peerDependencies).forEach(function (pkgname) {
    var version = tree.package.peerDependencies[pkgname]
    try {
      var spec = npa.resolve(pkgname, version)
    } catch (e) {}
    var match = spec &amp;&amp; findRequirement(tree.parent || tree, pkgname, spec)
    if (!match) onInvalid(tree, pkgname, version)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.diff_trees" id="apidoc.module.npm.diff_trees">module npm.diff_trees</a></h1>


    <h2>
        <a href="#apidoc.element.npm.diff_trees.diff_trees" id="apidoc.element.npm.diff_trees.diff_trees">
        function <span class="apidocSignatureSpan">npm.</span>diff_trees
        <span class="apidocSignatureSpan">(oldTree, newTree, differences, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff_trees = function (oldTree, newTree, differences, log, next) {
  validate(&apos;OOAOF&apos;, arguments)
  pushAll(differences, sortActions(diffTrees(oldTree, newTree)))
  log.finish()
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.diff_trees._diffTrees" id="apidoc.element.npm.diff_trees._diffTrees">
        function <span class="apidocSignatureSpan">npm.diff_trees.</span>_diffTrees
        <span class="apidocSignatureSpan">(oldTree, newTree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_diffTrees = function (oldTree, newTree) {
  validate(&apos;OO&apos;, arguments)
  var differences = []
  var flatOldTree = flattenTree(oldTree)
  var flatNewTree = flattenTree(newTree)
  var toRemove = {}
  var toRemoveByName = {}

  // Build our tentative remove list.  We don&apos;t add remove actions yet
  // because we might resuse them as part of a move.
  Object.keys(flatOldTree).forEach(function (flatname) {
    if (flatname === &apos;/&apos;) return
    if (flatNewTree[flatname]) return
    var pkg = flatOldTree[flatname]
    if (pkg.isInLink &amp;&amp; /^[.][.][/\\]/.test(path.relative(newTree.realpath, pkg.realpath))) return

    toRemove[flatname] = pkg
    var name = moduleName(pkg)
    if (!toRemoveByName[name]) toRemoveByName[name] = []
    toRemoveByName[name].push({flatname: flatname, pkg: pkg})
  })

  // generate our add/update/move actions
  Object.keys(flatNewTree).forEach(function (flatname) {
    if (flatname === &apos;/&apos;) return
    var pkg = flatNewTree[flatname]
    var oldPkg = pkg.oldPkg = flatOldTree[flatname]
    if (oldPkg) {
      // if the versions are equivalent then we don&apos;t need to update unless
      // the user explicitly asked us to.
      if (!pkg.userRequired &amp;&amp; pkgAreEquiv(oldPkg, pkg)) return
      setAction(differences, &apos;update&apos;, pkg)
    } else {
      var name = moduleName(pkg)
      // find any packages we&apos;re removing that share the same name and are equivalent
      var removing = (toRemoveByName[name] || []).filter((rm) =&gt; pkgAreEquiv(rm.pkg, pkg))
      var bundlesOrFromBundle = pkg.fromBundle || pkg.package.bundleDependencies
      // if we have any removes that match AND we&apos;re not working with a bundle then upgrade to a move
      if (removing.length &amp;&amp; !bundlesOrFromBundle) {
        var toMv = removing.shift()
        toRemoveByName[name] = toRemoveByName[name].filter((rm) =&gt; rm !== toMv)
        pkg.fromPath = toMv.pkg.path
        setAction(differences, &apos;move&apos;, pkg)
        delete toRemove[toMv.flatname]
      // we don&apos;t generate add actions for things found in links (which already exist on disk)
      } else if (!pkg.isInLink || !(pkg.fromBundle &amp;&amp; pkg.fromBundle.isLink)) {
        setAction(differences, &apos;add&apos;, pkg)
      }
    }
  })

  // finally generate our remove actions from any not consumed by moves
  Object
    .keys(toRemove)
    .map((flatname) =&gt; toRemove[flatname])
    .forEach((pkg) =&gt; setAction(differences, &apos;remove&apos;, pkg))

  return filterActions(differences)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.diff_trees.sortActions" id="apidoc.element.npm.diff_trees.sortActions">
        function <span class="apidocSignatureSpan">npm.diff_trees.</span>sortActions
        <span class="apidocSignatureSpan">(differences)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortActions = function (differences) {
  var actions = {}
  differences.forEach(function (action) {
    var child = action[1]
    actions[child.location] = action
  })

  var sorted = []
  var added = {}

  var sortedlocs = Object.keys(actions).sort(sortByLocation)

  // We&apos;re going to sort the actions taken on top level dependencies first, before
  // considering the order of transitive deps. Because we&apos;re building our list
  // from the bottom up, this means we will return a list with top level deps LAST.
  // This is important in terms of keeping installations as consistent as possible
  // as folks add new dependencies.
  var toplocs = sortedlocs.filter(function (location) {
    var mod = actions[location][1]
    if (!mod.requiredBy) return true
    // If this module is required by any non-top level module
    // or by any extraneous module, eg user requested or existing
    // then we don&apos;t want to give this priority sorting.
    return !mod.requiredBy.some(isNotTopOrExtraneous)
  })

  toplocs.concat(sortedlocs).forEach(function (location) {
    sortByDeps(actions[location])
  })

  function sortByLocation (aa, bb) {
    return bb.localeCompare(aa)
  }
  function sortModuleByLocation (aa, bb) {
    return sortByLocation(aa &amp;&amp; aa.location, bb &amp;&amp; bb.location)
  }
  function sortByDeps (action) {
    var mod = action[1]
    if (added[mod.location]) return
    added[mod.location] = action
    if (!mod.requiredBy) mod.requiredBy = []
    mod.requiredBy.sort(sortModuleByLocation).forEach(function (mod) {
      if (actions[mod.location]) sortByDeps(actions[mod.location])
    })
    sorted.unshift(action)
  }

  // safety net, anything excluded above gets tacked on the end
  differences.forEach((_) =&gt; {
    if (sorted.indexOf(_) === -1) sorted.push(_)
  })

  return sorted
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.edit" id="apidoc.module.npm.edit">module npm.edit</a></h1>


    <h2>
        <a href="#apidoc.element.npm.edit.edit" id="apidoc.element.npm.edit.edit">
        function <span class="apidocSignatureSpan">npm.</span>edit
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function edit(args, cb) {
  var p = args[0]
  if (args.length !== 1 || !p) return cb(edit.usage)
  var e = npm.config.get(&apos;editor&apos;)
  if (!e) {
    return cb(new Error(
      &quot;No editor set.  Set the &apos;editor&apos; config, or $EDITOR environ.&quot;
    ))
  }
  p = p.split(&apos;/&apos;)
    .join(&apos;/node_modules/&apos;)
    .replace(/(\/node_modules)+/, &apos;/node_modules&apos;)
  var f = path.resolve(npm.dir, p)
  fs.lstat(f, function (er) {
    if (er) return cb(er)
    editor(f, { editor: e }, noProgressTillDone(function (er) {
      if (er) return cb(er)
      npm.commands.rebuild(args, cb)
    }))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.edit.completion" id="apidoc.element.npm.edit.completion">
        function <span class="apidocSignatureSpan">npm.edit.</span>completion
        <span class="apidocSignatureSpan">(opts, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedShallow(opts, filter, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = filter
    filter = null
  }
  var conf = opts.conf
  var args = conf.argv.remain
  if (args.length &gt; 3) return cb()
  var local
  var global
  var localDir = npm.dir
  var globalDir = npm.globalDir
  if (npm.config.get(&apos;global&apos;)) {
    local = []
    next()
  } else {
    fs.readdir(localDir, function (er, pkgs) {
      local = (pkgs || []).filter(function (p) {
        return p.charAt(0) !== &apos;.&apos;
      })
      next()
    })
  }

  fs.readdir(globalDir, function (er, pkgs) {
    global = (pkgs || []).filter(function (p) {
      return p.charAt(0) !== &apos;.&apos;
    })
    next()
  })
  function next () {
    if (!local || !global) return
    filterInstalled(local, global, filter, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.error_handler" id="apidoc.module.npm.error_handler">module npm.error_handler</a></h1>


    <h2>
        <a href="#apidoc.element.npm.error_handler.error_handler" id="apidoc.element.npm.error_handler.error_handler">
        function <span class="apidocSignatureSpan">npm.</span>error_handler
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errorHandler(er) {
  log.disableProgress()
  if (!npm.config || !npm.config.loaded) {
    // logging won&apos;t work unless we pretend that it&apos;s ready
    er = er || new Error(&apos;Exit prior to config file resolving.&apos;)
    console.error(er.stack || er.message)
  }

  if (cbCalled) {
    er = er || new Error(&apos;Callback called more than once.&apos;)
  }

  cbCalled = true
  if (!er) return exit(0)
  if (typeof er === &apos;string&apos;) {
    log.error(&apos;&apos;, er)
    return exit(1, true)
  } else if (!(er instanceof Error)) {
    log.error(&apos;weird error&apos;, er)
    return exit(1, true)
  }

  var m = er.code || er.message.match(/^(?:Error: )?(E[A-Z]+)/)
  if (m &amp;&amp; !er.code) {
    er.code = m
  }

  ;[
    &apos;type&apos;,
    &apos;stack&apos;,
    &apos;statusCode&apos;,
    &apos;pkgid&apos;
  ].forEach(function (k) {
    var v = er[k]
    if (!v) return
    log.verbose(k, v)
  })

  log.verbose(&apos;cwd&apos;, process.cwd())

  var os = require(&apos;os&apos;)
  log.verbose(&apos;&apos;, os.type() + &apos; &apos; + os.release())
  log.verbose(&apos;argv&apos;, process.argv.map(JSON.stringify).join(&apos; &apos;))
  log.verbose(&apos;node&apos;, process.version)
  log.verbose(&apos;npm &apos;, &apos;v&apos; + npm.version)

  ;[
    &apos;file&apos;,
    &apos;path&apos;,
    &apos;code&apos;,
    &apos;errno&apos;,
    &apos;syscall&apos;
  ].forEach(function (k) {
    var v = er[k]
    if (v) log.error(k, v)
  })

  var msg = errorMessage(er)
  msg.summary.concat(msg.detail).forEach(function (errline) {
    log.error.apply(log, errline)
  })
  if (npm.config.get(&apos;json&apos;)) {
    var error = {
      error: {
        code: er.code,
        summary: messageText(msg.summary),
        detail: messageText(msg.detail)
      }
    }
    console.log(JSON.stringify(error, null, 2))
  }

  exit(typeof er.errno === &apos;number&apos; ? er.errno : 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.error_handler.exit" id="apidoc.element.npm.error_handler.exit">
        function <span class="apidocSignatureSpan">npm.error_handler.</span>exit
        <span class="apidocSignatureSpan">(code, noLog)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exit(code, noLog) {
  exitCode = exitCode || process.exitCode || code

  var doExit = npm.config.loaded ? npm.config.get(&apos;_exit&apos;) : true
  log.verbose(&apos;exit&apos;, [code, doExit])
  if (log.level === &apos;silent&apos;) noLog = true

  if (rollbacks.length) {
    chain(rollbacks.map(function (f) {
      return function (cb) {
        npm.commands.unbuild([f], true, cb)
      }
    }), function (er) {
      if (er) {
        log.error(&apos;error rolling back&apos;, er)
        if (!code) {
          errorHandler(er)
        } else {
          if (!noLog) writeLogFile()
          reallyExit(er)
        }
      } else {
        if (!noLog &amp;&amp; code) writeLogFile()
        reallyExit()
      }
    })
    rollbacks.length = 0
  } else if (code &amp;&amp; !noLog) {
    writeLogFile()
  } else {
    reallyExit()
  }

  function reallyExit (er) {
    if (er &amp;&amp; !code) code = typeof er.errno === &apos;number&apos; ? er.errno : 1

    itWorked = !code

    // Exit directly -- nothing in the CLI should still be running in the
    // background at this point, and this makes sure anything left dangling
    // for whatever reason gets thrown away, instead of leaving the CLI open
    //
    // Commands that expect long-running actions should just delay `cb()`
    process.stdout.write(&apos;&apos;, () =&gt; {
      process.exit(code)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var conf = nopt(types, shorthands)
npm.argv = conf.argv.remain
if (npm.deref(npm.argv[0])) npm.command = npm.argv.shift()
else conf.usage = true

if (conf.version) {
  console.log(npm.version)
  return errorHandler.<span class="apidocCodeKeywordSpan">exit</span>(0)
}

if (conf.versions) {
  npm.command = &apos;version&apos;
  conf.usage = false
  npm.argv = []
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.exists" id="apidoc.module.npm.exists">module npm.exists</a></h1>


    <h2>
        <a href="#apidoc.element.npm.exists.exists" id="apidoc.element.npm.exists.exists">
        function <span class="apidocSignatureSpan">npm.</span>exists
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight(&apos;exists:&apos; + dir, done)
  if (!done) return
  fs.access(dir, fs.F_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.exists.fsAccessImplementation" id="apidoc.element.npm.exists.fsAccessImplementation">
        function <span class="apidocSignatureSpan">npm.exists.</span>fsAccessImplementation
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight(&apos;exists:&apos; + dir, done)
  if (!done) return
  fs.access(dir, fs.F_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.exists.fsStatImplementation" id="apidoc.element.npm.exists.fsStatImplementation">
        function <span class="apidocSignatureSpan">npm.exists.</span>fsStatImplementation
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsStatImplementation(dir, done) {
  done = inflight(&apos;exists:&apos; + dir, done)
  if (!done) return
  fs.stat(dir, function (er) { done(accessError(dir, er)) })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.explore" id="apidoc.module.npm.explore">module npm.explore</a></h1>


    <h2>
        <a href="#apidoc.element.npm.explore.explore" id="apidoc.element.npm.explore.explore">
        function <span class="apidocSignatureSpan">npm.</span>explore
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function explore(args, cb) {
  if (args.length &lt; 1 || !args[0]) return cb(explore.usage)
  var p = args.shift()

  var cwd = path.resolve(npm.dir, p)
  var opts = {cwd: cwd, stdio: &apos;inherit&apos;}

  var shellArgs = []
  if (args) {
    if (isWindowsShell) {
      var execCmd = escapeExecPath(args.shift())
      var execArgs = [execCmd].concat(args.map(escapeArg))
      opts.windowsVerbatimArguments = true
      shellArgs = [&apos;/d&apos;, &apos;/s&apos;, &apos;/c&apos;].concat(execArgs)
    } else {
      shellArgs.unshift(&apos;-c&apos;)
      shellArgs = [&apos;-c&apos;, args.map(escapeArg).join(&apos; &apos;).trim()]
    }
  }

  var sh = npm.config.get(&apos;shell&apos;)
  fs.stat(cwd, function (er, s) {
    if (er || !s.isDirectory()) {
      return cb(new Error(
        &quot;It doesn&apos;t look like &quot; + p + &apos; is installed.&apos;
      ))
    }

    if (!shellArgs.length) {
      output(
        &apos;\nExploring &apos; + cwd + &apos;\n&apos; +
          &quot;Type &apos;exit&apos; or ^D when finished\n&quot;
      )
    }

    var shell = spawn(sh, shellArgs, opts)
    shell.on(&apos;close&apos;, function (er) {
      // only fail if non-interactive.
      if (!shellArgs.length) return cb()
      cb(er)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.explore.completion" id="apidoc.element.npm.explore.completion">
        function <span class="apidocSignatureSpan">npm.explore.</span>completion
        <span class="apidocSignatureSpan">(opts, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedShallow(opts, filter, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = filter
    filter = null
  }
  var conf = opts.conf
  var args = conf.argv.remain
  if (args.length &gt; 3) return cb()
  var local
  var global
  var localDir = npm.dir
  var globalDir = npm.globalDir
  if (npm.config.get(&apos;global&apos;)) {
    local = []
    next()
  } else {
    fs.readdir(localDir, function (er, pkgs) {
      local = (pkgs || []).filter(function (p) {
        return p.charAt(0) !== &apos;.&apos;
      })
      next()
    })
  }

  fs.readdir(globalDir, function (er, pkgs) {
    global = (pkgs || []).filter(function (p) {
      return p.charAt(0) !== &apos;.&apos;
    })
    next()
  })
  function next () {
    if (!local || !global) return
    filterInstalled(local, global, filter, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.extract" id="apidoc.module.npm.extract">module npm.extract</a></h1>


    <h2>
        <a href="#apidoc.element.npm.extract.extract" id="apidoc.element.npm.extract.extract">
        function <span class="apidocSignatureSpan">npm.</span>extract
        <span class="apidocSignatureSpan">(staging, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extract(staging, pkg, log) {
  log.silly(&apos;extract&apos;, packageId(pkg))
  const extractTo = moduleStagingPath(staging, pkg)
  if (!pacoteOpts) {
    pacoteOpts = require(&apos;../../config/pacote&apos;)
  }
  const opts = pacoteOpts({
    integrity: pkg.package._integrity,
    resolved: pkg.package._resolved
  })
  const args = [
    pkg.package._requested,
    extractTo,
    opts
  ]
  return BB.fromNode((cb) =&gt; {
    let launcher = localWorker
    let msg = args
    const spec = typeof args[0] === &apos;string&apos; ? npa(args[0]) : args[0]
    args[0] = spec.raw
    if (ENABLE_WORKERS &amp;&amp; (isRegistry(spec) || spec.type === &apos;remote&apos;)) {
      // We can&apos;t serialize these options
      opts.loglevel = opts.log.level
      opts.log = null
      opts.dirPacker = null
      // workers will run things in parallel!
      launcher = workers
      try {
        msg = JSON.stringify(msg)
      } catch (e) {
        return cb(e)
      }
    }
    launcher(msg, cb)
  }).then(() =&gt; {
    if (pkg.package.bundleDependencies || anyBundled(pkg)) {
      return readBundled(pkg, staging, extractTo)
    }
  }).then(() =&gt; {
    return gentlyRm(path.join(extractTo, &apos;node_modules&apos;))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  })
}

cache.unpack = unpack
function unpack (pkg, ver, unpackTarget, dmode, fmode, uid, gid) {
  return unbuild([unpackTarget], true).then(() =&gt; {
    const opts = pacoteOpts({dmode, fmode, uid, gid, offline: true})
    return pacote.<span class="apidocCodeKeywordSpan">extract</span>(npa.resolve(pkg, ver), unpackTarget, opts)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.extract.init" id="apidoc.element.npm.extract.init">
        function <span class="apidocSignatureSpan">npm.extract.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  if (ENABLE_WORKERS) {
    workers = workerFarm({
      maxConcurrentCallsPerWorker: npm.limit.fetch,
      maxRetries: 1
    }, WORKER_PATH)
  }
  return BB.resolve()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function timeEnd (log) {
process.emit(&apos;timeEnd&apos;, &apos;action:&apos; + log.name)
}

function withInit (action, body) {
return BB.using(
  action.<span class="apidocCodeKeywordSpan">init</span>().disposer(() =&gt; action.teardown()),
  body
)
}

function prepareAction (action, staging, log) {
validate(&apos;ASO&apos;, arguments)
validate(&apos;SO&apos;, action)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.extract.teardown" id="apidoc.element.npm.extract.teardown">
        function <span class="apidocSignatureSpan">npm.extract.</span>teardown
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  if (ENABLE_WORKERS) {
    workerFarm.end(workers)
    workers = null
  }
  return BB.resolve()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function timeEnd (log) {
process.emit(&apos;timeEnd&apos;, &apos;action:&apos; + log.name)
}

function withInit (action, body) {
return BB.using(
  action.init().disposer(() =&gt; action.<span class="apidocCodeKeywordSpan">teardown</span>()),
  body
)
}

function prepareAction (action, staging, log) {
validate(&apos;ASO&apos;, arguments)
validate(&apos;SO&apos;, action)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.fetch_opts" id="apidoc.module.npm.fetch_opts">module npm.fetch_opts</a></h1>


    <h2>
        <a href="#apidoc.element.npm.fetch_opts.fromPacote" id="apidoc.element.npm.fetch_opts.fromPacote">
        function <span class="apidocSignatureSpan">npm.fetch_opts.</span>fromPacote
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromPacote(opts) {
  return {
    cache: getCacheMode(opts),
    cacheManager: opts.cache,
    ca: opts.ca,
    cert: opts.cert,
    headers: getHeaders(&apos;&apos;, opts.registry, opts),
    key: opts.key,
    localAddress: opts.localAddress,
    maxSockets: opts.maxSockets,
    proxy: opts.proxy,
    referer: opts.refer,
    retry: opts.retry,
    strictSSL: !!opts.strictSSL,
    timeout: opts.timeout,
    uid: opts.uid,
    gid: opts.gid
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  log: log,
  creds: creds,
  registry: registry,
  auth: {
    otp: npm.config.get(&apos;otp&apos;)
  },
  scope: scope,
  opts: fetchOpts.<span class="apidocCodeKeywordSpan">fromPacote</span>(pacoteOpts())
}
login(conf).then((newCreds) =&gt; cb(null, newCreds)).catch(cb)
}

function login (conf) {
return profile.login(openerPromise, loginPrompter, conf)
  .catch((err) =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.fetch_package_metadata" id="apidoc.module.npm.fetch_package_metadata">module npm.fetch_package_metadata</a></h1>


    <h2>
        <a href="#apidoc.element.npm.fetch_package_metadata.fetch_package_metadata" id="apidoc.element.npm.fetch_package_metadata.fetch_package_metadata">
        function <span class="apidocSignatureSpan">npm.</span>fetch_package_metadata
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function limited() {
  var self = this
  var args = Array.prototype.slice.call(arguments)
  if (running &gt;= maxRunning) {
    queue.push({self: this, args: args})
    return
  }
  var cb = typeof args[args.length-1] === &apos;function&apos; &amp;&amp; args.pop()
  ++ running
  args.push(function () {
    var cbargs = arguments
    -- running
    cb &amp;&amp; process.nextTick(function () {
      cb.apply(self, cbargs)
    })
    if (queue.length) {
      var next = queue.shift()
      limited.apply(next.self, next.args)
    }
  })
  func.apply(self, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.fetch_package_metadata.addBundled" id="apidoc.element.npm.fetch_package_metadata.addBundled">
        function <span class="apidocSignatureSpan">npm.fetch_package_metadata.</span>addBundled
        <span class="apidocSignatureSpan">(pkg, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addBundled(pkg, next) {
  validate(&apos;OF&apos;, arguments)
  if (!pacoteOpts) {
    pacoteOpts = require(&apos;./config/pacote&apos;)
  }
  if (pkg._bundled !== undefined) return next(null, pkg)

  if (!pkg.bundleDependencies &amp;&amp; pkg._requested.type !== &apos;directory&apos;) return next(null, pkg)
  const requested = pkg._requested || npa(pkg._from)
  if (requested.type === &apos;directory&apos;) {
    pkg._bundled = null
    return readPackageTree(pkg._requested.fetchSpec, function (er, tree) {
      if (tree) pkg._bundled = tree.children
      return next(null, pkg)
    })
  }
  pkg._bundled = null
  const target = tempFilename(&apos;unpack&apos;)
  const opts = pacoteOpts({integrity: pkg._integrity})
  pacote.extract(pkg._resolved || pkg._requested || npa.resolve(pkg.name, pkg.version), target, opts).then(() =&gt; {
    log.silly(&apos;addBundled&apos;, &apos;read tarball&apos;)
    readPackageTree(target, (err, tree) =&gt; {
      if (err) { return next(err) }
      log.silly(&apos;cleanup&apos;, &apos;remove extracted module&apos;)
      rimraf(target, function () {
        if (tree) {
          pkg._bundled = tree.children
        }
        next(null, pkg)
      })
    })
  }, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.finalize" id="apidoc.module.npm.finalize">module npm.finalize</a></h1>


    <h2>
        <a href="#apidoc.element.npm.finalize.finalize" id="apidoc.element.npm.finalize.finalize">
        function <span class="apidocSignatureSpan">npm.</span>finalize
        <span class="apidocSignatureSpan">(staging, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function (staging, pkg, log) {
  log.silly(&apos;finalize&apos;, pkg.realpath)

  const extractedTo = moduleStagingPath(staging, pkg)

  const delpath = path.join(path.dirname(pkg.realpath), &apos;.&apos; + path.basename(pkg.realpath) + &apos;.DELETE&apos;)
  let movedDestAway = false

  const requested = pkg.package._requested || getRequested(pkg)
  if (requested.type === &apos;directory&apos;) {
    const relative = path.relative(path.dirname(pkg.path), pkg.realpath)
    return makeParentPath(pkg.path)
      .then(() =&gt; symlink(relative, pkg.path, &apos;junction&apos;))
      .catch((ex) =&gt; {
        return rimraf(pkg.path).then(() =&gt; symlink(relative, pkg.path, &apos;junction&apos;))
      })
  } else {
    return makeParentPath(pkg.realpath)
      .then(moveStagingToDestination)
      .then(restoreOldNodeModules)
      .catch((err) =&gt; {
        if (movedDestAway) {
          return rimraf(pkg.realpath).then(moveOldDestinationBack).then(() =&gt; {
            throw err
          })
        } else {
          throw err
        }
      })
      .then(() =&gt; rimraf(delpath))
  }

  function makeParentPath (dir) {
    return mkdirp(path.dirname(dir))
  }

  function moveStagingToDestination () {
    return destinationIsClear()
      .then(actuallyMoveStaging)
      .catch(() =&gt; moveOldDestinationAway().then(actuallyMoveStaging))
  }

  function destinationIsClear () {
    return lstat(pkg.realpath).then(() =&gt; {
      throw new Error(&apos;destination exists&apos;)
    }, () =&gt; {})
  }

  function actuallyMoveStaging () {
    return move(extractedTo, pkg.realpath, moveOpts)
  }

  function moveOldDestinationAway () {
    return rimraf(delpath).then(() =&gt; {
      return move(pkg.realpath, delpath, moveOpts)
    }).then(() =&gt; { movedDestAway = true })
  }

  function moveOldDestinationBack () {
    return move(delpath, pkg.realpath, moveOpts).then(() =&gt; { movedDestAway = false })
  }

  function restoreOldNodeModules () {
    if (!movedDestAway) return
    return readdir(path.join(delpath, &apos;node_modules&apos;)).catch(() =&gt; []).then((modules) =&gt; {
      if (!modules.length) return
      return mkdirp(path.join(pkg.realpath, &apos;node_modules&apos;)).then(() =&gt; Bluebird.map(modules, (file) =&gt; {
        const from = path.join(delpath, &apos;node_modules&apos;, file)
        const to = path.join(pkg.realpath, &apos;node_modules&apos;, file)
        return move(from, to, moveOpts)
      }))
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.finalize.rollback" id="apidoc.element.npm.finalize.rollback">
        function <span class="apidocSignatureSpan">npm.finalize.</span>rollback
        <span class="apidocSignatureSpan">(top, staging, pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (top, staging, pkg) {
  return Bluebird.try(() =&gt; {
    const requested = pkg.package._requested || getRequested(pkg)
    if (requested &amp;&amp; requested.type === &apos;directory&apos;) return Promise.resolve()
    // strictly speaking rolling back a finalize should ONLY remove module that
    // was being finalized, not any of the things under it. But currently
    // those modules are guaranteed to be useless so we may as well remove them too.
    // When/if we separate `commit` step and can rollback to previous versions
    // of upgraded modules then we&apos;ll need to revisit this
    return gentlyRm(pkg.path, false, top).catch((err) =&gt; {
      log.warn(&apos;rollback&apos;, `Rolling back ${packageId(pkg)} failed (this is probably harmless): ${err.message ? err.message : err
}`)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.flatten_tree" id="apidoc.module.npm.flatten_tree">module npm.flatten_tree</a></h1>


    <h2>
        <a href="#apidoc.element.npm.flatten_tree.flatten_tree" id="apidoc.element.npm.flatten_tree.flatten_tree">
        function <span class="apidocSignatureSpan">npm.</span>flatten_tree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenTree(tree) {
  validate(&apos;O&apos;, arguments)
  var seen = new Set()
  var flat = {}
  var todo = [[tree, &apos;/&apos;]]
  while (todo.length) {
    var next = todo.shift()
    var pkg = next[0]
    seen.add(pkg)
    var path = next[1]
    flat[path] = pkg
    if (path !== &apos;/&apos;) path += &apos;/&apos;
    for (var ii = 0; ii &lt; pkg.children.length; ++ii) {
      var child = pkg.children[ii]
      if (!seen.has(child)) {
        todo.push([child, flatName(path, child)])
      }
    }
  }
  return flat
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.flatten_tree.flatName" id="apidoc.element.npm.flatten_tree.flatName">
        function <span class="apidocSignatureSpan">npm.flatten_tree.</span>flatName
        <span class="apidocSignatureSpan">(path, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatName(path, child) {
  validate(&apos;SO&apos;, arguments)
  return path + (moduleName(child) || &apos;TOP&apos;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.flatten_tree.flatNameFromTree" id="apidoc.element.npm.flatten_tree.flatNameFromTree">
        function <span class="apidocSignatureSpan">npm.flatten_tree.</span>flatNameFromTree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatNameFromTree(tree) {
  validate(&apos;O&apos;, arguments)
  if (tree.isTop) return &apos;/&apos;
  var path = flatNameFromTree(tree.parent)
  if (path !== &apos;/&apos;) path += &apos;/&apos;
  return flatName(path, tree)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.help" id="apidoc.module.npm.help">module npm.help</a></h1>


    <h2>
        <a href="#apidoc.element.npm.help.help" id="apidoc.element.npm.help.help">
        function <span class="apidocSignatureSpan">npm.</span>help
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function help(args, cb) {
  var argv = npm.config.get(&apos;argv&apos;).cooked

  var argnum = 0
  if (args.length === 2 &amp;&amp; ~~args[0]) {
    argnum = ~~args.shift()
  }

  // npm help foo bar baz: search topics
  if (args.length &gt; 1 &amp;&amp; args[0]) {
    return npm.commands[&apos;help-search&apos;](args, argnum, cb)
  }

  var section = npm.deref(args[0]) || args[0]

  // npm help &lt;noargs&gt;:  show basic usage
  if (!section) {
    var valid = argv[0] === &apos;help&apos; ? 0 : 1
    return npmUsage(valid, cb)
  }

  // npm &lt;command&gt; -h: show command usage
  if (npm.config.get(&apos;usage&apos;) &amp;&amp;
      npm.commands[section] &amp;&amp;
      npm.commands[section].usage) {
    npm.config.set(&apos;loglevel&apos;, &apos;silent&apos;)
    log.level = &apos;silent&apos;
    output(npm.commands[section].usage)
    return cb()
  }

  // npm apihelp &lt;section&gt;: Prefer section 3 over section 1
  var apihelp = argv.length &amp;&amp; argv[0].indexOf(&apos;api&apos;) !== -1
  var pref = apihelp ? [3, 1, 5, 7] : [1, 3, 5, 7]
  if (argnum) {
    pref = [ argnum ].concat(pref.filter(function (n) {
      return n !== argnum
    }))
  }

  // npm help &lt;section&gt;: Try to find the path
  var manroot = path.resolve(__dirname, &apos;..&apos;, &apos;man&apos;)

  // legacy
  if (section === &apos;global&apos;) section = &apos;folders&apos;
  else if (section === &apos;json&apos;) section = &apos;package.json&apos;

  // find either /section.n or /npm-section.n
  // The glob is used in the glob.  The regexp is used much
  // further down.  Globs and regexps are different
  var compextglob = &apos;.+(gz|bz2|lzma|[FYzZ]|xz)&apos;
  var compextre = &apos;\\.(gz|bz2|lzma|[FYzZ]|xz)$&apos;
  var f = &apos;+(npm-&apos; + section + &apos;|&apos; + section + &apos;).[0-9]?(&apos; + compextglob + &apos;)&apos;
  return glob(manroot + &apos;/*/&apos; + f, function (er, mans) {
    if (er) return cb(er)

    if (!mans.length) return npm.commands[&apos;help-search&apos;](args, cb)

    mans = mans.map(function (man) {
      var ext = path.extname(man)
      if (man.match(new RegExp(compextre))) man = path.basename(man, ext)

      return man
    })

    viewMan(pickMan(mans, pref), cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    hits: found,
    totalHits: totalHits
  })
})

// if only one result, then just show that help section.
if (results.length === 1) {
  return npm.commands.<span class="apidocCodeKeywordSpan">help</span>([results[0].file.replace(/\.md$/, &apos;&apos;)], cb)
}

if (results.length === 0) {
  output(&apos;No results for &apos; + args.map(JSON.stringify).join(&apos; &apos;))
  return cb()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.help.completion" id="apidoc.element.npm.help.completion">
        function <span class="apidocSignatureSpan">npm.help.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  if (opts.conf.argv.remain.length &gt; 2) return cb(null, [])
  getSections(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.install" id="apidoc.module.npm.install">module npm.install</a></h1>


    <h2>
        <a href="#apidoc.element.npm.install.install" id="apidoc.element.npm.install.install">
        function <span class="apidocSignatureSpan">npm.</span>install
        <span class="apidocSignatureSpan">(where, args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function install(where, args, cb) {
  if (!cb) {
    cb = args
    args = where
    where = null
  }
  var globalTop = path.resolve(npm.globalDir, &apos;..&apos;)
  if (!where) {
    where = npm.config.get(&apos;global&apos;)
      ? globalTop
      : npm.prefix
  }
  validate(&apos;SAF&apos;, [where, args, cb])
  // the /path/to/node_modules/..
  var dryrun = !!npm.config.get(&apos;dry-run&apos;)

  if (npm.config.get(&apos;dev&apos;)) {
    log.warn(&apos;install&apos;, &apos;Usage of the `--dev` option is deprecated. Use `--only=dev` instead.&apos;)
  }

  if (where === globalTop &amp;&amp; !args.length) {
    args = [&apos;.&apos;]
  }
  args = args.filter(function (a) {
    return path.resolve(a) !== npm.prefix
  })

  new Installer(where, dryrun, args).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// if it&apos;s a folder, a random not-installed thing, or not a scoped package,
// then link or install it first
if (pkg[0] !== &apos;@&apos; &amp;&amp; (pkg.indexOf(&apos;/&apos;) !== -1 || pkg.indexOf(&apos;\\&apos;) !== -1)) {
  return fs.lstat(path.resolve(pkg), function (er, st) {
    if (er || !st.isDirectory()) {
      npm.commands.<span class="apidocCodeKeywordSpan">install</span>(t, pkg, n)
    } else {
      rp = path.resolve(pkg)
      linkPkg(rp, n)
    }
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.install.Installer" id="apidoc.element.npm.install.Installer">
        function <span class="apidocSignatureSpan">npm.install.</span>Installer
        <span class="apidocSignatureSpan">(where, dryrun, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Installer(where, dryrun, args, opts) {
  validate(&apos;SBA|SBAO&apos;, arguments)
  if (!opts) opts = {}
  this.where = where
  this.dryrun = dryrun
  this.args = args
  // fakechildren are children created from the lockfile and lack relationship data
  // the only exist when the tree does not match the lockfile
  // this is fine when doing full tree installs/updates but not ok when modifying only
  // a few deps via `npm install` or `npm uninstall`.
  this.currentTree = null
  this.idealTree = null
  this.differences = []
  this.todo = []
  this.progress = {}
  this.noPackageJsonOk = !!args.length
  this.topLevelLifecycles = !args.length

  this.autoPrune = npm.config.get(&apos;package-lock&apos;)

  const dev = npm.config.get(&apos;dev&apos;)
  const only = npm.config.get(&apos;only&apos;)
  const onlyProd = /^prod(uction)?$/.test(only)
  const onlyDev = /^dev(elopment)?$/.test(only)
  const prod = npm.config.get(&apos;production&apos;)
  this.dev = opts.dev != null ? opts.dev : dev || (!onlyProd &amp;&amp; !prod) || onlyDev
  this.prod = opts.prod != null ? opts.prod : !onlyDev

  this.packageLockOnly = opts.packageLockOnly != null
    ? opts.packageLockOnly : npm.config.get(&apos;package-lock-only&apos;)
  this.rollback = opts.rollback != null ? opts.rollback : npm.config.get(&apos;rollback&apos;)
  this.link = opts.link != null ? opts.link : npm.config.get(&apos;link&apos;)
  this.saveOnlyLock = opts.saveOnlyLock
  this.global = opts.global != null ? opts.global : this.where === path.resolve(npm.globalDir, &apos;..&apos;)
  this.audit = npm.config.get(&apos;audit&apos;) &amp;&amp; !this.global
  this.started = Date.now()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.install.completion" id="apidoc.element.npm.install.completion">
        function <span class="apidocSignatureSpan">npm.install.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  validate(&apos;OF&apos;, arguments)
  // install can complete to a folder with a package.json, or any package.
  // if it has a slash, then it&apos;s gotta be a folder
  // if it starts with https?://, then just give up, because it&apos;s a url
  if (/^https?:\/\//.test(opts.partialWord)) {
    // do not complete to URLs
    return cb(null, [])
  }

  if (/\//.test(opts.partialWord)) {
    // Complete fully to folder if there is exactly one match and it
    // is a folder containing a package.json file.  If that is not the
    // case we return 0 matches, which will trigger the default bash
    // complete.
    var lastSlashIdx = opts.partialWord.lastIndexOf(&apos;/&apos;)
    var partialName = opts.partialWord.slice(lastSlashIdx + 1)
    var partialPath = opts.partialWord.slice(0, lastSlashIdx)
    if (partialPath === &apos;&apos;) partialPath = &apos;/&apos;

    var annotatePackageDirMatch = function (sibling, cb) {
      var fullPath = path.join(partialPath, sibling)
      if (sibling.slice(0, partialName.length) !== partialName) {
        return cb(null, null) // not name match
      }
      fs.readdir(fullPath, function (err, contents) {
        if (err) return cb(null, { isPackage: false })

        cb(
          null,
          {
            fullPath: fullPath,
            isPackage: contents.indexOf(&apos;package.json&apos;) !== -1
          }
        )
      })
    }

    return fs.readdir(partialPath, function (err, siblings) {
      if (err) return cb(null, []) // invalid dir: no matching

      asyncMap(siblings, annotatePackageDirMatch, function (err, matches) {
        if (err) return cb(err)

        var cleaned = matches.filter(function (x) { return x !== null })
        if (cleaned.length !== 1) return cb(null, [])
        if (!cleaned[0].isPackage) return cb(null, [])

        // Success - only one match and it is a package dir
        return cb(null, [cleaned[0].fullPath])
      })
    })
  }

  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.legacy" id="apidoc.module.npm.legacy">module npm.legacy</a></h1>


    <h2>
        <a href="#apidoc.element.npm.legacy.login" id="apidoc.element.npm.legacy.login">
        function <span class="apidocSignatureSpan">npm.legacy.</span>login
        <span class="apidocSignatureSpan">(creds, registry, scope, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(creds, registry, scope, cb) =&gt; {
  const conf = {
    log: log,
    creds: creds,
    registry: registry,
    auth: {
      otp: npm.config.get(&apos;otp&apos;)
    },
    scope: scope,
    opts: fetchOpts.fromPacote(pacoteOpts())
  }
  login(conf).then((newCreds) =&gt; cb(null, newCreds)).catch(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log.disableProgress()

try {
  var auth = require(&apos;./auth/&apos; + npm.config.get(&apos;auth-type&apos;))
} catch (e) {
  return cb(new Error(&apos;no such auth module&apos;))
}
auth.<span class="apidocCodeKeywordSpan">login</span>(creds, registry, scope, function (err, newCreds) {
  if (err) return cb(err)

  npm.config.del(&apos;_token&apos;, &apos;user&apos;) // prevent legacy pollution
  if (scope) npm.config.set(scope + &apos;:registry&apos;, registry, &apos;user&apos;)
  npm.config.setCredentialsByURI(registry, newCreds)
  npm.config.save(&apos;user&apos;, cb)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.link" id="apidoc.module.npm.link">module npm.link</a></h1>


    <h2>
        <a href="#apidoc.element.npm.link.link" id="apidoc.element.npm.link.link">
        function <span class="apidocSignatureSpan">npm.</span>link
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function link(args, cb) {
  if (process.platform === &apos;win32&apos;) {
    var semver = require(&apos;semver&apos;)
    if (!semver.gte(process.version, &apos;0.7.9&apos;)) {
      var msg = &apos;npm link not supported on windows prior to node 0.7.9&apos;
      var e = new Error(msg)
      e.code = &apos;ENOTSUP&apos;
      e.errno = require(&apos;constants&apos;).ENOTSUP // eslint-disable-line node/no-deprecated-api
      return cb(e)
    }
  }

  if (npm.config.get(&apos;global&apos;)) {
    return cb(new Error(
      &apos;link should never be --global.\n&apos; +
      &apos;Please re-run this command with --local&apos;
    ))
  }

  if (args.length === 1 &amp;&amp; args[0] === &apos;.&apos;) args = []
  if (args.length) return linkInstall(args, cb)
  linkPkg(npm.prefix, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.link.completion" id="apidoc.element.npm.link.completion">
        function <span class="apidocSignatureSpan">npm.link.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var dir = npm.globalDir
  fs.readdir(dir, function (er, files) {
    cb(er, files.filter(function (f) {
      return !f.match(/^[._-]/)
    }))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.locker" id="apidoc.module.npm.locker">module npm.locker</a></h1>


    <h2>
        <a href="#apidoc.element.npm.locker.lock" id="apidoc.element.npm.locker.lock">
        function <span class="apidocSignatureSpan">npm.locker.</span>lock
        <span class="apidocSignatureSpan">(base, name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lock(base, name, cb) {
  var lockDir = resolve(npm.cache, &apos;_locks&apos;)
  correctMkdir(lockDir, function (er) {
    if (er) return cb(er)

    var opts = {
      stale: npm.config.get(&apos;cache-lock-stale&apos;),
      retries: npm.config.get(&apos;cache-lock-retries&apos;),
      wait: npm.config.get(&apos;cache-lock-wait&apos;)
    }
    var lf = lockFileName(base, name)
    lockfile.lock(lf, opts, function (er) {
      if (er) log.warn(&apos;locking&apos;, lf, &apos;failed&apos;, er)

      if (!er) {
        log.verbose(&apos;lock&apos;, &apos;using&apos;, lf, &apos;for&apos;, resolve(base, name))
        installLocks[lf] = true
      }

      cb(er)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.locker.unlock" id="apidoc.element.npm.locker.unlock">
        function <span class="apidocSignatureSpan">npm.locker.</span>unlock
        <span class="apidocSignatureSpan">(base, name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unlock(base, name, cb) {
  var lf = lockFileName(base, name)
  var locked = installLocks[lf]
  if (locked === false) {
    return process.nextTick(cb)
  } else if (locked === true) {
    lockfile.unlock(lf, function (er) {
      if (er) {
        log.warn(&apos;unlocking&apos;, lf, &apos;failed&apos;, er)
      } else {
        installLocks[lf] = false
        log.verbose(&apos;unlock&apos;, &apos;done using&apos;, lf, &apos;for&apos;, resolve(base, name))
      }

      cb(er)
    })
  } else {
    var notLocked = new Error(
      &apos;Attempt to unlock &apos; + resolve(base, name) + &quot;, which hasn&apos;t been locked&quot;
    )
    notLocked.code = &apos;ENOTLOCKED&apos;
    throw notLocked
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.ls" id="apidoc.module.npm.ls">module npm.ls</a></h1>


    <h2>
        <a href="#apidoc.element.npm.ls.ls" id="apidoc.element.npm.ls.ls">
        function <span class="apidocSignatureSpan">npm.</span>ls
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ls(args, silent, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }
  var dir = path.resolve(npm.dir, &apos;..&apos;)
  readPackageTree(dir, function (_, physicalTree) {
    if (!physicalTree) physicalTree = {package: {}, path: dir}
    physicalTree.isTop = true
    readShrinkwrap.andInflate(physicalTree, function () {
      lsFromTree(dir, computeMetadata(physicalTree), args, silent, cb)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        npm.config.get(&apos;unicode&apos;) ? &apos;  &apos; : &apos; -&gt; &apos;
      } ${hook.endpoint}`)
    }
  })
}

function ls (pkg) {
return hookApi.<span class="apidocCodeKeywordSpan">ls</span>(pkg, config())
  .then((hooks) =&gt; {
    if (npm.config.get(&apos;json&apos;)) {
      output(JSON.stringify(hooks, null, 2))
    } else if (!hooks.length) {
      output(&quot;You don&apos;t have any hooks configured yet.&quot;)
    } else {
      if (hooks.length === 1) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ls.completion" id="apidoc.element.npm.ls.completion">
        function <span class="apidocSignatureSpan">npm.ls.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedDeep(opts, cb) {
  var local
  var global
  var depth = npm.config.get(&apos;depth&apos;)
  var opt = { depth: depth, dev: true }

  if (npm.config.get(&apos;global&apos;)) {
    local = []
    next()
  } else {
    readInstalled(npm.prefix, opt, function (er, data) {
      local = getNames(data || {})
      next()
    })
  }

  readInstalled(npm.config.get(&apos;prefix&apos;), opt, function (er, data) {
    global = getNames(data || {})
    next()
  })

  function getNames_ (d, n) {
    if (d.realName &amp;&amp; n) {
      if (n[d.realName]) return n
      n[d.realName] = true
    }
    if (!n) n = {}
    Object.keys(d.dependencies || {}).forEach(function (dep) {
      getNames_(d.dependencies[dep], n)
    })
    return n
  }
  function getNames (d) {
    return Object.keys(getNames_(d))
  }

  function next () {
    if (!local || !global) return
    if (!npm.config.get(&apos;global&apos;)) {
      global = global.map(function (g) {
        return [g, &apos;-g&apos;]
      })
    }
    var names = local.concat(global)
    return cb(null, names)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ls.fromTree" id="apidoc.element.npm.ls.fromTree">
        function <span class="apidocSignatureSpan">npm.ls.</span>fromTree
        <span class="apidocSignatureSpan">(dir, physicalTree, args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromTree = function (dir, physicalTree, args, silent, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }

  // npm ls &apos;foo@~1.3&apos; bar &apos;baz@&lt;2&apos;
  if (!args) {
    args = []
  } else {
    args = args.map(function (a) {
      if (typeof a === &apos;object&apos;) {
        return [a.package.name, a.package.version, a]
      } else {
        var p = npa(a)
        var name = p.name
        // When version spec is missing, we&apos;ll skip using it when filtering.
        // Otherwise, `semver.validRange` would return &apos;*&apos;, which won&apos;t
        // match prerelease versions.
        var ver = (p.rawSpec &amp;&amp;
                   (semver.validRange(p.rawSpec) || &apos;&apos;))
        return [ name, ver, a ]
      }
    })
  }

  var data = mutateIntoLogicalTree.asReadInstalled(physicalTree)

  pruneNestedExtraneous(data)
  filterByEnv(data)
  filterByLink(data)

  var unlooped = filterFound(unloop(data), args)
  var lite = getLite(unlooped)

  if (silent) return cb(null, data, lite)

  var long = npm.config.get(&apos;long&apos;)
  var json = npm.config.get(&apos;json&apos;)
  var out
  if (json) {
    var seen = new Set()
    var d = long ? unlooped : lite
    // the raw data can be circular
    out = JSON.stringify(d, function (k, o) {
      if (typeof o === &apos;object&apos;) {
        if (seen.has(o)) return &apos;[Circular]&apos;
        seen.add(o)
      }
      return o
    }, 2)
  } else if (npm.config.get(&apos;parseable&apos;)) {
    out = makeParseable(unlooped, long, dir)
  } else if (data) {
    out = makeArchy(unlooped, long, dir)
  }
  output(out)

  if (args.length &amp;&amp; !data._found) process.exitCode = 1

  var er
  // if any errors were found, then complain and exit status 1
  if (lite.problems &amp;&amp; lite.problems.length) {
    er = lite.problems.join(&apos;\n&apos;)
  }
  cb(er, data, lite)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.metrics" id="apidoc.module.npm.metrics">module npm.metrics</a></h1>


    <h2>
        <a href="#apidoc.element.npm.metrics.save" id="apidoc.element.npm.metrics.save">
        function <span class="apidocSignatureSpan">npm.metrics.</span>save
        <span class="apidocSignatureSpan">(itWorked)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function saveMetrics(itWorked) {
  if (inMetrics) return
  // If the metrics reporter hasn&apos;t managed to PUT yet then kill it so that it doesn&apos;t
  // step on our updating the anonymous-cli-metrics json
  stopMetrics()
  var metricsFile = path.join(npm.config.get(&apos;cache&apos;), &apos;anonymous-cli-metrics.json&apos;)
  var metrics
  try {
    metrics = JSON.parse(fs.readFileSync(metricsFile))
    metrics.metrics.to = new Date().toISOString()
    if (itWorked) {
      ++metrics.metrics.successfulInstalls
    } else {
      ++metrics.metrics.failedInstalls
    }
  } catch (ex) {
    metrics = {
      metricId: uuid.v4(),
      metrics: {
        from: new Date().toISOString(),
        to: new Date().toISOString(),
        successfulInstalls: itWorked ? 1 : 0,
        failedInstalls: itWorked ? 0 : 1
      }
    }
  }
  try {
    fs.writeFileSync(metricsFile, JSON.stringify(metrics))
  } catch (ex) {
    // we couldn&apos;t write the error metrics file, um, well, oh well.
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  auth.login(creds, registry, scope, function (err, newCreds) {
    if (err) return cb(err)

    npm.config.del(&apos;_token&apos;, &apos;user&apos;) // prevent legacy pollution
    if (scope) npm.config.set(scope + &apos;:registry&apos;, registry, &apos;user&apos;)
    npm.config.setCredentialsByURI(registry, newCreds)
    npm.config.<span class="apidocCodeKeywordSpan">save</span>(&apos;user&apos;, cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.metrics.send" id="apidoc.element.npm.metrics.send">
        function <span class="apidocSignatureSpan">npm.metrics.</span>send
        <span class="apidocSignatureSpan">(metricsFile, metricsRegistry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sendMetrics(metricsFile, metricsRegistry) {
  inMetrics = true
  var cliMetrics = JSON.parse(fs.readFileSync(metricsFile))
  npm.load({}, function (err) {
    if (err) return
    npm.registry.config.retry.retries = 0
    npm.registry.sendAnonymousCLIMetrics(metricsRegistry, cliMetrics, function (err) {
      if (err) {
        fs.writeFileSync(path.join(path.dirname(metricsFile), &apos;last-send-metrics-error.txt&apos;), err.stack)
      } else {
        fs.unlinkSync(metricsFile)
      }
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.metrics.start" id="apidoc.element.npm.metrics.start">
        function <span class="apidocSignatureSpan">npm.metrics.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startMetrics() {
  if (inMetrics) return
  // loaded on demand to avoid any recursive deps when `./metrics-launch` requires us.
  var metricsLaunch = require(&apos;./metrics-launch.js&apos;)
  npm.metricsProcess = metricsLaunch()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.metrics.stop" id="apidoc.element.npm.metrics.stop">
        function <span class="apidocSignatureSpan">npm.metrics.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopMetrics() {
  if (inMetrics) return
  if (npm.metricsProcess) npm.metricsProcess.kill(&apos;SIGKILL&apos;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.mutate_into_logical_tree" id="apidoc.module.npm.mutate_into_logical_tree">module npm.mutate_into_logical_tree</a></h1>


    <h2>
        <a href="#apidoc.element.npm.mutate_into_logical_tree.mutate_into_logical_tree" id="apidoc.element.npm.mutate_into_logical_tree.mutate_into_logical_tree">
        function <span class="apidocSignatureSpan">npm.</span>mutate_into_logical_tree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mutate_into_logical_tree = function (tree) {
  validate(&apos;O&apos;, arguments)

  validateAllPeerDeps(tree, function (tree, pkgname, version) {
    if (!tree.missingPeers) tree.missingPeers = {}
    tree.missingPeers[pkgname] = version
  })

  var flat = flattenTree(tree)

  Object.keys(flat).sort().forEach(function (flatname) {
    var node = flat[flatname]
    if (!(node.requiredBy &amp;&amp; node.requiredBy.length)) return

    if (node.parent) {
      // If a node is a cycle that never reaches the root of the logical
      // tree then we&apos;ll leave it attached to the root, or else it
      // would go missing. Further we&apos;ll note that this is the node in the
      // cycle that we picked arbitrarily to be the one attached to the root.
      // others will fall
      if (isDisconnectedCycle(node)) {
        node.cycleTop = true
      // Nor do we want to disconnect non-cyclical extraneous modules from the tree.
      } else if (node.requiredBy.length) {
        // regular deps though, we do, as we&apos;re moving them into the capable
        // hands of the modules that require them.
        node.parent.children = without(node.parent.children, node)
      }
    }

    node.requiredBy.forEach(function (parentNode) {
      parentNode.children = union(parentNode.children, [node])
    })
  })
  return tree
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.mutate_into_logical_tree.asReadInstalled" id="apidoc.element.npm.mutate_into_logical_tree.asReadInstalled">
        function <span class="apidocSignatureSpan">npm.mutate_into_logical_tree.</span>asReadInstalled
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asReadInstalled = function (tree) {
  mutateIntoLogicalTree(tree)
  return translateTree(tree)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var ver = (p.rawSpec &amp;&amp;
                 (semver.validRange(p.rawSpec) || &apos;&apos;))
      return [ name, ver, a ]
    }
  })
}

var data = mutateIntoLogicalTree.<span class="apidocCodeKeywordSpan">asReadInstalled</span>(physicalTree)

pruneNestedExtraneous(data)
filterByEnv(data)
filterByLink(data)

var unlooped = filterFound(unloop(data), args)
var lite = getLite(unlooped)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.no_progress_while_running" id="apidoc.module.npm.no_progress_while_running">module npm.no_progress_while_running</a></h1>


    <h2>
        <a href="#apidoc.element.npm.no_progress_while_running.startRunning" id="apidoc.element.npm.no_progress_while_running.startRunning">
        function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>startRunning
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startRunning = function () {
  if (progressEnabled == null) progressEnabled = log.progressEnabled
  if (progressEnabled) log.disableProgress()
  ++running
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.no_progress_while_running.stopRunning" id="apidoc.element.npm.no_progress_while_running.stopRunning">
        function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>stopRunning
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopRunning = function () {
  --running
  if (progressEnabled &amp;&amp; running === 0) log.enableProgress()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.no_progress_while_running.tillDone" id="apidoc.element.npm.no_progress_while_running.tillDone">
        function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>tillDone
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noProgressTillDone(cb) {
  startRunning()
  return function () {
    stopRunning()
    cb.apply(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.node" id="apidoc.module.npm.node">module npm.node</a></h1>


    <h2>
        <a href="#apidoc.element.npm.node.create" id="apidoc.element.npm.node.create">
        function <span class="apidocSignatureSpan">npm.node.</span>create
        <span class="apidocSignatureSpan">(node, template, isNotTop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (node, template, isNotTop) {
  if (!template) template = defaultTemplate
  Object.keys(template).forEach(function (key) {
    if (template[key] != null &amp;&amp; typeof template[key] === &apos;object&apos; &amp;&amp; !(template[key] instanceof Array)) {
      if (!node[key]) node[key] = {}
      return create(node[key], template[key], true)
    }
    if (node[key] != null) return
    node[key] = template[key]
  })
  if (!isNotTop) {
    // isLink is true for the symlink and everything inside it.
    // by contrast, isInLink is true for only the things inside a link
    if (node.isLink == null) node.isLink = isLink(node.parent)
    if (node.isInLink == null) node.isInLink = isInLink(node.parent)
    if (node.fromBundle == null) {
      node.fromBundle = false
    }
  }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Fix typo in `npm install` documentation.
([@watilde](https://github.com/watilde))

#### DEPENDENCY UPDATES

* [`7537fe1`](https://github.com/npm/npm/commit/7537fe1748c27e6f1144b279b256cd3376d5c41c)
`sorted-object@2.0.0`:
Create objects with `{}` instead of `Object.<span class="apidocCodeKeywordSpan">create</span>(null)` to make the results
strictly equal to what, say, parsed JSON would provide.
([@domenic](https://github.com/domenic))
* [`8defb0f`](https://github.com/npm/npm/commit/8defb0f7b3ebdbe15c9ef5036052c10eda7e3161)
`readable-stream@2.0.6`:
Fix sync write issue on 0.10.
([@calvinmetcalf](https://github.com/calvinmetcalf))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.node.reset" id="apidoc.element.npm.node.reset">
        function <span class="apidocSignatureSpan">npm.node.</span>reset
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function (node) {
  reset(node, new Set())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.oauth" id="apidoc.module.npm.oauth">module npm.oauth</a></h1>


    <h2>
        <a href="#apidoc.element.npm.oauth.login" id="apidoc.element.npm.oauth.login">
        function <span class="apidocSignatureSpan">npm.oauth.</span>login
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function login() {
  npm.config.set(&apos;sso-type&apos;, &apos;oauth&apos;)
  ssoAuth.login.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log.disableProgress()

try {
  var auth = require(&apos;./auth/&apos; + npm.config.get(&apos;auth-type&apos;))
} catch (e) {
  return cb(new Error(&apos;no such auth module&apos;))
}
auth.<span class="apidocCodeKeywordSpan">login</span>(creds, registry, scope, function (err, newCreds) {
  if (err) return cb(err)

  npm.config.del(&apos;_token&apos;, &apos;user&apos;) // prevent legacy pollution
  if (scope) npm.config.set(scope + &apos;:registry&apos;, registry, &apos;user&apos;)
  npm.config.setCredentialsByURI(registry, newCreds)
  npm.config.save(&apos;user&apos;, cb)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.owner" id="apidoc.module.npm.owner">module npm.owner</a></h1>


    <h2>
        <a href="#apidoc.element.npm.owner.owner" id="apidoc.element.npm.owner.owner">
        function <span class="apidocSignatureSpan">npm.</span>owner
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function owner(args, cb) {
  var action = args.shift()
  switch (action) {
    case &apos;ls&apos;: case &apos;list&apos;: return ls(args[0], cb)
    case &apos;add&apos;: return add(args[0], args[1], cb)
    case &apos;rm&apos;: case &apos;remove&apos;: return rm(args[0], args[1], cb)
    default: return unknown(action, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.owner.completion" id="apidoc.element.npm.owner.completion">
        function <span class="apidocSignatureSpan">npm.owner.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain
  if (argv.length &gt; 4) return cb()
  if (argv.length &lt;= 2) {
    var subs = [&apos;add&apos;, &apos;rm&apos;]
    if (opts.partialWord === &apos;l&apos;) subs.push(&apos;ls&apos;)
    else subs.push(&apos;ls&apos;, &apos;list&apos;)
    return cb(null, subs)
  }

  npm.commands.whoami([], true, function (er, username) {
    if (er) return cb()

    var un = encodeURIComponent(username)
    var byUser, theUser
    switch (argv[2]) {
      case &apos;ls&apos;:
        // FIXME: there used to be registry completion here, but it stopped
        // making sense somewhere around 50,000 packages on the registry
        return cb()

      case &apos;rm&apos;:
        if (argv.length &gt; 3) {
          theUser = encodeURIComponent(argv[3])
          byUser = &apos;-/by-user/&apos; + theUser + &apos;|&apos; + un
          return mapToRegistry(byUser, npm.config, function (er, uri, auth) {
            if (er) return cb(er)

            console.error(uri)
            npm.registry.get(uri, { auth: auth }, function (er, d) {
              if (er) return cb(er)
              // return the intersection
              return cb(null, d[theUser].filter(function (p) {
                // kludge for server adminery.
                return un === &apos;isaacs&apos; || d[un].indexOf(p) === -1
              }))
            })
          })
        }
        // else fallthrough
<span class="apidocCodeCommentSpan">        /* eslint no-fallthrough:0 */
</span>      case &apos;add&apos;:
        if (argv.length &gt; 3) {
          theUser = encodeURIComponent(argv[3])
          byUser = &apos;-/by-user/&apos; + theUser + &apos;|&apos; + un
          return mapToRegistry(byUser, npm.config, function (er, uri, auth) {
            if (er) return cb(er)

            console.error(uri)
            npm.registry.get(uri, { auth: auth }, function (er, d) {
              console.error(uri, er || d)
              // return mine that they&apos;re not already on.
              if (er) return cb(er)
              var mine = d[un] || []
              var theirs = d[theUser] || []
              return cb(null, mine.filter(function (p) {
                return theirs.indexOf(p) === -1
              }))
            })
          })
        }
        // just list all users who aren&apos;t me.
        return mapToRegistry(&apos;-/users&apos;, npm.config, function (er, uri, auth) {
          if (er) return cb(er)

          npm.registry.get(uri, { auth: auth }, function (er, list) {
            if (er) return cb()
            return cb(null, Object.keys(list).filter(function (n) {
              return n !== un
            }))
          })
        })

      default:
        return cb()
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.pack" id="apidoc.module.npm.pack">module npm.pack</a></h1>


    <h2>
        <a href="#apidoc.element.npm.pack.pack" id="apidoc.element.npm.pack.pack">
        function <span class="apidocSignatureSpan">npm.</span>pack
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pack(args, silent, cb) {
  const cwd = process.cwd()
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }

  if (args.length === 0) args = [&apos;.&apos;]

  BB.all(
    args.map((arg) =&gt; pack_(arg, cwd))
  ).then((tarballs) =&gt; {
    if (!silent &amp;&amp; npm.config.get(&apos;json&apos;)) {
      output(JSON.stringify(tarballs, null, 2))
    } else if (!silent) {
      tarballs.forEach(logContents)
      output(tarballs.map((f) =&gt; path.relative(cwd, f.filename)).join(&apos;\n&apos;))
    }
    return tarballs
  }).nodeify(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.completion" id="apidoc.element.npm.pack.completion">
        function <span class="apidocSignatureSpan">npm.pack.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  validate(&apos;OF&apos;, arguments)
  // install can complete to a folder with a package.json, or any package.
  // if it has a slash, then it&apos;s gotta be a folder
  // if it starts with https?://, then just give up, because it&apos;s a url
  if (/^https?:\/\//.test(opts.partialWord)) {
    // do not complete to URLs
    return cb(null, [])
  }

  if (/\//.test(opts.partialWord)) {
    // Complete fully to folder if there is exactly one match and it
    // is a folder containing a package.json file.  If that is not the
    // case we return 0 matches, which will trigger the default bash
    // complete.
    var lastSlashIdx = opts.partialWord.lastIndexOf(&apos;/&apos;)
    var partialName = opts.partialWord.slice(lastSlashIdx + 1)
    var partialPath = opts.partialWord.slice(0, lastSlashIdx)
    if (partialPath === &apos;&apos;) partialPath = &apos;/&apos;

    var annotatePackageDirMatch = function (sibling, cb) {
      var fullPath = path.join(partialPath, sibling)
      if (sibling.slice(0, partialName.length) !== partialName) {
        return cb(null, null) // not name match
      }
      fs.readdir(fullPath, function (err, contents) {
        if (err) return cb(null, { isPackage: false })

        cb(
          null,
          {
            fullPath: fullPath,
            isPackage: contents.indexOf(&apos;package.json&apos;) !== -1
          }
        )
      })
    }

    return fs.readdir(partialPath, function (err, siblings) {
      if (err) return cb(null, []) // invalid dir: no matching

      asyncMap(siblings, annotatePackageDirMatch, function (err, matches) {
        if (err) return cb(err)

        var cleaned = matches.filter(function (x) { return x !== null })
        if (cleaned.length !== 1) return cb(null, [])
        if (!cleaned[0].isPackage) return cb(null, [])

        // Success - only one match and it is a package dir
        return cb(null, [cleaned[0].fullPath])
      })
    })
  }

  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.getContents" id="apidoc.element.npm.pack.getContents">
        function <span class="apidocSignatureSpan">npm.pack.</span>getContents
        <span class="apidocSignatureSpan">(pkg, target, filename, silent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getContents(pkg, target, filename, silent) {
  const bundledWanted = new Set(
    pkg.bundleDependencies ||
    pkg.bundledDependencies ||
    []
  )
  const files = []
  const bundled = new Set()
  let totalEntries = 0
  let totalEntrySize = 0
  return tar.t({
    file: target,
    onentry (entry) {
      totalEntries++
      totalEntrySize += entry.size
      const p = entry.path
      if (p.startsWith(&apos;package/node_modules/&apos;)) {
        const name = p.match(/^package\/node_modules\/((?:@[^/]+\/)?[^/]+)/)[1]
        if (bundledWanted.has(name)) {
          bundled.add(name)
        }
      } else {
        files.push({
          path: entry.path.replace(/^package\//, &apos;&apos;),
          size: entry.size,
          mode: entry.mode
        })
      }
    },
    strip: 1
  })
    .then(() =&gt; BB.all([
      BB.fromNode((cb) =&gt; fs.stat(target, cb)),
      ssri.fromStream(fs.createReadStream(target), {
        algorithms: [&apos;sha1&apos;, &apos;sha512&apos;]
      })
    ]))
    .then(([stat, integrity]) =&gt; {
      const shasum = integrity[&apos;sha1&apos;][0].hexDigest()
      return {
        id: pkg._id,
        name: pkg.name,
        version: pkg.version,
        from: pkg._from,
        size: stat.size,
        unpackedSize: totalEntrySize,
        shasum,
        integrity: ssri.parse(integrity[&apos;sha512&apos;][0]),
        filename,
        files,
        entryCount: totalEntries,
        bundled: Array.from(bundled)
      }
    })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    const extracted = path.join(tmp, &apos;package&apos;)
    const target = path.join(tmp, &apos;package.json&apos;)
    const opts = pacoteOpts()
    return pacote.tarball.toFile(arg, target, opts)
      .then(() =&gt; pacote.extract(arg, extracted, opts))
      .then(() =&gt; readJson(path.join(extracted, &apos;package.json&apos;)))
      .then((pkg) =&gt; {
        return BB.resolve(pack.<span class="apidocCodeKeywordSpan">getContents</span>(pkg, target))
          .tap((c) =&gt; !npm.config.get(&apos;json&apos;) &amp;&amp; pack.logContents(c))
          .tap(() =&gt; upload(arg, pkg, false, target))
      })
  })
}

function upload (arg, pkg, isRetry, cached) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.logContents" id="apidoc.element.npm.pack.logContents">
        function <span class="apidocSignatureSpan">npm.pack.</span>logContents
        <span class="apidocSignatureSpan">(tarball)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function logContents(tarball) {
  log.notice(&apos;&apos;)
  log.notice(&apos;&apos;, `${npm.config.get(&apos;unicode&apos;) ? &apos; &apos; : &apos;package:&apos;} ${tarball.name}@${tarball.version}`)
  log.notice(&apos;=== Tarball Contents ===&apos;)
  if (tarball.files.length) {
    log.notice(&apos;&apos;, columnify(tarball.files.map((f) =&gt; {
      const bytes = byteSize(f.size)
      return {path: f.path, size: `${bytes.value}${bytes.unit}`}
    }), {
      include: [&apos;size&apos;, &apos;path&apos;],
      showHeaders: false
    }))
  }
  if (tarball.bundled.length) {
    log.notice(&apos;=== Bundled Dependencies ===&apos;)
    tarball.bundled.forEach((name) =&gt; log.notice(&apos;&apos;, name))
  }
  log.notice(&apos;=== Tarball Details ===&apos;)
  log.notice(&apos;&apos;, columnify([
    {name: &apos;name:&apos;, value: tarball.name},
    {name: &apos;version:&apos;, value: tarball.version},
    tarball.filename &amp;&amp; {name: &apos;filename:&apos;, value: tarball.filename},
    {name: &apos;package size:&apos;, value: byteSize(tarball.size)},
    {name: &apos;unpacked size:&apos;, value: byteSize(tarball.unpackedSize)},
    {name: &apos;shasum:&apos;, value: tarball.shasum},
    {
      name: &apos;integrity:&apos;,
      value: tarball.integrity.toString().substr(0, 20) + &apos;[...]&apos; + tarball.integrity.toString().substr(80)},
    tarball.bundled.length &amp;&amp; {name: &apos;bundled deps:&apos;, value: tarball.bundled.length},
    tarball.bundled.length &amp;&amp; {name: &apos;bundled files:&apos;, value: tarball.entryCount - tarball.files.length},
    tarball.bundled.length &amp;&amp; {name: &apos;own files:&apos;, value: tarball.files.length},
    {name: &apos;total files:&apos;, value: tarball.entryCount}
  ].filter((x) =&gt; x), {
    include: [&apos;name&apos;, &apos;value&apos;],
    showHeaders: false
  }))
  log.notice(&apos;&apos;, &apos;&apos;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).then(() =&gt; {
  return readJson(path.join(arg, &apos;package.json&apos;))
}).then((pkg) =&gt; {
  return cacache.tmp.withTmp(npm.tmp, {tmpPrefix: &apos;fromDir&apos;}, (tmpDir) =&gt; {
    const target = path.join(tmpDir, &apos;package.tgz&apos;)
    return pack.packDirectory(pkg, arg, target, null, true)
      .tap((c) =&gt; { contents = c })
      .then((c) =&gt; !npm.config.get(&apos;json&apos;) &amp;&amp; pack.<span class="apidocCodeKeywordSpan">logContents</span>(c
))
      .then(() =&gt; upload(arg, pkg, false, target))
  })
}).then(() =&gt; {
  return readJson(path.join(arg, &apos;package.json&apos;))
}).tap((pkg) =&gt; {
  return lifecycle(pkg, &apos;publish&apos;, arg)
}).tap((pkg) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.packDirectory" id="apidoc.element.npm.pack.packDirectory">
        function <span class="apidocSignatureSpan">npm.pack.</span>packDirectory
        <span class="apidocSignatureSpan">(mani, dir, target, filename, logIt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function packDirectory(mani, dir, target, filename, logIt) {
  deprCheck(mani)
  return readJson(path.join(dir, &apos;package.json&apos;)).then((pkg) =&gt; {
    return lifecycle(pkg, &apos;prepack&apos;, dir)
  }).then(() =&gt; {
    return readJson(path.join(dir, &apos;package.json&apos;))
  }).then((pkg) =&gt; {
    return cacache.tmp.withTmp(npm.tmp, {tmpPrefix: &apos;packing&apos;}, (tmp) =&gt; {
      const tmpTarget = path.join(tmp, path.basename(target))

      const tarOpt = {
        file: tmpTarget,
        cwd: dir,
        prefix: &apos;package/&apos;,
        portable: true,
        // Provide a specific date in the 1980s for the benefit of zip,
        // which is confounded by files dated at the Unix epoch 0.
        mtime: new Date(&apos;1985-10-26T08:15:00.000Z&apos;),
        gzip: true
      }

      return BB.resolve(packlist({ path: dir }))
      // NOTE: node-tar does some Magic Stuff depending on prefixes for files
      //       specifically with @ signs, so we just neutralize that one
      //       and any such future &quot;features&quot; by prepending `./`
        .then((files) =&gt; tar.create(tarOpt, files.map((f) =&gt; `./${f}`)))
        .then(() =&gt; getContents(pkg, tmpTarget, filename, logIt))
        // thread the content info through
        .tap(() =&gt; move(tmpTarget, target, {Promise: BB, fs}))
        .tap(() =&gt; lifecycle(pkg, &apos;postpack&apos;, dir))
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).then((pkg) =&gt; {
  return lifecycle(pkg, &apos;prepublishOnly&apos;, arg)
}).then(() =&gt; {
  return readJson(path.join(arg, &apos;package.json&apos;))
}).then((pkg) =&gt; {
  return cacache.tmp.withTmp(npm.tmp, {tmpPrefix: &apos;fromDir&apos;}, (tmpDir) =&gt; {
    const target = path.join(tmpDir, &apos;package.tgz&apos;)
    return pack.<span class="apidocCodeKeywordSpan">packDirectory</span>(pkg, arg, target, null, true)
      .tap((c) =&gt; { contents = c })
      .then((c) =&gt; !npm.config.get(&apos;json&apos;) &amp;&amp; pack.logContents(c))
      .then(() =&gt; upload(arg, pkg, false, target))
  })
}).then(() =&gt; {
  return readJson(path.join(arg, &apos;package.json&apos;))
}).tap((pkg) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.packGitDep" id="apidoc.element.npm.pack.packGitDep">
        function <span class="apidocSignatureSpan">npm.pack.</span>packGitDep
        <span class="apidocSignatureSpan">(manifest, dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function packGitDep(manifest, dir) {
  const stream = new PassThrough()
  readJson(path.join(dir, &apos;package.json&apos;)).then((pkg) =&gt; {
    if (pkg.scripts &amp;&amp; pkg.scripts.prepare) {
      log.verbose(&apos;prepareGitDep&apos;, `${manifest._spec}: installing devDeps and running prepare script.`)
      const cliArgs = PASSTHROUGH_OPTS.reduce((acc, opt) =&gt; {
        if (npm.config.get(opt, &apos;cli&apos;) != null) {
          acc.push(`--${opt}=${npm.config.get(opt)}`)
        }
        return acc
      }, [])
      const child = cp.spawn(process.env.NODE || process.execPath, [
        require.resolve(&apos;../bin/npm-cli.js&apos;),
        &apos;install&apos;,
        &apos;--dev&apos;,
        &apos;--prod&apos;,
        &apos;--ignore-prepublish&apos;,
        &apos;--no-progress&apos;,
        &apos;--no-save&apos;
      ].concat(cliArgs), {
        cwd: dir,
        env: process.env
      })
      let errData = []
      let errDataLen = 0
      let outData = []
      let outDataLen = 0
      child.stdout.on(&apos;data&apos;, (data) =&gt; {
        outData.push(data)
        outDataLen += data.length
        log.gauge.pulse(&apos;preparing git package&apos;)
      })
      child.stderr.on(&apos;data&apos;, (data) =&gt; {
        errData.push(data)
        errDataLen += data.length
        log.gauge.pulse(&apos;preparing git package&apos;)
      })
      return BB.fromNode((cb) =&gt; {
        child.on(&apos;error&apos;, cb)
        child.on(&apos;exit&apos;, (code, signal) =&gt; {
          if (code &gt; 0) {
            const err = new Error(`${signal}: npm exited with code ${code} while attempting to build ${manifest._requested}. Clone
 the repository manually and run &apos;npm install&apos; in it for more information.`)
            err.code = code
            err.signal = signal
            cb(err)
          } else {
            cb()
          }
        })
      }).then(() =&gt; {
        if (outDataLen &gt; 0) log.silly(&apos;prepareGitDep&apos;, &apos;1&gt;&apos;, Buffer.concat(outData, outDataLen).toString())
        if (errDataLen &gt; 0) log.silly(&apos;prepareGitDep&apos;, &apos;2&gt;&apos;, Buffer.concat(errData, errDataLen).toString())
      }, (err) =&gt; {
        if (outDataLen &gt; 0) log.error(&apos;prepareGitDep&apos;, &apos;1&gt;&apos;, Buffer.concat(outData, outDataLen).toString())
        if (errDataLen &gt; 0) log.error(&apos;prepareGitDep&apos;, &apos;2&gt;&apos;, Buffer.concat(errData, errDataLen).toString())
        throw err
      })
    }
  }).then(() =&gt; {
    return readJson(path.join(dir, &apos;package.json&apos;))
  }).then((pkg) =&gt; {
    return cacache.tmp.withTmp(npm.tmp, {
      tmpPrefix: &apos;pacote-packing&apos;
    }, (tmp) =&gt; {
      const tmpTar = path.join(tmp, &apos;package.tgz&apos;)
      return packDirectory(manifest, dir, tmpTar).then(() =&gt; {
        return pipe(fs.createReadStream(tmpTar), stream)
      })
    })
  }).catch((err) =&gt; stream.emit(&apos;error&apos;, err))
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.prepareDirectory" id="apidoc.element.npm.pack.prepareDirectory">
        function <span class="apidocSignatureSpan">npm.pack.</span>prepareDirectory
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prepareDirectory(dir) {
  return readJson(path.join(dir, &apos;package.json&apos;)).then((pkg) =&gt; {
    if (!pkg.name) {
      throw new Error(&apos;package.json requires a &quot;name&quot; field&apos;)
    }
    if (!pkg.version) {
      throw new Error(&apos;package.json requires a valid &quot;version&quot; field&apos;)
    }
    if (!pathIsInside(dir, npm.tmp)) {
      if (pkg.scripts &amp;&amp; pkg.scripts.prepublish) {
        prepublishWarning([
          &apos;As of npm@5, `prepublish` scripts are deprecated.&apos;,
          &apos;Use `prepare` for build steps and `prepublishOnly` for upload-only.&apos;,
          &apos;See the deprecation note in `npm help scripts` for more information.&apos;
        ])
      }
      if (npm.config.get(&apos;ignore-prepublish&apos;)) {
        return lifecycle(pkg, &apos;prepare&apos;, dir).then(() =&gt; pkg)
      } else {
        return lifecycle(pkg, &apos;prepublish&apos;, dir).then(() =&gt; {
          return lifecycle(pkg, &apos;prepare&apos;, dir)
        }).then(() =&gt; pkg)
      }
    }
    return pkg
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})
}

function publishFromDirectory (arg) {
// All this readJson is because any of the given scripts might modify the
// package.json in question, so we need to refresh after every step.
let contents
return pack.<span class="apidocCodeKeywordSpan">prepareDirectory</span>(arg).then(() =&gt; {
  return readJson(path.join(arg, &apos;package.json&apos;))
}).then((pkg) =&gt; {
  return lifecycle(pkg, &apos;prepublishOnly&apos;, arg)
}).then(() =&gt; {
  return readJson(path.join(arg, &apos;package.json&apos;))
}).then((pkg) =&gt; {
  return cacache.tmp.withTmp(npm.tmp, {tmpPrefix: &apos;fromDir&apos;}, (tmpDir) =&gt; {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.parse_json" id="apidoc.module.npm.parse_json">module npm.parse_json</a></h1>


    <h2>
        <a href="#apidoc.element.npm.parse_json.parse_json" id="apidoc.element.npm.parse_json.parse_json">
        function <span class="apidocSignatureSpan">npm.</span>parse_json
        <span class="apidocSignatureSpan">(content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_json = function (content) {
  return parseJsonWithErrors(stripBOM(content))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.parse_json.noExceptions" id="apidoc.element.npm.parse_json.noExceptions">
        function <span class="apidocSignatureSpan">npm.parse_json.</span>noExceptions
        <span class="apidocSignatureSpan">(content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noExceptions = function (content) {
  try {
    return parseJSON(content)
  } catch (ex) {

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function isLinkable (pkg, cb) {
var globalPackage = path.resolve(npm.globalPrefix, &apos;lib&apos;, &apos;node_modules&apos;, moduleName(pkg))
var globalPackageJson = path.resolve(globalPackage, &apos;package.json&apos;)
fs.stat(globalPackage, function (er) {
  if (er) return cb(true, true)
  fs.readFile(globalPackageJson, function (er, data) {
    var json = parseJSON.<span class="apidocCodeKeywordSpan">noExceptions</span>(data)
    cb(false, json &amp;&amp; json.version === pkg.package.version)
  })
})
}

Installer.prototype.executeActions = function (cb) {
validate(&apos;F&apos;, arguments)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.profile" id="apidoc.module.npm.profile">module npm.profile</a></h1>


    <h2>
        <a href="#apidoc.element.npm.profile.profile" id="apidoc.element.npm.profile.profile">
        function <span class="apidocSignatureSpan">npm.</span>profile
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function profileCmd(args, cb) {
  if (args.length === 0) return cb(new Error(profileCmd.usage))
  log.gauge.show(&apos;profile&apos;)
  switch (args[0]) {
    case &apos;enable-2fa&apos;:
    case &apos;enable-tfa&apos;:
    case &apos;enable2fa&apos;:
    case &apos;enabletfa&apos;:
      withCb(enable2fa(args.slice(1)), cb)
      break
    case &apos;disable-2fa&apos;:
    case &apos;disable-tfa&apos;:
    case &apos;disable2fa&apos;:
    case &apos;disabletfa&apos;:
      withCb(disable2fa(), cb)
      break
    case &apos;get&apos;:
      withCb(get(args.slice(1)), cb)
      break
    case &apos;set&apos;:
      withCb(set(args.slice(1)), cb)
      break
    default:
      cb(new Error(&apos;Unknown profile command: &apos; + args[0]))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.profile.completion" id="apidoc.element.npm.profile.completion">
        function <span class="apidocSignatureSpan">npm.profile.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain
  switch (argv[2]) {
    case &apos;enable-2fa&apos;:
    case &apos;enable-tfa&apos;:
      if (argv.length === 3) {
        return cb(null, qw`auth-and-writes auth-only`)
      } else {
        return cb(null, [])
      }
    case &apos;disable-2fa&apos;:
    case &apos;disable-tfa&apos;:
    case &apos;get&apos;:
    case &apos;set&apos;:
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + &apos; not recognized&apos;))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.prune" id="apidoc.module.npm.prune">module npm.prune</a></h1>


    <h2>
        <a href="#apidoc.element.npm.prune.prune" id="apidoc.element.npm.prune.prune">
        function <span class="apidocSignatureSpan">npm.</span>prune
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prune(args, cb) {
  var dryrun = !!npm.config.get(&apos;dry-run&apos;)
  new Pruner(&apos;.&apos;, dryrun, args).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.prune.Pruner" id="apidoc.element.npm.prune.Pruner">
        function <span class="apidocSignatureSpan">npm.prune.</span>Pruner
        <span class="apidocSignatureSpan">(where, dryrun, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pruner(where, dryrun, args) {
  Installer.call(this, where, dryrun, args)
  this.autoPrune = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.prune.completion" id="apidoc.element.npm.prune.completion">
        function <span class="apidocSignatureSpan">npm.prune.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedDeep(opts, cb) {
  var local
  var global
  var depth = npm.config.get(&apos;depth&apos;)
  var opt = { depth: depth, dev: true }

  if (npm.config.get(&apos;global&apos;)) {
    local = []
    next()
  } else {
    readInstalled(npm.prefix, opt, function (er, data) {
      local = getNames(data || {})
      next()
    })
  }

  readInstalled(npm.config.get(&apos;prefix&apos;), opt, function (er, data) {
    global = getNames(data || {})
    next()
  })

  function getNames_ (d, n) {
    if (d.realName &amp;&amp; n) {
      if (n[d.realName]) return n
      n[d.realName] = true
    }
    if (!n) n = {}
    Object.keys(d.dependencies || {}).forEach(function (dep) {
      getNames_(d.dependencies[dep], n)
    })
    return n
  }
  function getNames (d) {
    return Object.keys(getNames_(d))
  }

  function next () {
    if (!local || !global) return
    if (!npm.config.get(&apos;global&apos;)) {
      global = global.map(function (g) {
        return [g, &apos;-g&apos;]
      })
    }
    var names = local.concat(global)
    return cb(null, names)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.publish" id="apidoc.module.npm.publish">module npm.publish</a></h1>


    <h2>
        <a href="#apidoc.element.npm.publish.publish" id="apidoc.element.npm.publish.publish">
        function <span class="apidocSignatureSpan">npm.</span>publish
        <span class="apidocSignatureSpan">(args, isRetry, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(args, isRetry, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = isRetry
    isRetry = false
  }
  if (args.length === 0) args = [&apos;.&apos;]
  if (args.length !== 1) return cb(publish.usage)

  log.verbose(&apos;publish&apos;, args)

  const t = npm.config.get(&apos;tag&apos;).trim()
  if (semver.validRange(t)) {
    return cb(new Error(&apos;Tag name must not be a valid SemVer range: &apos; + t))
  }

  return publish_(args[0])
    .then((tarball) =&gt; {
      const silent = log.level === &apos;silent&apos;
      if (!silent &amp;&amp; npm.config.get(&apos;json&apos;)) {
        output(JSON.stringify(tarball, null, 2))
      } else if (!silent) {
        output(`+ ${tarball.id}`)
      }
    })
    .nodeify(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (npm.config.get(&apos;dry-run&apos;)) {
  log.verbose(&apos;publish&apos;, &apos;--dry-run mode enabled. Skipping upload.&apos;)
  return BB.resolve()
}

log.showProgress(&apos;publish:&apos; + pkg._id)
return BB.fromNode((cb) =&gt; {
  registry.<span class="apidocCodeKeywordSpan">publish</span>(registryBase, params, cb)
}).catch((err) =&gt; {
  if (
    err.code === &apos;EPUBLISHCONFLICT&apos; &amp;&amp;
    npm.config.get(&apos;force&apos;) &amp;&amp;
    !isRetry
  ) {
    log.warn(&apos;publish&apos;, &apos;Forced publish over &apos; + pkg._id)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.publish.completion" id="apidoc.element.npm.publish.completion">
        function <span class="apidocSignatureSpan">npm.publish.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // publish can complete to a folder with a package.json
  // or a tarball, or a tarball url.
  // for now, not yet implemented.
  return cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.pulse_till_done" id="apidoc.module.npm.pulse_till_done">module npm.pulse_till_done</a></h1>


    <h2>
        <a href="#apidoc.element.npm.pulse_till_done.pulse_till_done" id="apidoc.element.npm.pulse_till_done.pulse_till_done">
        function <span class="apidocSignatureSpan">npm.</span>pulse_till_done
        <span class="apidocSignatureSpan">(prefix, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pulse_till_done = function (prefix, cb) {
  validate(&apos;SF&apos;, [prefix, cb])
  if (!prefix) prefix = &apos;network&apos;
  pulseStart(prefix)
  return function () {
    pulseStop()
    cb.apply(null, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pulse_till_done.withPromise" id="apidoc.element.npm.pulse_till_done.withPromise">
        function <span class="apidocSignatureSpan">npm.pulse_till_done.</span>withPromise
        <span class="apidocSignatureSpan">(prefix, promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pulseWhile(prefix, promise) {
  if (!promise) {
    promise = prefix
    prefix = &apos;&apos;
  }
  pulseStart(prefix)
  return Bluebird.resolve(promise).finally(() =&gt; pulseStop())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const knownProfileKeys = qw`
name email ${&apos;two-factor auth&apos;} fullname homepage
freenode twitter github created updated`

function get (args) {
const tfa = &apos;two-factor auth&apos;
const conf = config()
return pulseTillDone.<span class="apidocCodeKeywordSpan">withPromise</span>(profile.get(conf)).then((info) =&gt; {
  if (!info.cidr_whitelist) delete info.cidr_whitelist
  if (conf.json) {
    output(JSON.stringify(info, null, 2))
    return
  }
  const cleaned = {}
  knownProfileKeys.forEach((k) =&gt; { cleaned[k] = info[k] || &apos;&apos; })
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.read_shrinkwrap" id="apidoc.module.npm.read_shrinkwrap">module npm.read_shrinkwrap</a></h1>


    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap.read_shrinkwrap" id="apidoc.element.npm.read_shrinkwrap.read_shrinkwrap">
        function <span class="apidocSignatureSpan">npm.</span>read_shrinkwrap
        <span class="apidocSignatureSpan">(child, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readShrinkwrap(child, next) {
  if (child.package._shrinkwrap) return process.nextTick(next)
  BB.join(
    maybeReadFile(&apos;npm-shrinkwrap.json&apos;, child),
    // Don&apos;t read non-root lockfiles
    child.isTop &amp;&amp; maybeReadFile(&apos;package-lock.json&apos;, child),
    child.isTop &amp;&amp; maybeReadFile(&apos;package.json&apos;, child),
    (shrinkwrap, lockfile, pkgJson) =&gt; {
      if (shrinkwrap &amp;&amp; lockfile) {
        log.warn(&apos;read-shrinkwrap&apos;, &apos;Ignoring package-lock.json because there is already an npm-shrinkwrap.json. Please use only
 one of the two.&apos;)
      }
      const name = shrinkwrap ? &apos;npm-shrinkwrap.json&apos; : &apos;package-lock.json&apos;
      const parsed = parsePkgLock(shrinkwrap || lockfile, name)
      if (parsed &amp;&amp; parsed.lockfileVersion !== PKGLOCK_VERSION) {
        log.warn(&apos;read-shrinkwrap&apos;, `This version of npm is compatible with lockfileVersion@${PKGLOCK_VERSION}, but ${name} was
generated for lockfileVersion@${parsed.lockfileVersion || 0}. I&apos;ll try to do my best with it!`)
      }
      child.package._shrinkwrap = parsed
    }
  ).then(() =&gt; next(), next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap._isDiff" id="apidoc.element.npm.read_shrinkwrap._isDiff">
        function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>_isDiff
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDiff(str) {
  return str.match(OURS_RE) &amp;&amp; str.match(THEIRS_RE) &amp;&amp; str.match(END_RE)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap._parsePkgLock" id="apidoc.element.npm.read_shrinkwrap._parsePkgLock">
        function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>_parsePkgLock
        <span class="apidocSignatureSpan">(str, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parsePkgLock(str, filename) {
  if (!str) { return null }
  try {
    return parseJSON(str)
  } catch (e) {
    if (isDiff(str)) {
      log.warn(&apos;conflict&apos;, `A git conflict was detected in ${filename}. Attempting to auto-resolve.`)
      log.warn(&apos;conflict&apos;, &apos;To make this happen automatically on git rebase/merge, consider using the npm-merge-driver:&apos;)
      log.warn(&apos;conflict&apos;, &apos;$ npx npm-merge-driver install -g&apos;)
      const pieces = str.split(/[\n\r]+/g).reduce((acc, line) =&gt; {
        if (line.match(PARENT_RE)) acc.state = &apos;parent&apos;
        else if (line.match(OURS_RE)) acc.state = &apos;ours&apos;
        else if (line.match(THEIRS_RE)) acc.state = &apos;theirs&apos;
        else if (line.match(END_RE)) acc.state = &apos;top&apos;
        else {
          if (acc.state === &apos;top&apos; || acc.state === &apos;ours&apos;) acc.ours += line
          if (acc.state === &apos;top&apos; || acc.state === &apos;theirs&apos;) acc.theirs += line
          if (acc.state === &apos;top&apos; || acc.state === &apos;parent&apos;) acc.parent += line
        }
        return acc
      }, {
        state: &apos;top&apos;,
        ours: &apos;&apos;,
        theirs: &apos;&apos;,
        parent: &apos;&apos;
      })
      try {
        const ours = parseJSON(pieces.ours)
        const theirs = parseJSON(pieces.theirs)
        return reconcileLockfiles(ours, theirs)
      } catch (_e) {
        log.error(&apos;conflict&apos;, `Automatic conflict resolution failed. Please manually resolve conflicts in ${filename} and try again
.`)
        log.silly(&apos;conflict&apos;, `Error during resolution: ${_e}`)
        throw e
      }
    } else {
      throw e
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap.andInflate" id="apidoc.element.npm.read_shrinkwrap.andInflate">
        function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>andInflate
        <span class="apidocSignatureSpan">(child, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">andInflate = function (child, next) {
  readShrinkwrap(child, iferr(next, function () {
    if (child.package._shrinkwrap) {
      return inflateShrinkwrap(child, child.package._shrinkwrap || {}, next)
    } else {
      return next()
    }
  }))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.idealTree.warnings = []
cb()
}

Installer.prototype.loadShrinkwrap = function (cb) {
validate(&apos;F&apos;, arguments)
log.silly(&apos;install&apos;, &apos;loadShrinkwrap&apos;)
readShrinkwrap.<span class="apidocCodeKeywordSpan">andInflate</span>(this.idealTree, iferr(cb, () =&gt; {
  computeMetadata(this.idealTree)
  cb()
}))
}

Installer.prototype.getInstalledModules = function () {
return this.differences.filter(function (action) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.read_user_info" id="apidoc.module.npm.read_user_info">module npm.read_user_info</a></h1>


    <h2>
        <a href="#apidoc.element.npm.read_user_info.email" id="apidoc.element.npm.read_user_info.email">
        function <span class="apidocSignatureSpan">npm.read_user_info.</span>email
        <span class="apidocSignatureSpan">(msg, email, opts, isRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readEmail(msg, email, opts, isRetry) {
  if (!msg) msg = &apos;email (this IS public): &apos;
  if (isRetry &amp;&amp; email) {
    const error = userValidate.email(email)
    if (error) {
      opts.log &amp;&amp; opts.log.warn(error.message)
    } else {
      return email.trim()
    }
  }

  return read({prompt: msg, default: email || &apos;&apos;})
    .then((username) =&gt; readEmail(msg, username, opts, true))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const loginPrompter = (creds) =&gt; {
  const opts = { log: log }
  return read.username(&apos;Username:&apos;, creds.username, opts).then((u) =&gt; {
    creds.username = u
    return read.password(&apos;Password:&apos;, creds.password)
  }).then((p) =&gt; {
    creds.password = p
    return read.<span class="apidocCodeKeywordSpan">email</span>(&apos;Email: (this IS public) &apos;, creds.email, opts)
  }).then((e) =&gt; {
    creds.email = e
    return creds
  })
}

module.exports.login = (creds, registry, scope, cb) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_user_info.otp" id="apidoc.element.npm.read_user_info.otp">
        function <span class="apidocSignatureSpan">npm.read_user_info.</span>otp
        <span class="apidocSignatureSpan">(msg, otp, isRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readOTP(msg, otp, isRetry) {
  if (!msg) {
    msg = [
      &apos;There was an error while trying authentication due to OTP (One-Time-Password).&apos;,
      &apos;The One-Time-Password is generated via applications like Authy or&apos;,
      &apos;Google Authenticator, for more information see:&apos;,
      &apos;https://docs.npmjs.com/getting-started/using-two-factor-authentication&apos;,
      &apos;Enter OTP: &apos;
    ].join(&apos;\n&apos;)
  }
  if (isRetry &amp;&amp; otp &amp;&amp; /^[\d ]+$|^[A-Fa-f0-9]{64,64}$/.test(otp)) return otp.replace(/\s+/g, &apos;&apos;)

  return read({prompt: msg, default: otp || &apos;&apos;})
    .then((otp) =&gt; readOTP(msg, otp, true))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// FIXME: Work around to not clear everything other than what we&apos;re setting
return pulseTillDone.withPromise(profile.get(conf).then((user) =&gt; {
  const newUser = {}
  writableProfileKeys.forEach((k) =&gt; { newUser[k] = user[k] })
  newUser[prop] = value
  return profile.set(newUser, conf).catch((err) =&gt; {
    if (err.code !== &apos;EOTP&apos;) throw err
    return readUserInfo.<span class="apidocCodeKeywordSpan">otp</span>(&apos;Enter OTP:  &apos;).then((otp) =&gt; {
      conf.auth.otp = otp
      return profile.set(newUser, conf)
    })
  }).then((result) =&gt; {
    if (conf.json) {
      output(JSON.stringify({[prop]: result[prop]}, null, 2))
    } else if (conf.parseable) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_user_info.password" id="apidoc.element.npm.read_user_info.password">
        function <span class="apidocSignatureSpan">npm.read_user_info.</span>password
        <span class="apidocSignatureSpan">(msg, password, isRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readPassword(msg, password, isRetry) {
  if (!msg) msg = &apos;npm password: &apos;
  if (isRetry &amp;&amp; password) return password

  return read({prompt: msg, silent: true, default: password || &apos;&apos;})
    .then((password) =&gt; readPassword(msg, password, true))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &apos;Do not include your current or new passwords on the command line.&apos;))
}
if (writableProfileKeys.indexOf(prop) === -1) {
  return Promise.reject(Error(`&quot;${prop}&quot; is not a property we can set. Valid properties are: ` + writableProfileKeys.join
(&apos;, &apos;)))
}
return Bluebird.try(() =&gt; {
  if (prop === &apos;password&apos;) {
    return readUserInfo.<span class="apidocCodeKeywordSpan">password</span>(&apos;Current password: &apos;).then((current) =&gt; {
      return readPasswords().then((newpassword) =&gt; {
        value = {old: current, new: newpassword}
      })
    })
  } else if (prop === &apos;email&apos;) {
    return readUserInfo.password(&apos;Password: &apos;).then((current) =&gt; {
      return {password: current, email: value}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_user_info.username" id="apidoc.element.npm.read_user_info.username">
        function <span class="apidocSignatureSpan">npm.read_user_info.</span>username
        <span class="apidocSignatureSpan">(msg, username, opts, isRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readUsername(msg, username, opts, isRetry) {
  if (!msg) msg = &apos;npm username: &apos;
  if (isRetry &amp;&amp; username) {
    const error = userValidate.username(username)
    if (error) {
      opts.log &amp;&amp; opts.log.warn(error.message)
    } else {
      return Promise.resolve(username.trim())
    }
  }

  return read({prompt: msg, default: username || &apos;&apos;})
    .then((username) =&gt; readUsername(msg, username, opts, true))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

const openerPromise = (url) =&gt; new Promise((resolve, reject) =&gt; {
openUrl(url, &apos;to complete your login please visit&apos;, (er) =&gt; er ? reject(er) : resolve())
})

const loginPrompter = (creds) =&gt; {
const opts = { log: log }
return read.<span class="apidocCodeKeywordSpan">username</span>(&apos;Username:&apos;, creds.username, opts).then((u) =&gt; {
  creds.username = u
  return read.password(&apos;Password:&apos;, creds.password)
}).then((p) =&gt; {
  creds.password = p
  return read.email(&apos;Email: (this IS public) &apos;, creds.email, opts)
}).then((e) =&gt; {
  creds.email = e
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.rebuild" id="apidoc.module.npm.rebuild">module npm.rebuild</a></h1>


    <h2>
        <a href="#apidoc.element.npm.rebuild.rebuild" id="apidoc.element.npm.rebuild.rebuild">
        function <span class="apidocSignatureSpan">npm.</span>rebuild
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rebuild(args, cb) {
  var opt = { depth: npm.config.get(&apos;depth&apos;), dev: true }
  readInstalled(npm.prefix, opt, function (er, data) {
    log.info(&apos;readInstalled&apos;, typeof data)
    if (er) return cb(er)
    var set = filter(data, args)
    var folders = Object.keys(set).filter(function (f) {
      return f !== npm.prefix
    })
    if (!folders.length) return cb()
    log.silly(&apos;rebuild set&apos;, folders)
    cleanBuild(folders, set, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .join(&apos;/node_modules/&apos;)
    .replace(/(\/node_modules)+/, &apos;/node_modules&apos;)
  var f = path.resolve(npm.dir, p)
  fs.lstat(f, function (er) {
    if (er) return cb(er)
    editor(f, { editor: e }, noProgressTillDone(function (er) {
      if (er) return cb(er)
      npm.commands.<span class="apidocCodeKeywordSpan">rebuild</span>(args, cb)
    }))
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.rebuild.completion" id="apidoc.element.npm.rebuild.completion">
        function <span class="apidocSignatureSpan">npm.rebuild.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedDeep(opts, cb) {
  var local
  var global
  var depth = npm.config.get(&apos;depth&apos;)
  var opt = { depth: depth, dev: true }

  if (npm.config.get(&apos;global&apos;)) {
    local = []
    next()
  } else {
    readInstalled(npm.prefix, opt, function (er, data) {
      local = getNames(data || {})
      next()
    })
  }

  readInstalled(npm.config.get(&apos;prefix&apos;), opt, function (er, data) {
    global = getNames(data || {})
    next()
  })

  function getNames_ (d, n) {
    if (d.realName &amp;&amp; n) {
      if (n[d.realName]) return n
      n[d.realName] = true
    }
    if (!n) n = {}
    Object.keys(d.dependencies || {}).forEach(function (dep) {
      getNames_(d.dependencies[dep], n)
    })
    return n
  }
  function getNames (d) {
    return Object.keys(getNames_(d))
  }

  function next () {
    if (!local || !global) return
    if (!npm.config.get(&apos;global&apos;)) {
      global = global.map(function (g) {
        return [g, &apos;-g&apos;]
      })
    }
    var names = local.concat(global)
    return cb(null, names)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.repo" id="apidoc.module.npm.repo">module npm.repo</a></h1>


    <h2>
        <a href="#apidoc.element.npm.repo.repo" id="apidoc.element.npm.repo.repo">
        function <span class="apidocSignatureSpan">npm.</span>repo
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repo(args, cb) {
  var n = args.length ? args[0] : &apos;.&apos;
  fetchPackageMetadata(n, &apos;.&apos;, {fullMetadata: true}, function (er, d) {
    if (er) return cb(er)
    getUrlAndOpen(d, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.repo.completion" id="apidoc.element.npm.repo.completion">
        function <span class="apidocSignatureSpan">npm.repo.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.restart" id="apidoc.module.npm.restart">module npm.restart</a></h1>


    <h2>
        <a href="#apidoc.element.npm.restart.restart" id="apidoc.element.npm.restart.restart">
        function <span class="apidocSignatureSpan">npm.</span>restart
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands[&apos;run-script&apos;]([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.restart.completion" id="apidoc.element.npm.restart.completion">
        function <span class="apidocSignatureSpan">npm.restart.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  installedShallow(opts, function (d) {
    return d.scripts &amp;&amp; d.scripts[stage]
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.run_script" id="apidoc.module.npm.run_script">module npm.run_script</a></h1>


    <h2>
        <a href="#apidoc.element.npm.run_script.run_script" id="apidoc.element.npm.run_script.run_script">
        function <span class="apidocSignatureSpan">npm.</span>run_script
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runScript(args, cb) {
  if (!args.length) return list(cb)

  var pkgdir = npm.localPrefix
  var cmd = args.shift()

  readJson(path.resolve(pkgdir, &apos;package.json&apos;), function (er, d) {
    if (er) return cb(er)
    run(d, pkgdir, cmd, args, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.run_script.completion" id="apidoc.element.npm.run_script.completion">
        function <span class="apidocSignatureSpan">npm.run_script.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // see if there&apos;s already a package specified.
  var argv = opts.conf.argv.remain

  if (argv.length &gt;= 4) return cb()

  if (argv.length === 3) {
    // either specified a script locally, in which case, done,
    // or a package, in which case, complete against its scripts
    var json = path.join(npm.localPrefix, &apos;package.json&apos;)
    return readJson(json, function (er, d) {
      if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
      if (er) d = {}
      var scripts = Object.keys(d.scripts || {})
      console.error(&apos;local scripts&apos;, scripts)
      if (scripts.indexOf(argv[2]) !== -1) return cb()
      // ok, try to find out which package it was, then
      var pref = npm.config.get(&apos;global&apos;) ? npm.config.get(&apos;prefix&apos;)
        : npm.localPrefix
      var pkgDir = path.resolve(pref, &apos;node_modules&apos;, argv[2], &apos;package.json&apos;)
      readJson(pkgDir, function (er, d) {
        if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
        if (er) d = {}
        var scripts = Object.keys(d.scripts || {})
        return cb(null, scripts)
      })
    })
  }

  readJson(path.join(npm.localPrefix, &apos;package.json&apos;), function (er, d) {
    if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
    d = d || {}
    cb(null, Object.keys(d.scripts || {}))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.saml" id="apidoc.module.npm.saml">module npm.saml</a></h1>


    <h2>
        <a href="#apidoc.element.npm.saml.login" id="apidoc.element.npm.saml.login">
        function <span class="apidocSignatureSpan">npm.saml.</span>login
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function login() {
  npm.config.set(&apos;sso-type&apos;, &apos;saml&apos;)
  ssoAuth.login.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log.disableProgress()

try {
  var auth = require(&apos;./auth/&apos; + npm.config.get(&apos;auth-type&apos;))
} catch (e) {
  return cb(new Error(&apos;no such auth module&apos;))
}
auth.<span class="apidocCodeKeywordSpan">login</span>(creds, registry, scope, function (err, newCreds) {
  if (err) return cb(err)

  npm.config.del(&apos;_token&apos;, &apos;user&apos;) // prevent legacy pollution
  if (scope) npm.config.set(scope + &apos;:registry&apos;, registry, &apos;user&apos;)
  npm.config.setCredentialsByURI(registry, newCreds)
  npm.config.save(&apos;user&apos;, cb)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.save" id="apidoc.module.npm.save">module npm.save</a></h1>


    <h2>
        <a href="#apidoc.element.npm.save.getSaveType" id="apidoc.element.npm.save.getSaveType">
        function <span class="apidocSignatureSpan">npm.save.</span>getSaveType
        <span class="apidocSignatureSpan">(tree, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSaveType = function (tree, arg) {
  if (arguments.length) validate(&apos;OO&apos;, arguments)
  var globalInstall = npm.config.get(&apos;global&apos;)
  var noSaveFlags = !npm.config.get(&apos;save&apos;) &amp;&amp;
                    !npm.config.get(&apos;save-dev&apos;) &amp;&amp;
                    !npm.config.get(&apos;save-prod&apos;) &amp;&amp;
                    !npm.config.get(&apos;save-optional&apos;)
  if (globalInstall || noSaveFlags) return null

  if (npm.config.get(&apos;save-optional&apos;)) {
    return &apos;optionalDependencies&apos;
  } else if (npm.config.get(&apos;save-dev&apos;)) {
    return &apos;devDependencies&apos;
  } else if (npm.config.get(&apos;save-prod&apos;)) {
    return &apos;dependencies&apos;
  } else {
    if (arg) {
      var name = moduleName(arg)
      if (tree.package.optionalDependencies[name]) {
        return &apos;optionalDependencies&apos;
      } else if (tree.package.devDependencies[name]) {
        return &apos;devDependencies&apos;
      }
    }
    return &apos;dependencies&apos;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.save.saveRequested" id="apidoc.element.npm.save.saveRequested">
        function <span class="apidocSignatureSpan">npm.save.</span>saveRequested
        <span class="apidocSignatureSpan">(tree, andReturn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveRequested = function (tree, andReturn) {
  validate(&apos;OF&apos;, arguments)
  savePackageJson(tree, andWarnErrors(andSaveShrinkwrap(tree, andReturn)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.save.saveShrinkwrap" id="apidoc.element.npm.save.saveShrinkwrap">
        function <span class="apidocSignatureSpan">npm.save.</span>saveShrinkwrap
        <span class="apidocSignatureSpan">(tree, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function saveShrinkwrap(tree, next) {
  validate(&apos;OF&apos;, arguments)
  if (!npm.config.get(&apos;shrinkwrap&apos;) || !npm.config.get(&apos;package-lock&apos;)) {
    return next()
  }
  require(&apos;../shrinkwrap.js&apos;).createShrinkwrap(tree, {silent: false}, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.save_stack" id="apidoc.module.npm.save_stack">module npm.save_stack</a></h1>


    <h2>
        <a href="#apidoc.element.npm.save_stack.save_stack" id="apidoc.element.npm.save_stack.save_stack">
        function <span class="apidocSignatureSpan">npm.</span>save_stack
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SaveStack(fn) {
  Error.call(this)
  Error.captureStackTrace(this, fn || SaveStack)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.save_stack.super_" id="apidoc.element.npm.save_stack.super_">
        function <span class="apidocSignatureSpan">npm.save_stack.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.save_stack.prototype" id="apidoc.module.npm.save_stack.prototype">module npm.save_stack.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.npm.save_stack.prototype.completeWith" id="apidoc.element.npm.save_stack.prototype.completeWith">
        function <span class="apidocSignatureSpan">npm.save_stack.prototype.</span>completeWith
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completeWith = function (er) {
  this[&apos;__&apos; + &apos;proto&apos; + &apos;__&apos;] = er
  this.stack = this.stack + &apos;\n\n&apos; + er.stack
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.search" id="apidoc.module.npm.search">module npm.search</a></h1>


    <h2>
        <a href="#apidoc.element.npm.search.search" id="apidoc.element.npm.search.search">
        function <span class="apidocSignatureSpan">npm.</span>search
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function search(args, cb) {
  var searchOpts = {
    description: npm.config.get(&apos;description&apos;),
    exclude: prepareExcludes(npm.config.get(&apos;searchexclude&apos;)),
    include: prepareIncludes(args, npm.config.get(&apos;searchopts&apos;)),
    limit: npm.config.get(&apos;searchlimit&apos;),
    log: log,
    staleness: npm.config.get(&apos;searchstaleness&apos;),
    unicode: npm.config.get(&apos;unicode&apos;)
  }

  if (searchOpts.include.length === 0) {
    return cb(new Error(&apos;search must be called with arguments&apos;))
  }

  // Used later to figure out whether we had any packages go out
  var anyOutput = false

  var entriesStream = ms.through.obj()

  var esearchWritten = false
  esearch(searchOpts).on(&apos;data&apos;, function (pkg) {
    entriesStream.write(pkg)
    !esearchWritten &amp;&amp; (esearchWritten = true)
  }).on(&apos;error&apos;, function (e) {
    if (esearchWritten) {
      // If esearch errored after already starting output, we can&apos;t fall back.
      return entriesStream.emit(&apos;error&apos;, e)
    }
    log.warn(&apos;search&apos;, &apos;fast search endpoint errored. Using old search.&apos;)
    allPackageSearch(searchOpts).on(&apos;data&apos;, function (pkg) {
      entriesStream.write(pkg)
    }).on(&apos;error&apos;, function (e) {
      entriesStream.emit(&apos;error&apos;, e)
    }).on(&apos;end&apos;, function () {
      entriesStream.end()
    })
  }).on(&apos;end&apos;, function () {
    entriesStream.end()
  })

  // Grab a configured output stream that will spit out packages in the
  // desired format.
  var outputStream = formatPackageStream({
    args: args, // --searchinclude options are not highlighted
    long: npm.config.get(&apos;long&apos;),
    description: npm.config.get(&apos;description&apos;),
    json: npm.config.get(&apos;json&apos;),
    parseable: npm.config.get(&apos;parseable&apos;),
    color: npm.color
  })
  outputStream.on(&apos;data&apos;, function (chunk) {
    if (!anyOutput) { anyOutput = true }
    output(chunk.toString(&apos;utf8&apos;))
  })

  log.silly(&apos;search&apos;, &apos;searching packages&apos;)
  ms.pipe(entriesStream, outputStream, function (er) {
    if (er) return cb(er)
    if (!anyOutput &amp;&amp; !npm.config.get(&apos;json&apos;) &amp;&amp; !npm.config.get(&apos;parseable&apos;)) {
      output(&apos;No matches found for &apos; + (args.map(JSON.stringify).join(&apos; &apos;)))
    }
    log.silly(&apos;search&apos;, &apos;search completed&apos;)
    log.clearProgress()
    cb(null, {})
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.search.completion" id="apidoc.element.npm.search.completion">
        function <span class="apidocSignatureSpan">npm.search.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  cb(null, [])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.shrinkwrap" id="apidoc.module.npm.shrinkwrap">module npm.shrinkwrap</a></h1>


    <h2>
        <a href="#apidoc.element.npm.shrinkwrap.shrinkwrap" id="apidoc.element.npm.shrinkwrap.shrinkwrap">
        function <span class="apidocSignatureSpan">npm.</span>shrinkwrap
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shrinkwrap(args, silent, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }

  if (args.length) {
    log.warn(&apos;shrinkwrap&apos;, &quot;doesn&apos;t take positional args&quot;)
  }

  move(
    path.resolve(npm.prefix, PKGLOCK),
    path.resolve(npm.prefix, SHRINKWRAP),
    { Promise: BB }
  ).then(() =&gt; {
    log.notice(&apos;&apos;, `${PKGLOCK} has been renamed to ${SHRINKWRAP}. ${SHRINKWRAP} will be used for future installations.`)
    return readFile(path.resolve(npm.prefix, SHRINKWRAP)).then((d) =&gt; {
      return JSON.parse(d)
    })
  }, (err) =&gt; {
    if (err.code !== &apos;ENOENT&apos;) {
      throw err
    } else {
      return readPackageTree(npm.localPrefix).then(
        id.computeMetadata
      ).then((tree) =&gt; {
        return BB.fromNode((cb) =&gt; {
          createShrinkwrap(tree, {
            silent,
            defaultFile: SHRINKWRAP
          }, cb)
        })
      })
    }
  }).then((data) =&gt; cb(null, data), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.shrinkwrap.createShrinkwrap" id="apidoc.element.npm.shrinkwrap.createShrinkwrap">
        function <span class="apidocSignatureSpan">npm.shrinkwrap.</span>createShrinkwrap
        <span class="apidocSignatureSpan">(tree, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createShrinkwrap(tree, opts, cb) {
  opts = opts || {}
  lifecycle(tree.package, &apos;preshrinkwrap&apos;, tree.path, function () {
    const pkginfo = treeToShrinkwrap(tree)
    chain([
      [lifecycle, tree.package, &apos;shrinkwrap&apos;, tree.path],
      [shrinkwrap_, tree.path, pkginfo, opts],
      [lifecycle, tree.package, &apos;postshrinkwrap&apos;, tree.path]
    ], iferr(cb, function (data) {
      cb(null, pkginfo)
    }))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.saveShrinkwrap = saveShrinkwrap

function saveShrinkwrap (tree, next) {
validate(&apos;OF&apos;, arguments)
if (!npm.config.get(&apos;shrinkwrap&apos;) || !npm.config.get(&apos;package-lock&apos;)) {
  return next()
}
require(&apos;../shrinkwrap.js&apos;).<span class="apidocCodeKeywordSpan">createShrinkwrap</span>(tree, {silent: false}, next)
}

function savePackageJson (tree, next) {
validate(&apos;OF&apos;, arguments)
var saveBundle = npm.config.get(&apos;save-bundle&apos;)

// each item in the tree is a top-level thing that should be saved
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.shrinkwrap.treeToShrinkwrap" id="apidoc.element.npm.shrinkwrap.treeToShrinkwrap">
        function <span class="apidocSignatureSpan">npm.shrinkwrap.</span>treeToShrinkwrap
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function treeToShrinkwrap(tree) {
  validate(&apos;O&apos;, arguments)
  var pkginfo = {}
  if (tree.package.name) pkginfo.name = tree.package.name
  if (tree.package.version) pkginfo.version = tree.package.version
  if (tree.children.length) {
    pkginfo.requires = true
    shrinkwrapDeps(pkginfo.dependencies = {}, tree, tree)
  }
  return pkginfo
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.sso" id="apidoc.module.npm.sso">module npm.sso</a></h1>


    <h2>
        <a href="#apidoc.element.npm.sso.login" id="apidoc.element.npm.sso.login">
        function <span class="apidocSignatureSpan">npm.sso.</span>login
        <span class="apidocSignatureSpan">(creds, registry, scope, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function login(creds, registry, scope, cb) {
  var ssoType = npm.config.get(&apos;sso-type&apos;)
  if (!ssoType) { return cb(new Error(&apos;Missing option: sso-type&apos;)) }

  var params = {
    // We&apos;re reusing the legacy login endpoint, so we need some dummy
    // stuff here to pass validation. They&apos;re never used.
    auth: {
      username: &apos;npm_&apos; + ssoType + &apos;_auth_dummy_user&apos;,
      password: &apos;placeholder&apos;,
      email: &apos;support@npmjs.com&apos;,
      authType: ssoType
    }
  }
  npm.registry.adduser(registry, params, function (er, doc) {
    if (er) return cb(er)
    if (!doc || !doc.token) return cb(new Error(&apos;no SSO token returned&apos;))
    if (!doc.sso) return cb(new Error(&apos;no SSO URL returned by services&apos;))

    openUrl(doc.sso, &apos;to complete your login please visit&apos;, function () {
      pollForSession(registry, doc.token, function (err, username) {
        if (err) return cb(err)

        log.info(&apos;adduser&apos;, &apos;Authorized user %s&apos;, username)
        var scopeMessage = scope ? &apos; to scope &apos; + scope : &apos;&apos;
        output(&apos;Logged in as %s%s on %s.&apos;, username, scopeMessage, registry)

        cb(null, { token: doc.token })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log.disableProgress()

try {
  var auth = require(&apos;./auth/&apos; + npm.config.get(&apos;auth-type&apos;))
} catch (e) {
  return cb(new Error(&apos;no such auth module&apos;))
}
auth.<span class="apidocCodeKeywordSpan">login</span>(creds, registry, scope, function (err, newCreds) {
  if (err) return cb(err)

  npm.config.del(&apos;_token&apos;, &apos;user&apos;) // prevent legacy pollution
  if (scope) npm.config.set(scope + &apos;:registry&apos;, registry, &apos;user&apos;)
  npm.config.setCredentialsByURI(registry, newCreds)
  npm.config.save(&apos;user&apos;, cb)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.star" id="apidoc.module.npm.star">module npm.star</a></h1>


    <h2>
        <a href="#apidoc.element.npm.star.star" id="apidoc.element.npm.star.star">
        function <span class="apidocSignatureSpan">npm.</span>star
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function star(args, cb) {
  if (!args.length) return cb(star.usage)
  var s = npm.config.get(&apos;unicode&apos;) ? &apos;\u2605 &apos; : &apos;(*)&apos;
  var u = npm.config.get(&apos;unicode&apos;) ? &apos;\u2606 &apos; : &apos;( )&apos;
  var using = !(npm.command.match(/^un/))
  if (!using) s = u
  asyncMap(args, function (pkg, cb) {
    mapToRegistry(pkg, npm.config, function (er, uri, auth) {
      if (er) return cb(er)

      var params = {
        starred: using,
        auth: auth
      }
      npm.registry.star(uri, params, function (er, data, raw, req) {
        if (!er) {
          output(s + &apos; &apos; + pkg)
          log.verbose(&apos;star&apos;, data)
        }
        cb(er, data, raw, req)
      })
    })
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
mapToRegistry(pkg, npm.config, function (er, uri, auth) {
  if (er) return cb(er)

  var params = {
    starred: using,
    auth: auth
  }
  npm.registry.<span class="apidocCodeKeywordSpan">star</span>(uri, params, function (er, data, raw, req) {
    if (!er) {
      output(s + &apos; &apos; + pkg)
      log.verbose(&apos;star&apos;, data)
    }
    cb(er, data, raw, req)
  })
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.star.completion" id="apidoc.element.npm.star.completion">
        function <span class="apidocSignatureSpan">npm.star.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.start" id="apidoc.module.npm.start">module npm.start</a></h1>


    <h2>
        <a href="#apidoc.element.npm.start.start" id="apidoc.element.npm.start.start">
        function <span class="apidocSignatureSpan">npm.</span>start
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands[&apos;run-script&apos;]([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.start.completion" id="apidoc.element.npm.start.completion">
        function <span class="apidocSignatureSpan">npm.start.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  installedShallow(opts, function (d) {
    return d.scripts &amp;&amp; d.scripts[stage]
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.stop" id="apidoc.module.npm.stop">module npm.stop</a></h1>


    <h2>
        <a href="#apidoc.element.npm.stop.stop" id="apidoc.element.npm.stop.stop">
        function <span class="apidocSignatureSpan">npm.</span>stop
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands[&apos;run-script&apos;]([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.stop.completion" id="apidoc.element.npm.stop.completion">
        function <span class="apidocSignatureSpan">npm.stop.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  installedShallow(opts, function (d) {
    return d.scripts &amp;&amp; d.scripts[stage]
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.team" id="apidoc.module.npm.team">module npm.team</a></h1>


    <h2>
        <a href="#apidoc.element.npm.team.team" id="apidoc.element.npm.team.team">
        function <span class="apidocSignatureSpan">npm.</span>team
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function team(args, cb) {
  // Entities are in the format &lt;scope&gt;:&lt;team&gt;
  var cmd = args.shift()
  var entity = (args.shift() || &apos;&apos;).split(&apos;:&apos;)
  return mapToRegistry(&apos;/&apos;, npm.config, function (err, uri, auth) {
    if (err) { return cb(err) }
    try {
      return npm.registry.team(cmd, uri, {
        auth: auth,
        scope: entity[0].replace(/^@/, &apos;&apos;), // &apos;@&apos; prefix on scope is optional.
        team: entity[1],
        user: args.shift()
      }, function (err, data) {
        !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))
        cb(err, data)
      })
    } catch (e) {
      cb(e.message + &apos;\n\nUsage:\n&apos; + team.usage)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function team (args, cb) {
// Entities are in the format &lt;scope&gt;:&lt;team&gt;
var cmd = args.shift()
var entity = (args.shift() || &apos;&apos;).split(&apos;:&apos;)
return mapToRegistry(&apos;/&apos;, npm.config, function (err, uri, auth) {
  if (err) { return cb(err) }
  try {
    return npm.registry.<span class="apidocCodeKeywordSpan">team</span>(cmd, uri, {
      auth: auth,
      scope: entity[0].replace(/^@/, &apos;&apos;), // &apos;@&apos; prefix on scope is optional.
      team: entity[1],
      user: args.shift()
    }, function (err, data) {
      !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))
      cb(err, data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.team.completion" id="apidoc.element.npm.team.completion">
        function <span class="apidocSignatureSpan">npm.team.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain
  if (argv.length === 2) {
    return cb(null, team.subcommands)
  }
  switch (argv[2]) {
    case &apos;ls&apos;:
    case &apos;create&apos;:
    case &apos;destroy&apos;:
    case &apos;add&apos;:
    case &apos;rm&apos;:
    case &apos;edit&apos;:
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + &apos; not recognized&apos;))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.token" id="apidoc.module.npm.token">module npm.token</a></h1>


    <h2>
        <a href="#apidoc.element.npm.token.token" id="apidoc.element.npm.token.token">
        function <span class="apidocSignatureSpan">npm.</span>token
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(args, cb) {
  log.gauge.show(&apos;token&apos;)
  if (args.length === 0) return withCb(list([]), cb)
  switch (args[0]) {
    case &apos;list&apos;:
    case &apos;ls&apos;:
      withCb(list(), cb)
      break
    case &apos;delete&apos;:
    case &apos;revoke&apos;:
    case &apos;remove&apos;:
    case &apos;rm&apos;:
      withCb(rm(args.slice(1)), cb)
      break
    case &apos;create&apos;:
      withCb(create(args.slice(1)), cb)
      break
    default:
      cb(new Error(&apos;Unknown profile command: &apos; + args[0]))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.token._validateCIDRList" id="apidoc.element.npm.token._validateCIDRList">
        function <span class="apidocSignatureSpan">npm.token.</span>_validateCIDRList
        <span class="apidocSignatureSpan">(cidrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateCIDRList(cidrs) {
  const maybeList = cidrs ? (Array.isArray(cidrs) ? cidrs : [cidrs]) : []
  const list = maybeList.length === 1 ? maybeList[0].split(/,\s*/) : maybeList
  list.forEach(validateCIDR)
  return list
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.token.completion" id="apidoc.element.npm.token.completion">
        function <span class="apidocSignatureSpan">npm.token.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain

  switch (argv[2]) {
    case &apos;list&apos;:
    case &apos;revoke&apos;:
    case &apos;create&apos;:
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + &apos; not recognized&apos;))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.umask" id="apidoc.module.npm.umask">module npm.umask</a></h1>


    <h2>
        <a href="#apidoc.element.npm.umask.fromString" id="apidoc.element.npm.umask.fromString">
        function <span class="apidocSignatureSpan">npm.umask.</span>fromString
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromString = function (val) {
  _fromString(val, function (err, result) {
    if (err) {
      npmlog.warn(&apos;invalid umask&apos;, err.message)
    }
    val = result
  })

  return val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    val = &apos;&apos;
  }
}
key = key.trim()
val = val.trim()
log.info(&apos;config&apos;, &apos;set %j %j&apos;, key, val)
var where = npm.config.get(&apos;global&apos;) ? &apos;global&apos; : &apos;user&apos;
if (key.match(/umask/)) val = umask.<span class="apidocCodeKeywordSpan">fromString</span>(val)
npm.config.set(key, val, where)
npm.config.save(where, cb)
}

function get (key, cb) {
if (!key) return list(cb)
if (!publicVar(key)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.umask.toString" id="apidoc.element.npm.umask.toString">
        function <span class="apidocSignatureSpan">npm.umask.</span>toString
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString(val) {
    val = val.toString(8);
    while (val.length &lt; 4) {
        val = &quot;0&quot; + val;
    }
    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function get (key, cb) {
  if (!key) return list(cb)
  if (!publicVar(key)) {
    return cb(new Error(&apos;---sekretz---&apos;))
  }
  var val = npm.config.get(key)
  if (key.match(/umask/)) val = umask.<span class="apidocCodeKeywordSpan">toString</span>(val)
  output(val)
  cb()
}

function sort (a, b) {
  return a &gt; b ? 1 : -1
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.umask.validate" id="apidoc.element.npm.umask.validate">
        function <span class="apidocSignatureSpan">npm.umask.</span>validate
        <span class="apidocSignatureSpan">(data, k, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(data, k, val) {
    // must be either an integer or an octal string.
    if (typeof val === &quot;number&quot; &amp;&amp; !isNaN(val)) {
        data[k] = val;
        return true;
    }

    if (typeof val === &quot;string&quot;) {
        if (val.charAt(0) !== &quot;0&quot;) {
            return false;
        }
        data[k] = parseInt(val, 8);
        return true;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.warn(m + &apos; &apos; + util.format.apply(util, [].slice.call(arguments, 1)))
  } }
}

exports.Umask = Umask
function Umask () {}
function validateUmask (data, k, val) {
  return umask.<span class="apidocCodeKeywordSpan">validate</span>(data, k, val)
}

function validateSemver (data, k, val) {
  if (!semver.valid(val)) return false
  data[k] = semver.valid(val)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.unbuild" id="apidoc.module.npm.unbuild">module npm.unbuild</a></h1>


    <h2>
        <a href="#apidoc.element.npm.unbuild.unbuild" id="apidoc.element.npm.unbuild.unbuild">
        function <span class="apidocSignatureSpan">npm.</span>unbuild
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unbuild(args, silent, cb) {
  if (typeof silent === &apos;function&apos;) {
    cb = silent
    silent = false
  }
  asyncMap(args, unbuild_(silent), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unbuild.rmStuff" id="apidoc.element.npm.unbuild.rmStuff">
        function <span class="apidocSignatureSpan">npm.unbuild.</span>rmStuff
        <span class="apidocSignatureSpan">(pkg, folder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rmStuff(pkg, folder, cb) {
  // if it&apos;s global, and folder is in {prefix}/node_modules,
  // then bins are in {prefix}/bin
  // otherwise, then bins are in folder/../.bin
  var parent = pkg.name[0] === &apos;@&apos; ? path.dirname(path.dirname(folder)) : path.dirname(folder)
  var gnm = npm.dir
  // gnm might be an absolute path, parent might be relative
  // this checks they&apos;re the same directory regardless
  var top = path.relative(gnm, parent) === &apos;&apos;

  log.verbose(&apos;unbuild rmStuff&apos;, pkg._id, &apos;from&apos;, gnm)
  if (!top) log.verbose(&apos;unbuild rmStuff&apos;, &apos;in&apos;, parent)
  asyncMap([rmBins, rmMans], function (fn, cb) {
    fn(pkg, folder, parent, top, cb)
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.uninstall" id="apidoc.module.npm.uninstall">module npm.uninstall</a></h1>


    <h2>
        <a href="#apidoc.element.npm.uninstall.uninstall" id="apidoc.element.npm.uninstall.uninstall">
        function <span class="apidocSignatureSpan">npm.</span>uninstall
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uninstall(args, cb) {
  validate(&apos;AF&apos;, arguments)
  // the /path/to/node_modules/..
  const dryrun = !!npm.config.get(&apos;dry-run&apos;)

  if (args.length === 1 &amp;&amp; args[0] === &apos;.&apos;) args = []

  const where = npm.config.get(&apos;global&apos;) || !args.length
    ? path.resolve(npm.globalDir, &apos;..&apos;)
    : npm.prefix

  args = args.filter(function (a) {
    return path.resolve(a) !== where
  })

  if (args.length) {
    new Uninstaller(where, dryrun, args).run(cb)
  } else {
    // remove this package from the global space, if it&apos;s installed there
    readJson(path.resolve(npm.localPrefix, &apos;package.json&apos;), function (er, pkg) {
      if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
      if (er) return cb(uninstall.usage)
      new Uninstaller(where, dryrun, [pkg.name]).run(cb)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.uninstall.Uninstaller" id="apidoc.element.npm.uninstall.Uninstaller">
        function <span class="apidocSignatureSpan">npm.uninstall.</span>Uninstaller
        <span class="apidocSignatureSpan">(where, dryrun, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Uninstaller extends Installer {
  constructor (where, dryrun, args) {
    super(where, dryrun, args)
    this.remove = []
  }

  loadArgMetadata (next) {
    this.args = this.args.map(function (arg) { return {name: arg} })
    next()
  }

  loadAllDepsIntoIdealTree (cb) {
    validate(&apos;F&apos;, arguments)
    this.remove = this.args
    this.args = []
    log.silly(&apos;uninstall&apos;, &apos;loadAllDepsIntoIdealTree&apos;)
    const saveDeps = getSaveType()

    super.loadAllDepsIntoIdealTree(iferr(cb, () =&gt; {
      removeDeps(this.remove, this.idealTree, saveDeps, cb)
    }))
  }

  // no top level lifecycles on rm
  runPreinstallTopLevelLifecycles (cb) { cb() }
  runPostinstallTopLevelLifecycles (cb) { cb() }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.uninstall.completion" id="apidoc.element.npm.uninstall.completion">
        function <span class="apidocSignatureSpan">npm.uninstall.</span>completion
        <span class="apidocSignatureSpan">(opts, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedShallow(opts, filter, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = filter
    filter = null
  }
  var conf = opts.conf
  var args = conf.argv.remain
  if (args.length &gt; 3) return cb()
  var local
  var global
  var localDir = npm.dir
  var globalDir = npm.globalDir
  if (npm.config.get(&apos;global&apos;)) {
    local = []
    next()
  } else {
    fs.readdir(localDir, function (er, pkgs) {
      local = (pkgs || []).filter(function (p) {
        return p.charAt(0) !== &apos;.&apos;
      })
      next()
    })
  }

  fs.readdir(globalDir, function (er, pkgs) {
    global = (pkgs || []).filter(function (p) {
      return p.charAt(0) !== &apos;.&apos;
    })
    next()
  })
  function next () {
    if (!local || !global) return
    filterInstalled(local, global, filter, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.unpublish" id="apidoc.module.npm.unpublish">module npm.unpublish</a></h1>


    <h2>
        <a href="#apidoc.element.npm.unpublish.unpublish" id="apidoc.element.npm.unpublish.unpublish">
        function <span class="apidocSignatureSpan">npm.</span>unpublish
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unpublish(args, cb) {
  if (args.length &gt; 1) return cb(unpublish.usage)

  var thing = args.length ? npa(args[0]) : {}
  var project = thing.name
  var version = thing.rawSpec

  log.silly(&apos;unpublish&apos;, &apos;args[0]&apos;, args[0])
  log.silly(&apos;unpublish&apos;, &apos;thing&apos;, thing)
  if (!version &amp;&amp; !npm.config.get(&apos;force&apos;)) {
    return cb(
      &apos;Refusing to delete entire project.\n&apos; +
      &apos;Run with --force to do this.\n&apos; +
      unpublish.usage
    )
  }

  if (!project || path.resolve(project) === npm.localPrefix) {
    // if there&apos;s a package.json in the current folder, then
    // read the package name and version out of that.
    var cwdJson = path.join(npm.localPrefix, &apos;package.json&apos;)
    return readJson(cwdJson, function (er, data) {
      if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
      if (er) return cb(&apos;Usage:\n&apos; + unpublish.usage)
      log.verbose(&apos;unpublish&apos;, data)
      gotProject(data.name, data.version, data.publishConfig, cb)
    })
  }
  return gotProject(project, version, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (
  err.code === &apos;EPUBLISHCONFLICT&apos; &amp;&amp;
  npm.config.get(&apos;force&apos;) &amp;&amp;
  !isRetry
) {
  log.warn(&apos;publish&apos;, &apos;Forced publish over &apos; + pkg._id)
  return BB.fromNode((cb) =&gt; {
    npm.commands.<span class="apidocCodeKeywordSpan">unpublish</span>([pkg._id], cb)
  }).finally(() =&gt; {
    // ignore errors.  Use the force.  Reach out with your feelings.
    return upload(arg, pkg, true, cached).catch(() =&gt; {
      // but if it fails again, then report the first error.
      throw err
    })
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unpublish.completion" id="apidoc.element.npm.unpublish.completion">
        function <span class="apidocSignatureSpan">npm.unpublish.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  if (opts.conf.argv.remain.length &gt;= 3) return cb()
  npm.commands.whoami([], true, function (er, username) {
    if (er) return cb()

    var un = encodeURIComponent(username)
    if (!un) return cb()
    var byUser = &apos;-/by-user/&apos; + un
    mapToRegistry(byUser, npm.config, function (er, uri, auth) {
      if (er) return cb(er)

      npm.registry.get(uri, { auth: auth }, function (er, pkgs) {
        // do a bit of filtering at this point, so that we don&apos;t need
        // to fetch versions for more than one thing, but also don&apos;t
        // accidentally a whole project.
        pkgs = pkgs[un]
        if (!pkgs || !pkgs.length) return cb()
        var pp = npa(opts.partialWord).name
        pkgs = pkgs.filter(function (p) {
          return p.indexOf(pp) === 0
        })
        if (pkgs.length &gt; 1) return cb(null, pkgs)
        mapToRegistry(pkgs[0], npm.config, function (er, uri, auth) {
          if (er) return cb(er)

          npm.registry.get(uri, { auth: auth }, function (er, d) {
            if (er) return cb(er)
            var vers = Object.keys(d.versions)
            if (!vers.length) return cb(null, pkgs)
            return cb(null, vers.map(function (v) {
              return pkgs[0] + &apos;@&apos; + v
            }))
          })
        })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.unsupported" id="apidoc.module.npm.unsupported">module npm.unsupported</a></h1>


    <h2>
        <a href="#apidoc.element.npm.unsupported.checkForBrokenNode" id="apidoc.element.npm.unsupported.checkForBrokenNode">
        function <span class="apidocSignatureSpan">npm.unsupported.</span>checkForBrokenNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForBrokenNode = function () {
  var nodejs = checkVersion(process.version)
  if (nodejs.broken) {
    console.error(&apos;ERROR: npm is known not to run on Node.js &apos; + process.version)
    supportedNode.forEach(function (rel) {
      if (semver.satisfies(nodejs.version, rel.ver)) {
        console.error(&apos;Node.js &apos; + rel.ver + &quot; is supported but the specific version you&apos;re running has&quot;)
        console.error(&apos;a bug known to break npm. Please update to at least &apos; + rel.min + &apos; to use this&apos;)
        console.error(&apos;version of npm. You can find the latest release of Node.js at https://nodejs.org/&apos;)
        process.exit(1)
      }
    })
    var supportedMajors = supportedNode.map(function (n) { return n.ver }).join(&apos;, &apos;)
    console.error(&quot;You&apos;ll need to upgrade to a newer version in order to use this&quot;)
    console.error(&apos;version of npm. Supported versions are &apos; + supportedMajors + &apos;. You can find the&apos;)
    console.error(&apos;latest version at https://nodejs.org/&apos;)
    process.exit(1)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  WScript.quit(1)
  return
}

process.title = &apos;npm&apos;

var unsupported = require(&apos;../lib/utils/unsupported.js&apos;)
unsupported.<span class="apidocCodeKeywordSpan">checkForBrokenNode</span>()

var log = require(&apos;npmlog&apos;)
log.pause() // will be unpaused when config is loaded.
log.info(&apos;it worked if it ends with&apos;, &apos;ok&apos;)

unsupported.checkForUnsupportedNode()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unsupported.checkForUnsupportedNode" id="apidoc.element.npm.unsupported.checkForUnsupportedNode">
        function <span class="apidocSignatureSpan">npm.unsupported.</span>checkForUnsupportedNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForUnsupportedNode = function () {
  var nodejs = checkVersion(process.version)
  if (nodejs.unsupported) {
    var log = require(&apos;npmlog&apos;)
    var supportedMajors = supportedNode.map(function (n) { return n.ver }).join(&apos;, &apos;)
    log.warn(&apos;npm&apos;, &apos;npm does not support Node.js &apos; + process.version)
    log.warn(&apos;npm&apos;, &apos;You should probably upgrade to a newer version of node as we&apos;)
    log.warn(&apos;npm&apos;, &quot;can&apos;t make any promises that npm will work with this version.&quot;)
    log.warn(&apos;npm&apos;, &apos;Supported releases of Node.js are the latest release of &apos; + supportedMajors + &apos;.&apos;)
    log.warn(&apos;npm&apos;, &apos;You can find the latest version at https://nodejs.org/&apos;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var unsupported = require(&apos;../lib/utils/unsupported.js&apos;)
unsupported.checkForBrokenNode()

var log = require(&apos;npmlog&apos;)
log.pause() // will be unpaused when config is loaded.
log.info(&apos;it worked if it ends with&apos;, &apos;ok&apos;)

unsupported.<span class="apidocCodeKeywordSpan">checkForUnsupportedNode</span>()

var path = require(&apos;path&apos;)
var npm = require(&apos;../lib/npm.js&apos;)
var npmconf = require(&apos;../lib/config/core.js&apos;)
var errorHandler = require(&apos;../lib/utils/error-handler.js&apos;)

var configDefs = npmconf.defs
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unsupported.checkVersion" id="apidoc.element.npm.unsupported.checkVersion">
        function <span class="apidocSignatureSpan">npm.unsupported.</span>checkVersion
        <span class="apidocSignatureSpan">(version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkVersion = function (version) {
  var versionNoPrerelease = version.replace(/-.*$/, &apos;&apos;)
  return {
    version: versionNoPrerelease,
    broken: semver.satisfies(versionNoPrerelease, knownBroken),
    unsupported: !semver.satisfies(versionNoPrerelease, supportedNode.map(function (n) { return &apos;^&apos; + n.min }).join(&apos;||&apos;))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// now actually fire up npm and run the command.
// this is how to use npm programmatically:
conf._exit = true
npm.load(conf, function (er) {
  if (er) return errorHandler(er)
  if (!unsupported.<span class="apidocCodeKeywordSpan">checkVersion</span>(process.version).unsupported) {
    const pkg = require(&apos;../package.json&apos;)
    let notifier = require(&apos;update-notifier&apos;)({pkg})
    if (
      notifier.update &amp;&amp;
      notifier.update.latest !== pkg.version
    ) {
      const color = require(&apos;ansicolors&apos;)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.validate_args" id="apidoc.module.npm.validate_args">module npm.validate_args</a></h1>


    <h2>
        <a href="#apidoc.element.npm.validate_args.validate_args" id="apidoc.element.npm.validate_args.validate_args">
        function <span class="apidocSignatureSpan">npm.</span>validate_args
        <span class="apidocSignatureSpan">(idealTree, args, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_args = function (idealTree, args, next) {
  validate(&apos;OAF&apos;, arguments)
  var force = npm.config.get(&apos;force&apos;)

  asyncMap(args, function (pkg, done) {
    chain([
      [hasMinimumFields, pkg],
      [checkSelf, idealTree, pkg, force],
      [isInstallable, pkg]
    ], done)
  }, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.validate_args.isInstallable" id="apidoc.element.npm.validate_args.isInstallable">
        function <span class="apidocSignatureSpan">npm.validate_args.</span>isInstallable
        <span class="apidocSignatureSpan">(pkg, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstallable = function (pkg, next) {
  var force = npm.config.get(&apos;force&apos;)
  var nodeVersion = npm.config.get(&apos;node-version&apos;)
  if (/-/.test(nodeVersion)) {
    // for the purposes of validation, if the node version is a prerelease,
    // strip that. We check and warn about this sceanrio over in validate-tree.
    nodeVersion = nodeVersion.replace(/-.*/, &apos;&apos;)
  }
  var strict = npm.config.get(&apos;engine-strict&apos;)
  checkEngine(pkg, npm.version, nodeVersion, force, strict, iferr(next, thenWarnEngineIssues))
  function thenWarnEngineIssues (warn) {
    if (warn) getWarnings(pkg).push(warn)
    checkPlatform(pkg, force, next)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.view" id="apidoc.module.npm.view">module npm.view</a></h1>


    <h2>
        <a href="#apidoc.element.npm.view.view" id="apidoc.element.npm.view.view">
        function <span class="apidocSignatureSpan">npm.</span>view
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function view(args, silent, cb) {
  if (typeof cb !== &apos;function&apos;) {
    cb = silent
    silent = false
  }

  if (!args.length) args = [&apos;.&apos;]

  var pkg = args.shift()
  var nv
  if (/^[.]@/.test(pkg)) {
    nv = npa.resolve(null, pkg.slice(2))
  } else {
    nv = npa(pkg)
  }
  var name = nv.name
  var local = (name === &apos;.&apos; || !name)

  if (npm.config.get(&apos;global&apos;) &amp;&amp; local) {
    return cb(new Error(&apos;Cannot use view command in global mode.&apos;))
  }

  if (local) {
    var dir = npm.prefix
    readJson(path.resolve(dir, &apos;package.json&apos;), function (er, d) {
      d = d || {}
      if (er &amp;&amp; er.code !== &apos;ENOENT&apos; &amp;&amp; er.code !== &apos;ENOTDIR&apos;) return cb(er)
      if (!d.name) return cb(new Error(&apos;Invalid package.json&apos;))

      var p = d.name
      nv = npa(p)
      if (pkg &amp;&amp; ~pkg.indexOf(&apos;@&apos;)) {
        nv.rawSpec = pkg.split(&apos;@&apos;)[pkg.indexOf(&apos;@&apos;)]
      }

      fetchAndRead(nv, args, silent, cb)
    })
  } else {
    fetchAndRead(nv, args, silent, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.view.completion" id="apidoc.element.npm.view.completion">
        function <span class="apidocSignatureSpan">npm.view.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  if (opts.conf.argv.remain.length &lt;= 2) {
    // FIXME: there used to be registry completion here, but it stopped making
    // sense somewhere around 50,000 packages on the registry
    return cb()
  }
  // have the package, get the fields.
  var tag = npm.config.get(&apos;tag&apos;)
  mapToRegistry(opts.conf.argv.remain[2], npm.config, function (er, uri, auth) {
    if (er) return cb(er)

    npm.registry.get(uri, { auth: auth }, function (er, d) {
      if (er) return cb(er)
      var dv = d.versions[d[&apos;dist-tags&apos;][tag]]
      var fields = []
      d.versions = Object.keys(d.versions).sort(semver.compareLoose)
      fields = getFields(d).concat(getFields(dv))
      cb(null, fields)
    })
  })

  function getFields (d, f, pref) {
    f = f || []
    if (!d) return f
    pref = pref || []
    Object.keys(d).forEach(function (k) {
      if (k.charAt(0) === &apos;_&apos; || k.indexOf(&apos;.&apos;) !== -1) return
      var p = pref.concat(k).join(&apos;.&apos;)
      f.push(p)
      if (Array.isArray(d[k])) {
        d[k].forEach(function (val, i) {
          var pi = p + &apos;[&apos; + i + &apos;]&apos;
          if (val &amp;&amp; typeof val === &apos;object&apos;) getFields(val, f, [p])
          else f.push(pi)
        })
        return
      }
      if (typeof d[k] === &apos;object&apos;) getFields(d[k], f, [p])
    })
    return f
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require(&apos;graceful-fs&apos;)
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.writable" id="apidoc.module.npm.writable">module npm.writable</a></h1>


    <h2>
        <a href="#apidoc.element.npm.writable.writable" id="apidoc.element.npm.writable.writable">
        function <span class="apidocSignatureSpan">npm.</span>writable
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight(&apos;writable:&apos; + dir, done)
  if (!done) return
  fs.access(dir, fs.W_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.writable.fsAccessImplementation" id="apidoc.element.npm.writable.fsAccessImplementation">
        function <span class="apidocSignatureSpan">npm.writable.</span>fsAccessImplementation
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight(&apos;writable:&apos; + dir, done)
  if (!done) return
  fs.access(dir, fs.W_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.writable.fsOpenImplementation" id="apidoc.element.npm.writable.fsOpenImplementation">
        function <span class="apidocSignatureSpan">npm.writable.</span>fsOpenImplementation
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsOpenImplementation(dir, done) {
  done = inflight(&apos;writable:&apos; + dir, done)
  if (!done) return
  var tmp = path.join(dir, &apos;.npm.check.permissions&apos;)
  fs.open(tmp, &apos;w&apos;, function (er, fd) {
    if (er) return done(accessError(dir, er))
    fs.close(fd, function () {
      fs.unlink(tmp, andIgnoreErrors(done))
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
