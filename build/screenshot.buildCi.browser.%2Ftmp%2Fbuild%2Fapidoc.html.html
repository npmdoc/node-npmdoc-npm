<html data-scrape="{
    &quot;hrefDict&quot;: {
        &quot;https://docs.npmjs.com/&quot;: &quot;npm (v5.8.0)&quot;,
        &quot;https://github.com/kaizhu256/node-utility2&quot;: &quot;utility2&quot;
    },
    &quot;href&quot;: &quot;file:///home/travis/build/npmdoc/node-npmdoc-npm/tmp/build/apidoc.html&quot;,
    &quot;url&quot;: &quot;file:///home/travis/build/npmdoc/node-npmdoc-npm/tmp/build/apidoc.html&quot;,
    &quot;bodyTextContent&quot;: &quot;description and source-codefunction access(args, cb) {\n  var cmd = args.shift()\n  var params\n  return parseParams(cmd, args, function (err, p) {\n    if (err) { return cb(err) }\n    params = p\n    return mapToRegistry(params.package, npm.config, invokeCmd)\n  })\n\n  function invokeCmd (err, uri, auth, base) {\n    if (err) { return cb(err) }\n    params.auth = auth\n    try {\n      return npm.registry.access(cmd, uri, params, function (err, data) {\n        if (!err &amp;&amp; data) {\n          output(JSON.stringify(data, undefined, 2))\n        }\n        cb(err, data)\n      })\n    } catch (e) {\n      cb(e.message + '\\n\\nUsage:\\n' + access.usage)\n    }\n  }\n}\n    example usage...\n  return mapToRegistry(params.package, npm.config, invokeCmd)\n})\n\nfunction invokeCmd (err, uri, auth, base) {\n  if (err) { return cb(err) }\n  params.auth = auth\n  try {\n    return npm.registry.access(cmd, uri, params, function (err, data) {\n      if (!err &amp;&amp; data) {\n        output(JSON.stringify(data, undefined, 2))\n      }\n      cb(err, data)\n    })\n  } catch (e) {\n    cb(e.message + '\\n\\nUsage:\\n' + access.usage)\n...\n\n                      createEntryStream(cachePath, uri, auth, staleness, function (err, entryStream, latest, newEntries) {\n      if (err) return stream.emit('error', err)\n      log.silly('all-package-metadata', 'entry stream created')\n      if (entryStream &amp;&amp; newEntries) {\n        createCacheWriteStream(cachePath, latest, function (err, writeStream) {\n          if (err) return stream.emit('error', err)\n          log.silly('all-package-metadata', 'output stream created')\n          ms.pipeline.obj(entryStream, writeStream, stream)\n        })\n      } else if (entryStream) {\n        ms.pipeline.obj(entryStream, stream)\n      } else {\n        stream.emit('error', new Error('No search sources available'))\n      }\n    })\n  })\n  return stream\n}\n    example usagen/a\n\n                            var url = d.bugs &amp;&amp; ((typeof d.bugs === 'string') ? d.bugs : d.bugs.url)\n    if (!url) {\n      url = 'https://www.npmjs.org/package/' + d.name\n    }\n    log.silly('bugs', 'url', url)\n    opener(url, { command: npm.config.get('browser') }, cb)\n  })\n}\n    example usagen/a\n\n            description and source-codefunction ci(args, cb) {\n  return new Installer({\n    config: npm.config,\n    log: npmlog\n  })\n  .run()\n  .then(\n    (details) => console.error(`added ${details.pkgCount} packages in ${\n      details.runTime / 1000\n    }s`)\n  )\n  .then(() => cb(), cb)\n}\n    example usagen/a\n\n                  // get the partial line and partial word,\n  // if the point isn't at the end.\n  // ie, tabbing at: npm foo b|ar\n  var w = +process.env.COMP_CWORD\n  var words = args.map(unescape)\n  var word = words[w]\n  var line = process.env.COMP_LINE\n  var point = +process.env.COMP_POINT\n  var partialLine = line.substr(0, point)\n  var partialWords = words.slice(0, w)\n\n  // figure out where in that last word the point is.\n  var partialWord = args[w]\n  var i = partialWord.length\n  while (partialWord.substr(0, i) !== partialLine.substr(-1 * i) &amp;&amp; i > 0) {\n    i--\n  }\n  partialWord = unescape(partialWord.substr(0, i))\n  partialWords.push(partialWord)\n\n        if (partialWords.slice(0, -1).indexOf('--') === -1) {\n    if (word.charAt(0) === '-') return configCompl(opts, cb)\n    if (words[w - 1] &amp;&amp;\n        words[w - 1].charAt(0) === '-' &amp;&amp;\n        !isFlag(words[w - 1])) {\n      // awaiting a value for a non-bool config.\n      // don't even try to do this for now\n      console.error('configValueCompl')\n      return configValueCompl(opts, cb)\n    }\n  }\n\n  // try to find the npm command.\n  // it's the first thing after all the configs.\n  // take a little shortcut and use npm's arg parsing logic.\n  // don't have to worry about the last arg being implicitly\n  // boolean'ed, since the last block will catch that.\n  var parsed = opts.conf =\n    nopt(configTypes, shorthands, partialWords.slice(0, -1), 0)\n  // check if there's a command already.\n  console.error(parsed)\n  var cmd = parsed.argv.remain[1]\n  if (!cmd) return cmdCompl(opts, cb)\n\n                  description and source-codefunction gf() {\n  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {\n    return gf[kDefaultMethod].func.apply(this, arguments)\n  } else {\n    return gf.applyGenfun(this, arguments)\n  }\n}\n    example usage...\n  // now actually fire up npm and run the command.\n  // this is how to use npm programmatically:\n  conf._exit = true\n  npm.load(conf, function (er) {\n    if (er) return errorHandler(er)\n    npm.commands[npm.command](npm.argv, function (err) {\n      // https://www.youtube.com/watch?v=7nfPu8qTiQU\n      if (!err &amp;&amp; npm.config.get('ham-it-up') &amp;&amp; !npm.config\n.get('json') &amp;&amp; !npm.config.get('parseable') &amp;&amp; npm.command !== 'completion') {\n        output('\\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\\n')\n      }\n      errorHandler.apply(this, arguments)\n    })\n  })\n})()\n...\n\n            description and source-codefunction gf() {\n  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {\n    return gf[kDefaultMethod].func.apply(this, arguments)\n  } else {\n    return gf.applyGenfun(this, arguments)\n  }\n}\n    example usage...\n  } catch (e) {\n    return cb(new Error('no such auth module'))\n  }\n  auth.login(creds, registry, scope, function (err, newCreds) {\n    if (err) return cb(err)\n\n                                        description and source-codefunction dedupe(args, cb) {\n  validate('AF', arguments)\n  // the /path/to/node_modules/..\n  var where = path.resolve(npm.dir, '..')\n  var dryrun = false\n  if (npm.command.match(/^find/)) dryrun = true\n  if (npm.config.get('dry-run')) dryrun = true\n  if (dryrun &amp;&amp; !npm.config.get('json')) npm.config.set('parseable', true)\n\n                                        description and source-codederef = function (c) {\n  if (!c) return ''\n  if (c.match(/[A-Z]/)) {\n    c = c.replace(/([A-Z])/g, function (m) {\n      return '-' + m.toLowerCase()\n    })\n  }\n  if (plumbing.indexOf(c) !== -1) return c\n  var a = abbrevs[c]\n  if (aliases[a]) a = aliases[a]\n  return a\n}\n    example usage...\n  process.argv.splice(1, 1, 'npm', '-g')\n}\n\n                        description and source-codefunction edit(args, cb) {\n  var p = args[0]\n  if (args.length !== 1 || !p) return cb(edit.usage)\n  var e = npm.config.get('editor')\n  if (!e) {\n    return cb(new Error(\n      \&quot;No editor set.  Set the 'editor' config, or $EDITOR environ.\&quot;\n    ))\n  }\n  p = p.split('/')\n       .join('/node_modules/')\n       .replace(/(\\/node_modules)+/, '/node_modules')\n  var f = path.resolve(npm.dir, p)\n  fs.lstat(f, function (er) {\n    if (er) return cb(er)\n    editor(f, { editor: e }, noProgressTillDone(function (er) {\n      if (er) return cb(er)\n      npm.commands.rebuild(args, cb)\n    }))\n  })\n}\n    example usagen/a\n\n            description and source-codefunction errorHandler(er) {\n  log.disableProgress()\n  if (!npm.config || !npm.config.loaded) {\n    // logging won't work unless we pretend that it's ready\n    er = er || new Error('Exit prior to config file resolving.')\n    console.error(er.stack || er.message)\n  }\n\n                var msg = errorMessage(er)\n  msg.summary.concat(msg.detail).forEach(function (errline) {\n    log.error.apply(log, errline)\n  })\n  if (npm.config.get('json')) {\n    var error = {\n      error: {\n        code: er.code,\n        summary: messageText(msg.summary),\n        detail: messageText(msg.detail)\n      }\n    }\n    console.log(JSON.stringify(error, null, 2))\n  }\n\n                              var shellArgs = []\n  if (args) {\n    if (isWindowsShell) {\n      var execCmd = escapeExecPath(args.shift())\n      var execArgs = [execCmd].concat(args.map(escapeArg))\n      opts.windowsVerbatimArguments = true\n      shellArgs = ['/d', '/s', '/c'].concat(execArgs)\n    } else {\n      shellArgs.unshift('-c')\n      shellArgs = ['-c', args.map(escapeArg).join(' ').trim()]\n    }\n  }\n\n                      description and source-codefunction extract(staging, pkg, log) {\n  log.silly('extract', packageId(pkg))\n  const extractTo = moduleStagingPath(staging, pkg)\n  if (!pacoteOpts) {\n    pacoteOpts = require('../../config/pacote')\n  }\n  const opts = pacoteOpts({\n    integrity: pkg.package._integrity,\n    resolved: pkg.package._resolved\n  })\n  const args = [\n    pkg.package._requested,\n    extractTo,\n    opts\n  ]\n  return BB.fromNode((cb) => {\n    let launcher = localWorker\n    let msg = args\n    const spec = typeof args[0] === 'string' ? npa(args[0]) : args[0]\n    args[0] = spec.raw\n    if (ENABLE_WORKERS &amp;&amp; (isRegistry(spec) || spec.type === 'remote')) {\n      // We can't serialize these options\n      opts.loglevel = opts.log.level\n      opts.log = null\n      opts.dirPacker = null\n      // workers will run things in parallel!\n      launcher = workers\n      try {\n        msg = JSON.stringify(msg)\n      } catch (e) {\n        return cb(e)\n      }\n    }\n    launcher(msg, cb)\n  }).then(() => {\n    if (pkg.package.bundleDependencies || anyBundled(pkg)) {\n      return readBundled(pkg, staging, extractTo)\n    }\n  }).then(() => {\n    return gentlyRm(path.join(extractTo, 'node_modules'))\n  })\n}\n    example usage...\n  })\n}\n\ncache.unpack = unpack\nfunction unpack (pkg, ver, unpackTarget, dmode, fmode, uid, gid) {\n  return unbuild([unpackTarget], true).then(() => {\n    const opts = pacoteOpts({dmode, fmode, uid, gid, offline: true})\n    return pacote.extract(npa.resolve(pkg, ver), unpackTarget, opts)\n  })\n}\n...\n\n            description and source-codefunction limited() {\n  var self = this\n  var args = Array.prototype.slice.call(arguments)\n  if (running >= maxRunning) {\n    queue.push({self: this, args: args})\n    return\n  }\n  var cb = typeof args[args.length-1] === 'function' &amp;&amp; args.pop()\n  ++ running\n  args.push(function () {\n    var cbargs = arguments\n    -- running\n    cb &amp;&amp; process.nextTick(function () {\n      cb.apply(self, cbargs)\n    })\n    if (queue.length) {\n      var next = queue.shift()\n      limited.apply(next.self, next.args)\n    }\n  })\n  func.apply(self, args)\n}\n    example usagen/a\n\n                  const requested = pkg.package._requested || getRequested(pkg)\n  if (requested.type === 'directory') {\n    const relative = path.relative(path.dirname(pkg.path), pkg.realpath)\n    return makeParentPath(pkg.path)\n      .then(() => symlink(relative, pkg.path, 'junction'))\n      .catch((ex) => {\n        return rimraf(pkg.path).then(() => symlink(relative, pkg.path, 'junction'))\n      })\n  } else {\n    return makeParentPath(pkg.realpath)\n      .then(moveStagingToDestination)\n      .then(restoreOldNodeModules)\n      .catch((err) => {\n        if (movedDestAway) {\n          return rimraf(pkg.realpath).then(moveOldDestinationBack).then(() => {\n            throw err\n          })\n        } else {\n          throw err\n        }\n      })\n      .then(() => rimraf(delpath))\n  }\n\n              function restoreOldNodeModules () {\n    if (!movedDestAway) return\n    return readdir(path.join(delpath, 'node_modules')).catch(() => []).then((modules) => {\n      if (!modules.length) return\n      return mkdirp(path.join(pkg.realpath, 'node_modules')).then(() => Bluebird.map(modules, (file) => {\n        const from = path.join(delpath, 'node_modules', file)\n        const to = path.join(pkg.realpath, 'node_modules', file)\n        return move(from, to, moveOpts)\n      }))\n    })\n  }\n}\n    example usagen/a\n\n            description and source-codefunction flattenTree(tree) {\n  validate('O', arguments)\n  var seen = new Set()\n  var flat = {}\n  var todo = [[tree, '/']]\n  while (todo.length) {\n    var next = todo.shift()\n    var pkg = next[0]\n    seen.add(pkg)\n    var path = next[1]\n    flat[path] = pkg\n    if (path !== '/') path += '/'\n    for (var ii = 0; ii < pkg.children.length; ++ii) {\n      var child = pkg.children[ii]\n      if (!seen.has(child)) {\n        todo.push([child, flatName(path, child)])\n      }\n    }\n  }\n  return flat\n}\n    example usagen/a\n\n                      // npm <command> -h: show command usage\n  if (npm.config.get('usage') &amp;&amp;\n      npm.commands[section] &amp;&amp;\n      npm.commands[section].usage) {\n    npm.config.set('loglevel', 'silent')\n    log.level = 'silent'\n    output(npm.commands[section].usage)\n    return cb()\n  }\n\n  // npm apihelp <section>: Prefer section 3 over section 1\n  var apihelp = argv.length &amp;&amp; argv[0].indexOf('api') !== -1\n  var pref = apihelp ? [3, 1, 5, 7] : [1, 3, 5, 7]\n  if (argnum) {\n    pref = [ argnum ].concat(pref.filter(function (n) {\n      return n !== argnum\n    }))\n  }\n\n      // find either /section.n or /npm-section.n\n  // The glob is used in the glob.  The regexp is used much\n  // further down.  Globs and regexps are different\n  var compextglob = '.+(gz|bz2|lzma|[FYzZ]|xz)'\n  var compextre = '\\\\.(gz|bz2|lzma|[FYzZ]|xz)$'\n  var f = '+(npm-' + section + '|' + section + ').[0-9]?(' + compextglob + ')'\n  return glob(manroot + '/*/' + f, function (er, mans) {\n    if (er) return cb(er)\n\n                              description and source-codefunction install(where, args, cb) {\n  if (!cb) {\n    cb = args\n    args = where\n    where = null\n  }\n  var globalTop = path.resolve(npm.globalDir, '..')\n  if (!where) {\n    where = npm.config.get('global')\n          ? globalTop\n          : npm.prefix\n  }\n  validate('SAF', [where, args, cb])\n  // the /path/to/node_modules/..\n  var dryrun = !!npm.config.get('dry-run')\n\n      // if it's a folder, a random not-installed thing, or not a scoped package,\n// then link or install it first\nif (pkg[0] !== '@' &amp;&amp; (pkg.indexOf('/') !== -1 || pkg.indexOf('\\\\') !== -1)) {\n  return fs.lstat(path.resolve(pkg), function (er, st) {\n    if (er || !st.isDirectory()) {\n      npm.commands.install(t, pkg, n)\n    } else {\n      rp = path.resolve(pkg)\n      linkPkg(rp, n)\n    }\n  })\n}\n...\n\n            description and source-codefunction link(args, cb) {\n  if (process.platform === 'win32') {\n    var semver = require('semver')\n    if (!semver.gte(process.version, '0.7.9')) {\n      var msg = 'npm link not supported on windows prior to node 0.7.9'\n      var e = new Error(msg)\n      e.code = 'ENOTSUP'\n      e.errno = require('constants').ENOTSUP\n      return cb(e)\n    }\n  }\n\n                description and source-codeload = function (cli, cb_) {\n  if (!cb_ &amp;&amp; typeof cli === 'function') {\n    cb_ = cli\n    cli = {}\n  }\n  if (!cb_) cb_ = function () {}\n  if (!cli) cli = {}\n  loadListeners.push(cb_)\n  if (loaded || loadErr) return cb(loadErr)\n  if (loading) return\n  loading = true\n  var onload = true\n\n  function cb (er) {\n    if (loadErr) return\n    loadErr = er\n    if (er) return cb_(er)\n    if (npm.config.get('force')) {\n      log.warn('using --force', 'I sure hope you know what you are doing.')\n    }\n    npm.config.loaded = true\n    loaded = true\n    loadCb(loadErr = er)\n    onload = onload &amp;&amp; npm.config.get('onload-script')\n    if (onload) {\n      try {\n        require(onload)\n      } catch (err) {\n        log.warn('onload-script', 'failed to require onload script', onload)\n        log.warn('onload-script', err)\n      }\n      onload = false\n    }\n  }\n\n    // now actually fire up npm and run the command.\n// this is how to use npm programmatically:\nconf._exit = true\nnpm.load(conf, function (er) {\n  if (er) return errorHandler(er)\n  npm.commands[npm.command](npm.argv, function (err) {\n    // https://www.youtube.com/watch?v=7nfPu8qTiQU\n    if (!err &amp;&amp; npm.config.get('ham-it-up') &amp;&amp; !npm.config.get('json') &amp;&amp; !npm.config\n.get('parseable') &amp;&amp; npm.command !== 'completion') {\n      output('\\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\\n')\n    }\n    errorHandler.apply(this, arguments)\n...\n\n            description and source-codefunction ls(args, silent, cb) {\n  if (typeof cb !== 'function') {\n    cb = silent\n    silent = false\n  }\n  var dir = path.resolve(npm.dir, '..')\n  readPackageTree(dir, function (_, physicalTree) {\n    if (!physicalTree) physicalTree = {package: {}, path: dir}\n    physicalTree.isTop = true\n    readShrinkwrap.andInflate(physicalTree, function () {\n      lsFromTree(dir, computeMetadata(physicalTree), args, silent, cb)\n    })\n  })\n}\n    example usagen/a\n\n                      if (node.parent) {\n      // If a node is a cycle that never reaches the root of the logical\n      // tree then we'll leave it attached to the root, or else it\n      // would go missing. Further we'll note that this is the node in the\n      // cycle that we picked arbitrarily to be the one attached to the root.\n      // others will fall\n      if (isDisconnectedCycle(node)) {\n        node.cycleTop = true\n      // Nor do we want to disconnect non-cyclical extraneous modules from the tree.\n      } else if (node.requiredBy.length) {\n        // regular deps though, we do, as we're moving them into the capable\n        // hands of the modules that require them.\n        node.parent.children = without(node.parent.children, node)\n      }\n    }\n\n                description and source-codefunction owner(args, cb) {\n  var action = args.shift()\n  switch (action) {\n    case 'ls': case 'list': return ls(args[0], cb)\n    case 'add': return add(args[0], args[1], cb)\n    case 'rm': case 'remove': return rm(args[0], args[1], cb)\n    default: return unknown(action, cb)\n  }\n}\n    example usagen/a\n\n                                        description and source-codefunction profileCmd(args, cb) {\n  if (args.length === 0) return cb(new Error(profileCmd.usage))\n  log.gauge.show('profile')\n  switch (args[0]) {\n    case 'enable-2fa':\n    case 'enable-tfa':\n    case 'enable2fa':\n    case 'enabletfa':\n      withCb(enable2fa(args.slice(1)), cb)\n      break\n    case 'disable-2fa':\n    case 'disable-tfa':\n    case 'disable2fa':\n    case 'disabletfa':\n      withCb(disable2fa(), cb)\n      break\n    case 'get':\n      withCb(get(args.slice(1)), cb)\n      break\n    case 'set':\n      withCb(set(args.slice(1)), cb)\n      break\n    default:\n      cb(new Error('Unknown profile command: ' + args[0]))\n  }\n}\n    example usagen/a\n\n                                log.showProgress('publish:' + pkg._id)\nreturn BB.fromNode((cb) => {\n  registry.publish(registryBase, params, cb)\n}).catch((err) => {\n  if (\n    err.code === 'EPUBLISHCONFLICT' &amp;&amp;\n    npm.config.get('force') &amp;&amp;\n    !isRetry\n  ) {\n    log.warn('publish', 'Forced publish over ' + pkg._id)\n...\n\n                        description and source-codefunction readShrinkwrap(child, next) {\n  if (child.package._shrinkwrap) return process.nextTick(next)\n  BB.join(\n    maybeReadFile('npm-shrinkwrap.json', child),\n    // Don't read non-root lockfiles\n    child.isTop &amp;&amp; maybeReadFile('package-lock.json', child),\n    child.isTop &amp;&amp; maybeReadFile('package.json', child),\n    (shrinkwrap, lockfile, pkgJson) => {\n      if (shrinkwrap &amp;&amp; lockfile) {\n        log.warn('read-shrinkwrap', 'Ignoring package-lock.json because there is already an npm-shrinkwrap.json. Please use only\n one of the two.')\n      }\n      const name = shrinkwrap ? 'npm-shrinkwrap.json' : 'package-lock.json'\n      const parsed = parsePkgLock(shrinkwrap || lockfile, name)\n      if (parsed &amp;&amp; parsed.lockfileVersion !== PKGLOCK_VERSION) {\n        log.warn('read-shrinkwrap', `This version of npm is compatible with lockfileVersion@${PKGLOCK_VERSION}, but ${name} was\ngenerated for lockfileVersion@${parsed.lockfileVersion || 0}. I'll try to do my best with it!`)\n      }\n      child.package._shrinkwrap = parsed\n    }\n  ).then(() => next(), next)\n}\n    example usagen/a\n\n            description and source-codefunction rebuild(args, cb) {\n  var opt = { depth: npm.config.get('depth'), dev: true }\n  readInstalled(npm.prefix, opt, function (er, data) {\n    log.info('readInstalled', typeof data)\n    if (er) return cb(er)\n    var set = filter(data, args)\n    var folders = Object.keys(set).filter(function (f) {\n      return f !== npm.prefix\n    })\n    if (!folders.length) return cb()\n    log.silly('rebuild set', folders)\n    cleanBuild(folders, set, cb)\n  })\n}\n    example usage...\n       .join('/node_modules/')\n       .replace(/(\\/node_modules)+/, '/node_modules')\n  var f = path.resolve(npm.dir, p)\n  fs.lstat(f, function (er) {\n    if (er) return cb(er)\n    editor(f, { editor: e }, noProgressTillDone(function (er) {\n      if (er) return cb(er)\n      npm.commands.rebuild(args, cb)\n    }))\n  })\n}\n...\n\n                                                                description and source-codefunction search(args, cb) {\n  var searchOpts = {\n    description: npm.config.get('description'),\n    exclude: prepareExcludes(npm.config.get('searchexclude')),\n    include: prepareIncludes(args, npm.config.get('searchopts')),\n    limit: npm.config.get('searchlimit'),\n    log: log,\n    staleness: npm.config.get('searchstaleness'),\n    unicode: npm.config.get('unicode')\n  }\n\n        var esearchWritten = false\n  esearch(searchOpts).on('data', function (pkg) {\n    entriesStream.write(pkg)\n    !esearchWritten &amp;&amp; (esearchWritten = true)\n  }).on('error', function (e) {\n    if (esearchWritten) {\n      // If esearch errored after already starting output, we can't fall back.\n      return entriesStream.emit('error', e)\n    }\n    log.warn('search', 'fast search endpoint errored. Using old search.')\n    allPackageSearch(searchOpts).on('data', function (pkg) {\n      entriesStream.write(pkg)\n    }).on('error', function (e) {\n      entriesStream.emit('error', e)\n    }).on('end', function () {\n      entriesStream.end()\n    })\n  }).on('end', function () {\n    entriesStream.end()\n  })\n\n  // Grab a configured output stream that will spit out packages in the\n  // desired format.\n  var outputStream = formatPackageStream({\n    args: args, // --searchinclude options are not highlighted\n    long: npm.config.get('long'),\n    description: npm.config.get('description'),\n    json: npm.config.get('json'),\n    parseable: npm.config.get('parseable'),\n    color: npm.color\n  })\n  outputStream.on('data', function (chunk) {\n    if (!anyOutput) { anyOutput = true }\n    output(chunk.toString('utf8'))\n  })\n\n  log.silly('search', 'searching packages')\n  ms.pipe(entriesStream, outputStream, function (er) {\n    if (er) return cb(er)\n    if (!anyOutput &amp;&amp; !npm.config.get('json') &amp;&amp; !npm.config.get('parseable')) {\n      output('No matches found for ' + (args.map(JSON.stringify).join(' ')))\n    }\n    log.silly('search', 'search completed')\n    log.clearProgress()\n    cb(null, {})\n  })\n}\n    example usagen/a\n\n                move(\n    path.resolve(npm.prefix, PKGLOCK),\n    path.resolve(npm.prefix, SHRINKWRAP),\n    { Promise: BB }\n  ).then(() => {\n    log.notice('', `${PKGLOCK} has been renamed to ${SHRINKWRAP}. ${SHRINKWRAP} will be used for future installations.`)\n    return readFile(path.resolve(npm.prefix, SHRINKWRAP)).then((d) => {\n      return JSON.parse(d)\n    })\n  }, (err) => {\n    if (err.code !== 'ENOENT') {\n      throw err\n    } else {\n      return readPackageTree(npm.localPrefix).then(\n        id.computeMetadata\n      ).then((tree) => {\n        return BB.fromNode((cb) => {\n          createShrinkwrap(tree, {\n            silent,\n            defaultFile: SHRINKWRAP\n          }, cb)\n        })\n      })\n    }\n  }).then((data) => cb(null, data), cb)\n}\n    example usagen/a\n\n            description and source-codefunction star(args, cb) {\n  if (!args.length) return cb(star.usage)\n  var s = npm.config.get('unicode') ? '\\u2605 ' : '(*)'\n  var u = npm.config.get('unicode') ? '\\u2606 ' : '( )'\n  var using = !(npm.command.match(/^un/))\n  if (!using) s = u\n  asyncMap(args, function (pkg, cb) {\n    mapToRegistry(pkg, npm.config, function (er, uri, auth) {\n      if (er) return cb(er)\n\n      var params = {\n        starred: using,\n        auth: auth\n      }\n      npm.registry.star(uri, params, function (er, data, raw, req) {\n        if (!er) {\n          output(s + ' ' + pkg)\n          log.verbose('star', data)\n        }\n        cb(er, data, raw, req)\n      })\n    })\n  }, cb)\n}\n    example usage...\nmapToRegistry(pkg, npm.config, function (er, uri, auth) {\n  if (er) return cb(er)\n\n                                      description and source-codefunction team(args, cb) {\n  // Entities are in the format <scope>:<team>\n  var cmd = args.shift()\n  var entity = (args.shift() || '').split(':')\n  return mapToRegistry('/', npm.config, function (err, uri, auth) {\n    if (err) { return cb(err) }\n    try {\n      return npm.registry.team(cmd, uri, {\n        auth: auth,\n        scope: entity[0],\n        team: entity[1],\n        user: args.shift()\n      }, function (err, data) {\n        !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))\n        cb(err, data)\n      })\n    } catch (e) {\n      cb(e.message + '\\n\\nUsage:\\n' + team.usage)\n    }\n  })\n}\n    example usage...\nfunction team (args, cb) {\n// Entities are in the format <scope>:<team>\nvar cmd = args.shift()\nvar entity = (args.shift() || '').split(':')\nreturn mapToRegistry('/', npm.config, function (err, uri, auth) {\n  if (err) { return cb(err) }\n  try {\n    return npm.registry.team(cmd, uri, {\n      auth: auth,\n      scope: entity[0],\n      team: entity[1],\n      user: args.shift()\n    }, function (err, data) {\n      !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))\n      cb(err, data)\n...\n\n            description and source-codefunction token(args, cb) {\n  log.gauge.show('token')\n  if (args.length === 0) return withCb(list([]), cb)\n  switch (args[0]) {\n    case 'list':\n    case 'ls':\n      withCb(list(), cb)\n      break\n    case 'delete':\n    case 'revoke':\n    case 'remove':\n    case 'rm':\n      withCb(rm(args.slice(1)), cb)\n      break\n    case 'create':\n      withCb(create(args.slice(1)), cb)\n      break\n    default:\n      cb(new Error('Unknown profile command: ' + args[0]))\n  }\n}\n    example usagen/a\n\n                                if (args.length) {\n    new Uninstaller(where, dryrun, args).run(cb)\n  } else {\n    // remove this package from the global space, if it's installed there\n    readJson(path.resolve(npm.localPrefix, 'package.json'), function (er, pkg) {\n      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)\n      if (er) return cb(uninstall.usage)\n      new Uninstaller(where, dryrun, [pkg.name]).run(cb)\n    })\n  }\n}\n    example usagen/a\n\n                log.silly('unpublish', 'args[0]', args[0])\n  log.silly('unpublish', 'thing', thing)\n  if (!version &amp;&amp; !npm.config.get('force')) {\n    return cb(\n      'Refusing to delete entire project.\\n' +\n      'Run with --force to do this.\\n' +\n      unpublish.usage\n    )\n  }\n\n  if (!project || path.resolve(project) === npm.localPrefix) {\n    // if there's a package.json in the current folder, then\n    // read the package name and version out of that.\n    var cwdJson = path.join(npm.localPrefix, 'package.json')\n    return readJson(cwdJson, function (er, data) {\n      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)\n      if (er) return cb('Usage:\\n' + unpublish.usage)\n      log.verbose('unpublish', data)\n      gotProject(data.name, data.version, data.publishConfig, cb)\n    })\n  }\n  return gotProject(project, version, cb)\n}\n    example usage...\nif (\n  err.code === 'EPUBLISHCONFLICT' &amp;&amp;\n  npm.config.get('force') &amp;&amp;\n  !isRetry\n) {\n  log.warn('publish', 'Forced publish over ' + pkg._id)\n  return BB.fromNode((cb) => {\n    npm.commands.unpublish([pkg._id], cb)\n  }).finally(() => {\n    // ignore errors.  Use the force.  Reach out with your feelings.\n    return upload(arg, pkg, true, cached).catch(() => {\n      // but if it fails again, then report the first error.\n      throw err\n    })\n  })\n...\n\n                                  if (local) {\n    var dir = npm.prefix\n    readJson(path.resolve(dir, 'package.json'), function (er, d) {\n      d = d || {}\n      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)\n      if (!d.name) return cb(new Error('Invalid package.json'))\n\n                                    description and source-codefunction access(args, cb) {\n  var cmd = args.shift()\n  var params\n  return parseParams(cmd, args, function (err, p) {\n    if (err) { return cb(err) }\n    params = p\n    return mapToRegistry(params.package, npm.config, invokeCmd)\n  })\n\n  function invokeCmd (err, uri, auth, base) {\n    if (err) { return cb(err) }\n    params.auth = auth\n    try {\n      return npm.registry.access(cmd, uri, params, function (err, data) {\n        if (!err &amp;&amp; data) {\n          output(JSON.stringify(data, undefined, 2))\n        }\n        cb(err, data)\n      })\n    } catch (e) {\n      cb(e.message + '\\n\\nUsage:\\n' + access.usage)\n    }\n  }\n}\n    example usage...\n  return mapToRegistry(params.package, npm.config, invokeCmd)\n})\n\nfunction invokeCmd (err, uri, auth, base) {\n  if (err) { return cb(err) }\n  params.auth = auth\n  try {\n    return npm.registry.access(cmd, uri, params, function (err, data) {\n      if (!err &amp;&amp; data) {\n        output(JSON.stringify(data, undefined, 2))\n      }\n      cb(err, data)\n    })\n  } catch (e) {\n    cb(e.message + '\\n\\nUsage:\\n' + access.usage)\n...\n\n              switch (argv[2]) {\n    case 'grant':\n      if (argv.length === 3) {\n        return cb(null, ['read-only', 'read-write'])\n      } else {\n        return cb(null, [])\n      }\n    case 'public':\n    case 'restricted':\n    case 'ls-packages':\n    case 'ls-collaborators':\n    case 'edit':\n      return cb(null, [])\n    case 'revoke':\n      return cb(null, [])\n    default:\n      return cb(new Error(argv[2] + ' not recognized'))\n  }\n}\n    example usage...\n  npm.config.set(k, parsed[k])\n})\n\n            description and source-codefunction doOne(cmd, staging, pkg, log, next) {\n  validate('SSOOF', arguments)\n  const prepped = prepareAction([cmd, pkg], staging, log)\n  return withInit(actions[cmd], () => {\n    return execAction(prepped)\n  }).nodeify(next)\n}\n    example usagen/a\n\n            description and source-codefunction doParallel(type, staging, actionsToRun, log, next) {\n  validate('SSAOF', arguments)\n  const acts = actionsToRun.reduce((acc, todo) => {\n    if (todo[0] === type) {\n      acc.push(prepareAction(todo, staging, log))\n    }\n    return acc\n  }, [])\n  log.silly('doParallel', type + ' ' + acts.length)\n  time(log)\n  if (!acts.length) { return next() }\n  return withInit(actions[type], () => {\n    return BB.map(acts, execAction, {\n      concurrency: npm.limit.action\n    })\n  }).nodeify((err) => {\n    log.finish()\n    timeEnd(log)\n    next(err)\n  })\n}\n    example usagen/a\n\n            description and source-codefunction doReverseSerial(type, staging, actionsToRun, log, next) {\n  validate('SSAOF', arguments)\n  log.silly('doReverseSerial', '%s %d', type, actionsToRun.length)\n  runSerial(type, staging, [].concat(actionsToRun).reverse(), log, next)\n}\n    example usagen/a\n\n                                  createEntryStream(cachePath, uri, auth, staleness, function (err, entryStream, latest, newEntries) {\n      if (err) return stream.emit('error', err)\n      log.silly('all-package-metadata', 'entry stream created')\n      if (entryStream &amp;&amp; newEntries) {\n        createCacheWriteStream(cachePath, latest, function (err, writeStream) {\n          if (err) return stream.emit('error', err)\n          log.silly('all-package-metadata', 'output stream created')\n          ms.pipeline.obj(entryStream, writeStream, stream)\n        })\n      } else if (entryStream) {\n        ms.pipeline.obj(entryStream, stream)\n      } else {\n        stream.emit('error', new Error('No search sources available'))\n      }\n    })\n  })\n  return stream\n}\n    example usagen/a\n\n            description and source-codefunction createCacheEntryStream(cacheFile, cb) {\n  log.verbose('all-package-metadata', 'creating entry stream from local cache')\n  log.verbose('all-package-metadata', cacheFile)\n  fs.stat(cacheFile, function (err, stat) {\n    if (err) return cb(err)\n    // TODO - This isn't very helpful if `cacheFile` is empty or just `{}`\n    var entryStream = ms.pipeline.obj(\n      fs.createReadStream(cacheFile),\n      jsonstream.parse('*'),\n      // I believe this passthrough is necessary cause `jsonstream` returns\n      // weird custom streams that behave funny sometimes.\n      ms.through.obj()\n    )\n    extractUpdated(entryStream, 'cached-entry-stream', cb)\n  })\n}\n    example usagen/a\n\n            description and source-codefunction createCacheWriteStream(cacheFile, latest, cb) {\n  _ensureCacheDirExists(cacheFile, function (err) {\n    if (err) return cb(err)\n    log.silly('all-package-metadata', 'creating output stream')\n    var outStream = _createCacheOutStream()\n    var cacheFileStream = writeStreamAtomic(cacheFile)\n    var inputStream = _createCacheInStream(cacheFileStream, outStream, latest)\n\n                        description and source-codefunction createEntryStream(cachePath, uri, auth, staleness, cb) {\n  createCacheEntryStream(cachePath, function (err, cacheStream, cacheLatest) {\n    cacheLatest = cacheLatest || 0\n    if (err) {\n      log.warn('', 'Failed to read search cache. Rebuilding')\n      log.silly('all-package-metadata', 'cache read error: ', err)\n    }\n    createEntryUpdateStream(uri, auth, staleness, cacheLatest, function (err, updateStream, updatedLatest) {\n      updatedLatest = updatedLatest || 0\n      var latest = updatedLatest || cacheLatest\n      if (!cacheStream &amp;&amp; !updateStream) {\n        return cb(new Error('No search sources available'))\n      }\n      if (err) {\n        log.warn('', 'Search data request failed, search might be stale')\n        log.silly('all-package-metadata', 'update request error: ', err)\n      }\n      if (cacheStream &amp;&amp; updateStream) {\n        // Deduped, unioned, sorted stream from the combination of both.\n        cb(null,\n          createMergedStream(cacheStream, updateStream),\n          latest,\n          !!updatedLatest)\n      } else {\n        // Either one works if one or the other failed\n        cb(null, cacheStream || updateStream, latest, !!updatedLatest)\n      }\n    })\n  })\n}\n    example usagen/a\n\n            description and source-codefunction createEntryUpdateStream(all, auth, staleness, latest, cb) {\n  log.verbose('all-package-metadata', 'creating remote entry stream')\n  var params = {\n    timeout: 600,\n    follow: true,\n    staleOk: true,\n    auth: auth,\n    streaming: true\n  }\n  var partialUpdate = false\n  if (latest &amp;&amp; (Date.now() - latest < (staleness * 1000))) {\n    // Skip the request altogether if our `latest` isn't stale.\n    log.verbose('all-package-metadata', 'Local data up to date, skipping update')\n    return cb(null)\n  } else if (latest === 0) {\n    log.warn('', 'Building the local index for the first time, please be patient')\n    log.verbose('all-package-metadata', 'No cached data: requesting full metadata db')\n  } else {\n    log.verbose('all-package-metadata', 'Cached data present with timestamp:', latest, 'requesting partial index update')\n    all += '/since?stale=update_after&amp;startkey=' + latest\n    partialUpdate = true\n  }\n  npm.registry.request(all, params, function (er, res) {\n    if (er) return cb(er)\n    log.silly('all-package-metadata', 'request stream opened, code:', res.statusCode)\n    // NOTE - The stream returned by `request` seems to be very persnickety\n    //        and this is almost a magic incantation to get it to work.\n    //        Modify how `res` is used here at your own risk.\n    var entryStream = ms.pipeline.obj(\n      res,\n      ms.through(function (chunk, enc, cb) {\n        cb(null, chunk)\n      }),\n      gunzip(),\n      jsonstream.parse('*', function (pkg, key) {\n        if (key[0] === '_updated' || key[0][0] !== '_') {\n          return pkg\n        }\n      })\n    )\n    if (partialUpdate) {\n      // The `/all/since` endpoint doesn't return `_updated`, so we\n      // just use the request's own timestamp.\n      cb(null, entryStream, Date.parse(res.headers.date))\n    } else {\n      extractUpdated(entryStream, 'entry-update-stream', cb)\n    }\n  })\n}\n    example usagen/a\n\n                                    this.packageLockOnly = opts.packageLockOnly != null\n  ? opts.packageLockOnly : npm.config.get('package-lock-only')\nthis.rollback = opts.rollback != null ? opts.rollback : npm.config.get('rollback')\nthis.link = opts.link != null ? opts.link : npm.config.get('link')\nthis.saveOnlyLock = opts.saveOnlyLock\nthis.global = opts.global != null ? opts.global : this.where === path.resolve(npm.globalDir, '..')\nthis.started = Date.now()\n}\nInstaller.prototype = {}\n\n                var url = d.bugs &amp;&amp; ((typeof d.bugs === 'string') ? d.bugs : d.bugs.url)\n    if (!url) {\n      url = 'https://www.npmjs.org/package/' + d.name\n    }\n    log.silly('bugs', 'url', url)\n    opener(url, { command: npm.config.get('browser') }, cb)\n  })\n}\n    example usagen/a\n\n            description and source-codecompletion = function (opts, cb) {\n  // FIXME: there used to be registry completion here, but it stopped making\n  // sense somewhere around 50,000 packages on the registry\n  cb()\n}\n    example usage...\n  npm.config.set(k, parsed[k])\n})\n\n            description and source-codefunction ci(args, cb) {\n  return new Installer({\n    config: npm.config,\n    log: npmlog\n  })\n  .run()\n  .then(\n    (details) => console.error(`added ${details.pkgCount} packages in ${\n      details.runTime / 1000\n    }s`)\n  )\n  .then(() => cb(), cb)\n}\n    example usagen/a\n\n                          var fs = require('graceful-fs')\n  var path = require('path')\n  var bashExists = null\n  var zshExists = null\n  fs.stat(path.resolve(process.env.HOME, '.bashrc'), function (er) {\n    bashExists = !er\n    next()\n  })\n  fs.stat(path.resolve(process.env.HOME, '.zshrc'), function (er) {\n    zshExists = !er\n    next()\n  })\n  function next () {\n    if (zshExists === null || bashExists === null) return\n    var out = []\n    if (zshExists) out.push('~/.zshrc')\n    if (bashExists) out.push('~/.bashrc')\n    if (opts.w === 2) {\n      out = out.map(function (m) {\n        return ['>>', m]\n      })\n    }\n    cb(null, out)\n  }\n}\n    example usage...\n  npm.config.set(k, parsed[k])\n})\n\n            description and source-codefunction gf() {\n  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {\n    return gf[kDefaultMethod].func.apply(this, arguments)\n  } else {\n    return gf.applyGenfun(this, arguments)\n  }\n}\n    example usage...\n  // now actually fire up npm and run the command.\n  // this is how to use npm programmatically:\n  conf._exit = true\n  npm.load(conf, function (er) {\n    if (er) return errorHandler(er)\n    npm.commands[npm.command](npm.argv, function (err) {\n      // https://www.youtube.com/watch?v=7nfPu8qTiQU\n      if (!err &amp;&amp; npm.config.get('ham-it-up') &amp;&amp; !npm.config\n.get('json') &amp;&amp; !npm.config.get('parseable') &amp;&amp; npm.command !== 'completion') {\n        output('\\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\\n')\n      }\n      errorHandler.apply(this, arguments)\n    })\n  })\n})()\n...\n\n            description and source-codefunction gf() {\n  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {\n    return gf[kDefaultMethod].func.apply(this, arguments)\n  } else {\n    return gf.applyGenfun(this, arguments)\n  }\n}\n    example usage...\n  } catch (e) {\n    return cb(new Error('no such auth module'))\n  }\n  auth.login(creds, registry, scope, function (err, newCreds) {\n    if (err) return cb(err)\n\n                                        description and source-codefunction gf() {\n  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {\n    return gf[kDefaultMethod].func.apply(this, arguments)\n  } else {\n    return gf.applyGenfun(this, arguments)\n  }\n}\n    example usage...\n  // now actually fire up npm and run the command.\n  // this is how to use npm programmatically:\n  conf._exit = true\n  npm.load(conf, function (er) {\n    if (er) return errorHandler(er)\n    npm.commands[npm.command](npm.argv, function (err) {\n      // https://www.youtube.com/watch?v=7nfPu8qTiQU\n      if (!err &amp;&amp; npm.config.get('ham-it-up') &amp;&amp; !npm.config\n.get('json') &amp;&amp; !npm.config.get('parseable') &amp;&amp; npm.command !== 'completion') {\n        output('\\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\\n')\n      }\n      errorHandler.apply(this, arguments)\n    })\n  })\n})()\n...\n\n                        description and source-codefunction gf() {\n  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {\n    return gf[kDefaultMethod].func.apply(this, arguments)\n  } else {\n    return gf.applyGenfun(this, arguments)\n  }\n}\n    example usage...\n  } catch (e) {\n    return cb(new Error('no such auth module'))\n  }\n  auth.login(creds, registry, scope, function (err, newCreds) {\n    if (err) return cb(err)\n\n                                                                                            description and source-codefunction load() {\n  var cli, builtin, cb\n  for (var i = 0; i < arguments.length; i++) {\n    switch (typeof arguments[i]) {\n      case 'string': builtin = arguments[i]; break\n      case 'object': cli = arguments[i]; break\n      case 'function': cb = arguments[i]; break\n    }\n  }\n\n                // now actually fire up npm and run the command.\n// this is how to use npm programmatically:\nconf._exit = true\nnpm.load(conf, function (er) {\n  if (er) return errorHandler(er)\n  npm.commands[npm.command](npm.argv, function (err) {\n    // https://www.youtube.com/watch?v=7nfPu8qTiQU\n    if (!err &amp;&amp; npm.config.get('ham-it-up') &amp;&amp; !npm.config.get('json') &amp;&amp; !npm.config\n.get('parseable') &amp;&amp; npm.command !== 'completion') {\n      output('\\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\\n')\n    }\n    errorHandler.apply(this, arguments)\n...\n\n                          description and source-codefunction dedupe(args, cb) {\n  validate('AF', arguments)\n  // the /path/to/node_modules/..\n  var where = path.resolve(npm.dir, '..')\n  var dryrun = false\n  if (npm.command.match(/^find/)) dryrun = true\n  if (npm.config.get('dry-run')) dryrun = true\n  if (dryrun &amp;&amp; !npm.config.get('json')) npm.config.set('parseable', true)\n\n                                                                description and source-codecompletion = function (opts, cb) {\n  // first, get a list of remote packages this user owns.\n  // once we have a user account, then don't complete anything.\n  if (opts.conf.argv.remain.length > 2) return cb()\n  // get the list of packages by user\n  var path = '/-/by-user/'\n  mapToRegistry(path, npm.config, function (er, uri, c) {\n    if (er) return cb(er)\n\n        var params = {\n      timeout: 60000,\n      auth: c\n    }\n    npm.registry.get(uri + c.username, params, function (er, list) {\n      if (er) return cb()\n      console.error(list)\n      return cb(null, list[c.username])\n    })\n  })\n}\n    example usage...\n  npm.config.set(k, parsed[k])\n})\n\n                                    description and source-codefunction computeMetadata(tree, seen) {\n  if (!seen) seen = new Set()\n  if (!tree || seen.has(tree)) return\n  seen.add(tree)\n  if (tree.parent == null) {\n    resetMetadata(tree)\n    tree.isTop = true\n  }\n  tree.location = flatNameFromTree(tree)\n\n  function findChild (name, spec, kind) {\n    try {\n      var req = childDependencySpecifier(tree, name, spec)\n    } catch (err) {\n      return\n    }\n    var child = findRequirement(tree, req.name, req)\n    if (child) {\n      resolveWithExistingModule(child, tree)\n      return true\n    }\n    return\n  }\n\n  const deps = tree.package.dependencies || {}\n  const reqs = tree.swRequires || {}\n  for (let name of Object.keys(deps)) {\n    if (findChild(name, deps[name])) continue\n    if (name in reqs &amp;&amp; findChild(name, reqs[name])) continue\n    tree.missingDeps[name] = deps[name]\n  }\n  if (tree.isTop) {\n    const devDeps = tree.package.devDependencies || {}\n    for (let name of Object.keys(devDeps)) {\n      if (findChild(name, devDeps[name])) continue\n      tree.missingDevDeps[name] = devDeps[name]\n    }\n  }\n\n                description and source-codefunction computeVersionSpec(tree, child) {\n  validate('OO', arguments)\n  var requested\n  var childReq = child.package._requested\n  if (childReq &amp;&amp; (isNotEmpty(childReq.saveSpec) || (isNotEmpty(childReq.rawSpec) &amp;&amp; isNotEmpty(childReq.fetchSpec)))) {\n    requested = child.package._requested\n  } else if (child.package._from) {\n    requested = npa(child.package._from)\n  } else {\n    requested = npa.resolve(child.package.name, child.package.version)\n  }\n  if (isRegistry(requested)) {\n    var version = child.package.version\n    var rangeDescriptor = ''\n    if (semver.valid(version, true) &amp;&amp;\n        semver.gte(version, '0.1.0', true) &amp;&amp;\n        !npm.config.get('save-exact')) {\n      rangeDescriptor = npm.config.get('save-prefix')\n    }\n    return rangeDescriptor + version\n  } else if (requested.type === 'directory' || requested.type === 'file') {\n    return 'file:' + unixFormatPath(path.relative(tree.path, requested.fetchSpec))\n  } else {\n    return requested.saveSpec || requested.rawSpec\n  }\n}\n    example usagen/a\n\n              function undeletedModuleMatches (child) {\n    return !child.removed &amp;&amp; moduleName(child) === pkg.name\n  }\n  const undeletedMatches = tree.children.filter(undeletedModuleMatches)\n  if (undeletedMatches.length) {\n    // if there's a conflict with another child AT THE SAME level then we're replacing it, so\n    // mark it as removed and continue with resolution normally.\n    if (tree === requiredBy) {\n      undeletedMatches.forEach((pkg) => {\n        if (pkg.fromBundle) reportBundleOverride(pkg, log)\n        removeObsoleteDep(pkg, log)\n      })\n    } else {\n      return null\n    }\n  }\n\n  // If any of the children of this tree have conflicting\n  // binaries then we need to decline to install this package here.\n  var binaryMatches = pkg.bin &amp;&amp; tree.children.some(function (child) {\n    if (child.removed || !child.package.bin) return false\n    return Object.keys(child.package.bin).some(function (bin) {\n      return pkg.bin[bin]\n    })\n  })\n\n    // if this tree location requested the same module then we KNOW it\n  // isn't compatible because if it were findRequirement would have\n  // found that version.\n  var deps = tree.package.dependencies || {}\n  if (!tree.removed &amp;&amp; requiredBy !== tree &amp;&amp; deps[pkg.name]) {\n    return null\n  }\n\n  var devDeps = tree.package.devDependencies || {}\n  if (tree.isTop &amp;&amp; devDeps[pkg.name]) {\n    var requested = childDependencySpecifier(tree, pkg.name, devDeps[pkg.name])\n    if (!doesChildVersionMatch({package: pkg}, requested, tree)) {\n      return null\n    }\n  }\n\n                                let anyFailed = false\n  for (var ii = 0; ii < tree.requiredBy.length; ++ii) {\n    var requireParent = tree.requiredBy[ii]\n    if (failedDependency(requireParent, moduleName(tree), tree)) {\n      anyFailed = true\n    }\n  }\n  return anyFailed\n}\n    example usagen/a\n\n            description and source-codefindRequirement = function (tree, name, requested, requestor) {\n  validate('OSO', [tree, name, requested])\n  if (!requestor) requestor = tree\n  var nameMatch = function (child) {\n    return moduleName(child) === name &amp;&amp; child.parent &amp;&amp; !child.removed\n  }\n  var versionMatch = function (child) {\n    return doesChildVersionMatch(child, requested, requestor)\n  }\n  if (nameMatch(tree)) {\n    // this *is* the module, but it doesn't match the version, so a\n    // new copy will have to be installed\n    return versionMatch(tree) ? tree : null\n  }\n\n  var matches = tree.children.filter(nameMatch)\n  if (matches.length) {\n    matches = matches.filter(versionMatch)\n    // the module exists as a dependent, but the version doesn't match, so\n    // a new copy will have to be installed above here\n    if (matches.length) return matches[0]\n    return null\n  }\n  if (tree.isTop) return null\n  if (!preserveSymlinks() &amp;&amp; /^[.][.][\\\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return null\n  return findRequirement(tree.parent, name, requested, requestor)\n}\n    example usagen/a\n\n            description and source-codegetAllMetadata = function (args, tree, where, next) {\n  asyncMap(args, function (arg, done) {\n    let spec\n    try {\n      spec = npa(arg)\n    } catch (e) {\n      return done(e)\n    }\n    if (spec.type !== 'file' &amp;&amp; spec.type !== 'directory' &amp;&amp; (spec.name == null || spec.rawSpec === '')) {\n      return fs.stat(path.join(arg, 'package.json'), (err) => {\n        if (err) {\n          var version = matchingDep(tree, spec.name)\n          if (version) {\n            try {\n              return fetchPackageMetadata(npa.resolve(spec.name, version), where, done)\n            } catch (e) {\n              return done(e)\n            }\n          } else {\n            return fetchPackageMetadata(spec, where, done)\n          }\n        } else {\n          try {\n            return fetchPackageMetadata(npa('file:' + arg), where, done)\n          } catch (e) {\n            return done(e)\n          }\n        }\n      })\n    } else {\n      return fetchPackageMetadata(spec, where, done)\n    }\n  }, next)\n}\n    example usagen/a\n\n            description and source-codefunction loadDeps(tree, log, next) {\n  validate('OOF', arguments)\n  if (tree.loaded || (tree.parent &amp;&amp; tree.parent.failed) || tree.removed) return andFinishTracker.now(log, next)\n  if (tree.parent) tree.loaded = true\n  if (!tree.package.dependencies) tree.package.dependencies = {}\n  asyncMap(Object.keys(tree.package.dependencies), function (dep, done) {\n    var version = tree.package.dependencies[dep]\n    if (tree.package.optionalDependencies &amp;&amp;\n        tree.package.optionalDependencies[dep] &amp;&amp;\n        !npm.config.get('optional')) {\n      return done()\n    }\n\n                description and source-codeloadDevDeps = function (tree, log, next) {\n  validate('OOF', arguments)\n  if (!tree.package.devDependencies) return andFinishTracker.now(log, next)\n  asyncMap(Object.keys(tree.package.devDependencies), function (dep, done) {\n    // things defined as both dev dependencies and regular dependencies are treated\n    // as the former\n    if (tree.package.dependencies[dep]) return done()\n\n                  function loadExtraneous (tree) {\n    if (seen.has(tree)) return\n    seen.add(tree)\n    for (var child of tree.children) {\n      if (child.loaded) continue\n      resolveWithExistingModule(child, tree)\n      loadExtraneous(child)\n    }\n  }\n  loadExtraneous(tree)\n  log.finish()\n  next()\n}\n    example usagen/a\n\n            description and source-codeloadRequestedDeps = function (args, tree, saveToDependencies, log, next) {\n  validate('AOOF', [args, tree, log, next])\n  asyncMap(args, function (pkg, done) {\n    var depLoaded = andAddParentToErrors(tree, done)\n    resolveWithNewModule(pkg, tree, log.newGroup('loadRequestedDeps'), iferr(depLoaded, function (child, tracker) {\n      validate('OO', arguments)\n      if (npm.config.get('global')) {\n        child.isGlobal = true\n      }\n      var childName = moduleName(child)\n      child.saveSpec = computeVersionSpec(tree, child)\n      child.userRequired = true\n      child.save = getSaveType(tree, child)\n      const types = ['dependencies', 'devDependencies', 'optionalDependencies']\n      if (child.save) {\n        tree.package[child.save][childName] = child.saveSpec\n        // Astute readers might notice that this exact same code exists in\n        // save.js under a different guise. That code is responsible for deps\n        // being removed from the final written `package.json`. The removal in\n        // this function is specifically to prevent \&quot;installed as both X and Y\&quot;\n        // warnings when moving an existing dep between different dep fields.\n        //\n        // Or, try it by removing this loop, and do `npm i -P x &amp;&amp; npm i -D x`\n        for (let saveType of types) {\n          if (child.save !== saveType) {\n            delete tree.package[saveType][childName]\n          }\n        }\n      }\n\n      // For things the user asked to install, that aren't a dependency (or\n      // won't be when we're done), flag it as \&quot;depending\&quot; on the user\n      // themselves, so we don't remove it as a dep that no longer exists\n      var childIsDep = addRequiredDep(tree, child)\n      if (!childIsDep) child.userRequired = true\n      depLoaded(null, child, tracker)\n    }))\n  }, andForEachChild(loadDeps, andFinishTracker(log, next)))\n}\n    example usagen/a\n\n            description and source-codefunction prefetchDeps(tree, deps, log, next) {\n  validate('OOOF', arguments)\n  var skipOptional = !npm.config.get('optional')\n  var seen = new Set()\n  const finished = andFinishTracker(log, next)\n  const fpm = BB.promisify(fetchPackageMetadata)\n  resolveBranchDeps(tree.package, deps).then(\n    () => finished(), finished\n  )\n\n  function resolveBranchDeps (pkg, deps) {\n    return BB.resolve(null).then(() => {\n      var allDependencies = Object.keys(deps).map((dep) => {\n        return npa.resolve(dep, deps[dep])\n      }).filter((dep) => {\n        return isRegistry(dep) &amp;&amp;\n               !seen.has(dep.toString()) &amp;&amp;\n               !findRequirement(tree, dep.name, dep)\n      })\n      if (skipOptional) {\n        var optDeps = pkg.optionalDependencies || {}\n        allDependencies = allDependencies.filter((dep) => !optDeps[dep.name])\n      }\n      return BB.map(allDependencies, (dep) => {\n        seen.add(dep.toString())\n        return fpm(dep, '', {tracker: log.newItem('fetchMetadata')}).then(\n          (pkg) => {\n            return pkg &amp;&amp; pkg.dependencies &amp;&amp; resolveBranchDeps(pkg, pkg.dependencies)\n          },\n          () => null\n        )\n      })\n    })\n  }\n}\n    example usagen/a\n\n            description and source-coderemoveDeps = function (args, tree, saveToDependencies, next) {\n  validate('AOSF|AOZF', [args, tree, saveToDependencies, next])\n  for (let pkg of args) {\n    var pkgName = moduleName(pkg)\n    var toRemove = tree.children.filter(moduleNameMatches(pkgName))\n    var pkgToRemove = toRemove[0] || createChild({package: {name: pkgName}})\n    var saveType = getSaveType(tree, pkg) || 'dependencies'\n    if (tree.isTop &amp;&amp; saveToDependencies) {\n      pkgToRemove.save = saveType\n    }\n    if (tree.package[saveType][pkgName]) {\n      delete tree.package[saveType][pkgName]\n      if (saveType === 'optionalDependencies' &amp;&amp; tree.package.dependencies[pkgName]) {\n        delete tree.package.dependencies[pkgName]\n      }\n    }\n    replaceModuleByPath(tree, 'removedChildren', pkgToRemove)\n    for (let parent of pkgToRemove.requiredBy) {\n      parent.requires = parent.requires.filter((child) => child !== pkgToRemove)\n    }\n    pkgToRemove.requiredBy = pkgToRemove.requiredBy.filter((parent) => parent !== tree)\n    flagAsRemoving(pkgToRemove)\n  }\n  next()\n}\n    example usagen/a\n\n            description and source-coderemoveExtraneous = function (args, tree, next) {\n  for (let pkg of args) {\n    var pkgName = moduleName(pkg)\n    var toRemove = tree.children.filter(moduleNameMatches(pkgName))\n    if (toRemove.length) {\n      removeObsoleteDep(toRemove[0])\n    }\n  }\n  next()\n}\n    example usagen/a\n\n            description and source-codefunction removeObsoleteDep(child, log) {\n  if (child.removed) return\n  child.removed = true\n  if (log) {\n    log.silly('removeObsoleteDep', 'removing ' + packageId(child) +\n      ' from the tree as its been replaced by a newer version or is no longer required')\n  }\n  // remove from physical tree\n  if (child.parent) {\n    child.parent.children = child.parent.children.filter(function (pchild) { return pchild !== child })\n  }\n  // remove from logical tree\n  var requires = child.requires || []\n  requires.forEach(function (requirement) {\n    requirement.requiredBy = requirement.requiredBy.filter(function (reqBy) { return reqBy !== child })\n    // we don't just check requirement.requires because that doesn't account\n    // for circular deps.  isExtraneous does.\n    if (isExtraneous(requirement)) removeObsoleteDep(requirement, log)\n  })\n}\n    example usagen/a\n\n            description and source-codeupdatePhantomChildren = function (current, child) {\n  validate('OO', arguments)\n  while (current &amp;&amp; current !== child.parent) {\n    if (!current.phantomChildren) current.phantomChildren = {}\n    current.phantomChildren[moduleName(child)] = child\n    current = current.parent\n  }\n}\n    example usagen/a\n\n                        description and source-codevalidatePeerDeps = function (tree, onInvalid) {\n  if (!tree.package.peerDependencies) return\n  Object.keys(tree.package.peerDependencies).forEach(function (pkgname) {\n    var version = tree.package.peerDependencies[pkgname]\n    try {\n      var spec = npa.resolve(pkgname, version)\n    } catch (e) {}\n    var match = spec &amp;&amp; findRequirement(tree.parent || tree, pkgname, spec)\n    if (!match) onInvalid(tree, pkgname, version)\n  })\n}\n    example usagen/a\n\n                          // Build our tentative remove list.  We don't add remove actions yet\n  // because we might resuse them as part of a move.\n  Object.keys(flatOldTree).forEach(function (flatname) {\n    if (flatname === '/') return\n    if (flatNewTree[flatname]) return\n    var pkg = flatOldTree[flatname]\n    if (pkg.isInLink &amp;&amp; /^[.][.][/\\\\]/.test(path.relative(newTree.realpath, pkg.realpath))) return\n\n      // generate our add/update/move actions\n  Object.keys(flatNewTree).forEach(function (flatname) {\n    if (flatname === '/') return\n    var pkg = flatNewTree[flatname]\n    var oldPkg = pkg.oldPkg = flatOldTree[flatname]\n    if (oldPkg) {\n      // if the versions are equivalent then we don't need to updateâ€¦ unless\n      // the user explicitly asked us to.\n      if (!pkg.userRequired &amp;&amp; pkgAreEquiv(oldPkg, pkg)) return\n      setAction(differences, 'update', pkg)\n    } else {\n      var name = moduleName(pkg)\n      // find any packages we're removing that share the same name and are equivalent\n      var removing = (toRemoveByName[name] || []).filter((rm) => pkgAreEquiv(rm.pkg, pkg))\n      var bundlesOrFromBundle = pkg.fromBundle || pkg.package.bundleDependencies\n      // if we have any removes that match AND we're not working with a bundle then upgrade to a move\n      if (removing.length &amp;&amp; !bundlesOrFromBundle) {\n        var toMv = removing.shift()\n        toRemoveByName[name] = toRemoveByName[name].filter((rm) => rm !== toMv)\n        pkg.fromPath = toMv.pkg.path\n        setAction(differences, 'move', pkg)\n        delete toRemove[toMv.flatname]\n      // we don't generate add actions for things found in links (which already exist on disk) or\n      // for bundled modules (which will be installed when we install their parent)\n      } else if (!(pkg.isInLink &amp;&amp; pkg.fromBundle)) {\n        setAction(differences, 'add', pkg)\n      }\n    }\n  })\n\n    const includeDev = npm.config.get('dev') ||\n    (!/^prod(uction)?$/.test(npm.config.get('only')) &amp;&amp; !npm.config.get('production')) ||\n    /^dev(elopment)?$/.test(npm.config.get('only')) ||\n    /^dev(elopment)?$/.test(npm.config.get('also'))\n  const includeProd = !/^dev(elopment)?$/.test(npm.config.get('only'))\n  if (!includeProd || !includeDev) {\n    log.silly('diff-trees', 'filtering actions:', 'includeDev', includeDev, 'includeProd', includeProd)\n    differences = differences.filter((diff) => {\n      const pkg = diff[1]\n      const pkgIsOnlyDev = isOnlyDev(pkg)\n      return (!includeProd &amp;&amp; pkgIsOnlyDev) || (includeDev &amp;&amp; pkgIsOnlyDev) || (includeProd &amp;&amp; !pkgIsOnlyDev)\n    })\n  }\n  return differences\n}\n    example usagen/a\n\n                  // We're going to sort the actions taken on top level dependencies first, before\n  // considering the order of transitive deps. Because we're building our list\n  // from the bottom up, this means we will return a list with top level deps LAST.\n  // This is important in terms of keeping installations as consistent as possible\n  // as folks add new dependencies.\n  var toplocs = sortedlocs.filter(function (location) {\n    var mod = actions[location][1]\n    if (!mod.requiredBy) return true\n    // If this module is required by any non-top level module\n    // or by any extraneous module, eg user requested or existing\n    // then we don't want to give this priority sorting.\n    return !mod.requiredBy.some(isNotTopOrExtraneous)\n  })\n\n    function sortByLocation (aa, bb) {\n    return bb.localeCompare(aa)\n  }\n  function sortModuleByLocation (aa, bb) {\n    return sortByLocation(aa &amp;&amp; aa.location, bb &amp;&amp; bb.location)\n  }\n  function sortByDeps (action) {\n    var mod = action[1]\n    if (added[mod.location]) return\n    added[mod.location] = action\n    if (!mod.requiredBy) mod.requiredBy = []\n    mod.requiredBy.sort(sortModuleByLocation).forEach(function (mod) {\n      if (actions[mod.location]) sortByDeps(actions[mod.location])\n    })\n    sorted.unshift(action)\n  }\n\n              description and source-codefunction edit(args, cb) {\n  var p = args[0]\n  if (args.length !== 1 || !p) return cb(edit.usage)\n  var e = npm.config.get('editor')\n  if (!e) {\n    return cb(new Error(\n      \&quot;No editor set.  Set the 'editor' config, or $EDITOR environ.\&quot;\n    ))\n  }\n  p = p.split('/')\n       .join('/node_modules/')\n       .replace(/(\\/node_modules)+/, '/node_modules')\n  var f = path.resolve(npm.dir, p)\n  fs.lstat(f, function (er) {\n    if (er) return cb(er)\n    editor(f, { editor: e }, noProgressTillDone(function (er) {\n      if (er) return cb(er)\n      npm.commands.rebuild(args, cb)\n    }))\n  })\n}\n    example usagen/a\n\n            description and source-codefunction installedShallow(opts, filter, cb) {\n  if (typeof cb !== 'function') {\n    cb = filter\n    filter = null\n  }\n  var conf = opts.conf\n  var args = conf.argv.remain\n  if (args.length > 3) return cb()\n  var local\n  var global\n  var localDir = npm.dir\n  var globalDir = npm.globalDir\n  if (npm.config.get('global')) {\n    local = []\n    next()\n  } else {\n    fs.readdir(localDir, function (er, pkgs) {\n      local = (pkgs || []).filter(function (p) {\n        return p.charAt(0) !== '.'\n      })\n      next()\n    })\n  }\n\n  fs.readdir(globalDir, function (er, pkgs) {\n    global = (pkgs || []).filter(function (p) {\n      return p.charAt(0) !== '.'\n    })\n    next()\n  })\n  function next () {\n    if (!local || !global) return\n    filterInstalled(local, global, filter, cb)\n  }\n}\n    example usage...\n  npm.config.set(k, parsed[k])\n})\n\n            description and source-codefunction errorHandler(er) {\n  log.disableProgress()\n  if (!npm.config || !npm.config.loaded) {\n    // logging won't work unless we pretend that it's ready\n    er = er || new Error('Exit prior to config file resolving.')\n    console.error(er.stack || er.message)\n  }\n\n                var msg = errorMessage(er)\n  msg.summary.concat(msg.detail).forEach(function (errline) {\n    log.error.apply(log, errline)\n  })\n  if (npm.config.get('json')) {\n    var error = {\n      error: {\n        code: er.code,\n        summary: messageText(msg.summary),\n        detail: messageText(msg.detail)\n      }\n    }\n    console.log(JSON.stringify(error, null, 2))\n  }\n\n                  if (rollbacks.length) {\n    chain(rollbacks.map(function (f) {\n      return function (cb) {\n        npm.commands.unbuild([f], true, cb)\n      }\n    }), function (er) {\n      if (er) {\n        log.error('error rolling back', er)\n        if (!code) {\n          errorHandler(er)\n        } else {\n          if (!noLog) writeLogFile()\n          reallyExit(er)\n        }\n      } else {\n        if (!noLog &amp;&amp; code) writeLogFile()\n        reallyExit()\n      }\n    })\n    rollbacks.length = 0\n  } else if (code &amp;&amp; !noLog) {\n    writeLogFile()\n  } else {\n    reallyExit()\n  }\n\n          // Exit directly -- nothing in the CLI should still be running in the\n    // background at this point, and this makes sure anything left dangling\n    // for whatever reason gets thrown away, instead of leaving the CLI open\n    //\n    // Commands that expect long-running actions should just delay `cb()`\n    process.stdout.write('', () => {\n      process.exit(code)\n    })\n  }\n}\n    example usage...\nvar conf = nopt(types, shorthands)\nnpm.argv = conf.argv.remain\nif (npm.deref(npm.argv[0])) npm.command = npm.argv.shift()\nelse conf.usage = true\n\n                                                    var shellArgs = []\n  if (args) {\n    if (isWindowsShell) {\n      var execCmd = escapeExecPath(args.shift())\n      var execArgs = [execCmd].concat(args.map(escapeArg))\n      opts.windowsVerbatimArguments = true\n      shellArgs = ['/d', '/s', '/c'].concat(execArgs)\n    } else {\n      shellArgs.unshift('-c')\n      shellArgs = ['-c', args.map(escapeArg).join(' ').trim()]\n    }\n  }\n\n                      description and source-codefunction installedShallow(opts, filter, cb) {\n  if (typeof cb !== 'function') {\n    cb = filter\n    filter = null\n  }\n  var conf = opts.conf\n  var args = conf.argv.remain\n  if (args.length > 3) return cb()\n  var local\n  var global\n  var localDir = npm.dir\n  var globalDir = npm.globalDir\n  if (npm.config.get('global')) {\n    local = []\n    next()\n  } else {\n    fs.readdir(localDir, function (er, pkgs) {\n      local = (pkgs || []).filter(function (p) {\n        return p.charAt(0) !== '.'\n      })\n      next()\n    })\n  }\n\n  fs.readdir(globalDir, function (er, pkgs) {\n    global = (pkgs || []).filter(function (p) {\n      return p.charAt(0) !== '.'\n    })\n    next()\n  })\n  function next () {\n    if (!local || !global) return\n    filterInstalled(local, global, filter, cb)\n  }\n}\n    example usage...\n  npm.config.set(k, parsed[k])\n})\n\n            description and source-codefunction extract(staging, pkg, log) {\n  log.silly('extract', packageId(pkg))\n  const extractTo = moduleStagingPath(staging, pkg)\n  if (!pacoteOpts) {\n    pacoteOpts = require('../../config/pacote')\n  }\n  const opts = pacoteOpts({\n    integrity: pkg.package._integrity,\n    resolved: pkg.package._resolved\n  })\n  const args = [\n    pkg.package._requested,\n    extractTo,\n    opts\n  ]\n  return BB.fromNode((cb) => {\n    let launcher = localWorker\n    let msg = args\n    const spec = typeof args[0] === 'string' ? npa(args[0]) : args[0]\n    args[0] = spec.raw\n    if (ENABLE_WORKERS &amp;&amp; (isRegistry(spec) || spec.type === 'remote')) {\n      // We can&quot;
}"><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    overflow-wrap: break-word;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://docs.npmjs.com/">npm (v5.8.0)</a>
</h1>
<h4>a package manager for JavaScript</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm">module npm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.access">
            function <span class="apidocSignatureSpan">npm.</span>access
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata">
            function <span class="apidocSignatureSpan">npm.</span>all_package_metadata
            <span class="apidocSignatureSpan">(staleness)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.and_finish_tracker">
            function <span class="apidocSignatureSpan">npm.</span>and_finish_tracker
            <span class="apidocSignatureSpan">(tracker, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.bugs">
            function <span class="apidocSignatureSpan">npm.</span>bugs
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ci">
            function <span class="apidocSignatureSpan">npm.</span>ci
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.completion">
            function <span class="apidocSignatureSpan">npm.</span>completion
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.get">
            function <span class="apidocSignatureSpan">npm.</span>config.get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.set">
            function <span class="apidocSignatureSpan">npm.</span>config.set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toLifecycle">
            function <span class="apidocSignatureSpan">npm.</span>config.toLifecycle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toPacote">
            function <span class="apidocSignatureSpan">npm.</span>config.toPacote
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.dedupe">
            function <span class="apidocSignatureSpan">npm.</span>dedupe
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deprecate">
            function <span class="apidocSignatureSpan">npm.</span>deprecate
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deref">
            function <span class="apidocSignatureSpan">npm.</span>deref
            <span class="apidocSignatureSpan">(c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.diff_trees">
            function <span class="apidocSignatureSpan">npm.</span>diff_trees
            <span class="apidocSignatureSpan">(oldTree, newTree, differences, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.edit">
            function <span class="apidocSignatureSpan">npm.</span>edit
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.error_handler">
            function <span class="apidocSignatureSpan">npm.</span>error_handler
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.exists">
            function <span class="apidocSignatureSpan">npm.</span>exists
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.explore">
            function <span class="apidocSignatureSpan">npm.</span>explore
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.extract">
            function <span class="apidocSignatureSpan">npm.</span>extract
            <span class="apidocSignatureSpan">(staging, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.fetch_package_metadata">
            function <span class="apidocSignatureSpan">npm.</span>fetch_package_metadata
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.finalize">
            function <span class="apidocSignatureSpan">npm.</span>finalize
            <span class="apidocSignatureSpan">(staging, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.flatten_tree">
            function <span class="apidocSignatureSpan">npm.</span>flatten_tree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.help">
            function <span class="apidocSignatureSpan">npm.</span>help
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.install">
            function <span class="apidocSignatureSpan">npm.</span>install
            <span class="apidocSignatureSpan">(where, args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.link">
            function <span class="apidocSignatureSpan">npm.</span>link
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.load">
            function <span class="apidocSignatureSpan">npm.</span>load
            <span class="apidocSignatureSpan">(cli, cb_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ls">
            function <span class="apidocSignatureSpan">npm.</span>ls
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.mutate_into_logical_tree">
            function <span class="apidocSignatureSpan">npm.</span>mutate_into_logical_tree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.owner">
            function <span class="apidocSignatureSpan">npm.</span>owner
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack">
            function <span class="apidocSignatureSpan">npm.</span>pack
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.parse_json">
            function <span class="apidocSignatureSpan">npm.</span>parse_json
            <span class="apidocSignatureSpan">(content)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.profile">
            function <span class="apidocSignatureSpan">npm.</span>profile
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.prune">
            function <span class="apidocSignatureSpan">npm.</span>prune
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.publish">
            function <span class="apidocSignatureSpan">npm.</span>publish
            <span class="apidocSignatureSpan">(args, isRetry, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pulse_till_done">
            function <span class="apidocSignatureSpan">npm.</span>pulse_till_done
            <span class="apidocSignatureSpan">(prefix, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap">
            function <span class="apidocSignatureSpan">npm.</span>read_shrinkwrap
            <span class="apidocSignatureSpan">(child, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.rebuild">
            function <span class="apidocSignatureSpan">npm.</span>rebuild
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.repo">
            function <span class="apidocSignatureSpan">npm.</span>repo
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.restart">
            function <span class="apidocSignatureSpan">npm.</span>restart
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.run_script">
            function <span class="apidocSignatureSpan">npm.</span>run_script
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save_stack">
            function <span class="apidocSignatureSpan">npm.</span>save_stack
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.search">
            function <span class="apidocSignatureSpan">npm.</span>search
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.shrinkwrap">
            function <span class="apidocSignatureSpan">npm.</span>shrinkwrap
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.star">
            function <span class="apidocSignatureSpan">npm.</span>star
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.start">
            function <span class="apidocSignatureSpan">npm.</span>start
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.stop">
            function <span class="apidocSignatureSpan">npm.</span>stop
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.team">
            function <span class="apidocSignatureSpan">npm.</span>team
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.token">
            function <span class="apidocSignatureSpan">npm.</span>token
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unbuild">
            function <span class="apidocSignatureSpan">npm.</span>unbuild
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.uninstall">
            function <span class="apidocSignatureSpan">npm.</span>uninstall
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unpublish">
            function <span class="apidocSignatureSpan">npm.</span>unpublish
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.validate_args">
            function <span class="apidocSignatureSpan">npm.</span>validate_args
            <span class="apidocSignatureSpan">(idealTree, args, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.view">
            function <span class="apidocSignatureSpan">npm.</span>view
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.writable">
            function <span class="apidocSignatureSpan">npm.</span>writable
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">npm.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">npm.</span>lockfileVersion</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>actions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>argv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>commands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>core</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>deps</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>fetch_opts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>fullList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>legacy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>limit</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>locker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>metrics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>no_progress_while_running</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>node</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>oauth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>read_user_info</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>rollbacks</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>saml</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>save</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>save_stack.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>sso</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>umask</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>unsupported</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.</span>command</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.</span>name</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.access">module npm.access</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.access.access">
            function <span class="apidocSignatureSpan">npm.</span>access
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.access.completion">
            function <span class="apidocSignatureSpan">npm.access.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.access.</span>subcommands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.access.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.actions">module npm.actions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.actions.doOne">
            function <span class="apidocSignatureSpan">npm.actions.</span>doOne
            <span class="apidocSignatureSpan">(cmd, staging, pkg, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.actions.doParallel">
            function <span class="apidocSignatureSpan">npm.actions.</span>doParallel
            <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.actions.doReverseSerial">
            function <span class="apidocSignatureSpan">npm.actions.</span>doReverseSerial
            <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.actions.doSerial">
            function <span class="apidocSignatureSpan">npm.actions.</span>doSerial
            <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.</span>actions</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.all_package_metadata">module npm.all_package_metadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata.all_package_metadata">
            function <span class="apidocSignatureSpan">npm.</span>all_package_metadata
            <span class="apidocSignatureSpan">(staleness)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createCacheEntryStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createCacheEntryStream
            <span class="apidocSignatureSpan">(cacheFile, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createCacheWriteStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createCacheWriteStream
            <span class="apidocSignatureSpan">(cacheFile, latest, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createEntryStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createEntryStream
            <span class="apidocSignatureSpan">(cachePath, uri, auth, staleness, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createEntryUpdateStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createEntryUpdateStream
            <span class="apidocSignatureSpan">(all, auth, staleness, latest, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.all_package_metadata._createMergedStream">
            function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createMergedStream
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.and_finish_tracker">module npm.and_finish_tracker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.and_finish_tracker.and_finish_tracker">
            function <span class="apidocSignatureSpan">npm.</span>and_finish_tracker
            <span class="apidocSignatureSpan">(tracker, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.and_finish_tracker.now">
            function <span class="apidocSignatureSpan">npm.and_finish_tracker.</span>now
            <span class="apidocSignatureSpan">(tracker, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.bugs">module npm.bugs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.bugs.bugs">
            function <span class="apidocSignatureSpan">npm.</span>bugs
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.bugs.completion">
            function <span class="apidocSignatureSpan">npm.bugs.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.bugs.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.ci">module npm.ci</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ci.ci">
            function <span class="apidocSignatureSpan">npm.</span>ci
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ci.completion">
            function <span class="apidocSignatureSpan">npm.ci.</span>completion
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.ci.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.completion">module npm.completion</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.completion.completion">
            function <span class="apidocSignatureSpan">npm.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.completion.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.config">module npm.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">npm.config.</span>loaded</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.get">
            function <span class="apidocSignatureSpan">npm.config.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.set">
            function <span class="apidocSignatureSpan">npm.config.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toLifecycle">
            function <span class="apidocSignatureSpan">npm.config.</span>toLifecycle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toPacote">
            function <span class="apidocSignatureSpan">npm.config.</span>toPacote
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.config.get">module npm.config.get</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.get.get">
            function <span class="apidocSignatureSpan">npm.config.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.get.duck">
            function <span class="apidocSignatureSpan">npm.config.get.</span>duck
            <span class="apidocSignatureSpan">(thisType, argTypes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.config.set">module npm.config.set</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.set.set">
            function <span class="apidocSignatureSpan">npm.config.</span>set
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.set.duck">
            function <span class="apidocSignatureSpan">npm.config.set.</span>duck
            <span class="apidocSignatureSpan">(thisType, argTypes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.config.toLifecycle">module npm.config.toLifecycle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toLifecycle.toLifecycle">
            function <span class="apidocSignatureSpan">npm.config.</span>toLifecycle
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toLifecycle.duck">
            function <span class="apidocSignatureSpan">npm.config.toLifecycle.</span>duck
            <span class="apidocSignatureSpan">(thisType, argTypes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.config.toPacote">module npm.config.toPacote</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toPacote.toPacote">
            function <span class="apidocSignatureSpan">npm.config.</span>toPacote
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.config.toPacote.duck">
            function <span class="apidocSignatureSpan">npm.config.toPacote.</span>duck
            <span class="apidocSignatureSpan">(thisType, argTypes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.core">module npm.core</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">npm.core.</span>loaded</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">npm.core.</span>usingBuiltin</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.core.Conf">
            function <span class="apidocSignatureSpan">npm.core.</span>Conf
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.core.load">
            function <span class="apidocSignatureSpan">npm.core.</span>load
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.core.validate">
            function <span class="apidocSignatureSpan">npm.core.</span>validate
            <span class="apidocSignatureSpan">(cl)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.core.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.core.</span>defs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.core.</span>rootConf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.core.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.dedupe">module npm.dedupe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.dedupe.dedupe">
            function <span class="apidocSignatureSpan">npm.</span>dedupe
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.dedupe.Deduper">
            function <span class="apidocSignatureSpan">npm.dedupe.</span>Deduper
            <span class="apidocSignatureSpan">(where, dryrun)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.dedupe.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.defaults">module npm.defaults</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.defaults.Umask">
            function <span class="apidocSignatureSpan">npm.defaults.</span>Umask
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.defaults.</span>shorthands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.defaults.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.deprecate">module npm.deprecate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deprecate.deprecate">
            function <span class="apidocSignatureSpan">npm.</span>deprecate
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deprecate.completion">
            function <span class="apidocSignatureSpan">npm.deprecate.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.deprecate.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.deps">module npm.deps</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps._replaceModuleByName">
            function <span class="apidocSignatureSpan">npm.deps.</span>_replaceModuleByName
            <span class="apidocSignatureSpan">(obj, key, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps._replaceModuleByPath">
            function <span class="apidocSignatureSpan">npm.deps.</span>_replaceModuleByPath
            <span class="apidocSignatureSpan">(obj, key, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.computeMetadata">
            function <span class="apidocSignatureSpan">npm.deps.</span>computeMetadata
            <span class="apidocSignatureSpan">(tree, seen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.computeVersionSpec">
            function <span class="apidocSignatureSpan">npm.deps.</span>computeVersionSpec
            <span class="apidocSignatureSpan">(tree, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.earliestInstallable">
            function <span class="apidocSignatureSpan">npm.deps.</span>earliestInstallable
            <span class="apidocSignatureSpan">(requiredBy, tree, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.failedDependency">
            function <span class="apidocSignatureSpan">npm.deps.</span>failedDependency
            <span class="apidocSignatureSpan">(tree, name, pkg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.findRequirement">
            function <span class="apidocSignatureSpan">npm.deps.</span>findRequirement
            <span class="apidocSignatureSpan">(tree, name, requested, requestor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.getAllMetadata">
            function <span class="apidocSignatureSpan">npm.deps.</span>getAllMetadata
            <span class="apidocSignatureSpan">(args, tree, where, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.loadDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>loadDeps
            <span class="apidocSignatureSpan">(tree, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.loadDevDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>loadDevDeps
            <span class="apidocSignatureSpan">(tree, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.loadExtraneous">
            function <span class="apidocSignatureSpan">npm.deps.</span>loadExtraneous
            <span class="apidocSignatureSpan">(tree, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.loadRequestedDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>loadRequestedDeps
            <span class="apidocSignatureSpan">(args, tree, saveToDependencies, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.prefetchDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>prefetchDeps
            <span class="apidocSignatureSpan">(tree, deps, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.removeDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>removeDeps
            <span class="apidocSignatureSpan">(args, tree, saveToDependencies, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.removeExtraneous">
            function <span class="apidocSignatureSpan">npm.deps.</span>removeExtraneous
            <span class="apidocSignatureSpan">(args, tree, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.removeObsoleteDep">
            function <span class="apidocSignatureSpan">npm.deps.</span>removeObsoleteDep
            <span class="apidocSignatureSpan">(child, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.updatePhantomChildren">
            function <span class="apidocSignatureSpan">npm.deps.</span>updatePhantomChildren
            <span class="apidocSignatureSpan">(current, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.validateAllPeerDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>validateAllPeerDeps
            <span class="apidocSignatureSpan">(tree, onInvalid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.deps.validatePeerDeps">
            function <span class="apidocSignatureSpan">npm.deps.</span>validatePeerDeps
            <span class="apidocSignatureSpan">(tree, onInvalid)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.diff_trees">module npm.diff_trees</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.diff_trees.diff_trees">
            function <span class="apidocSignatureSpan">npm.</span>diff_trees
            <span class="apidocSignatureSpan">(oldTree, newTree, differences, log, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.diff_trees._diffTrees">
            function <span class="apidocSignatureSpan">npm.diff_trees.</span>_diffTrees
            <span class="apidocSignatureSpan">(oldTree, newTree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.diff_trees.sortActions">
            function <span class="apidocSignatureSpan">npm.diff_trees.</span>sortActions
            <span class="apidocSignatureSpan">(differences)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.edit">module npm.edit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.edit.edit">
            function <span class="apidocSignatureSpan">npm.</span>edit
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.edit.completion">
            function <span class="apidocSignatureSpan">npm.edit.</span>completion
            <span class="apidocSignatureSpan">(opts, filter, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.edit.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.error_handler">module npm.error_handler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.error_handler.error_handler">
            function <span class="apidocSignatureSpan">npm.</span>error_handler
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.error_handler.exit">
            function <span class="apidocSignatureSpan">npm.error_handler.</span>exit
            <span class="apidocSignatureSpan">(code, noLog)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.exists">module npm.exists</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.exists.exists">
            function <span class="apidocSignatureSpan">npm.</span>exists
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.exists.fsAccessImplementation">
            function <span class="apidocSignatureSpan">npm.exists.</span>fsAccessImplementation
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.exists.fsStatImplementation">
            function <span class="apidocSignatureSpan">npm.exists.</span>fsStatImplementation
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.explore">module npm.explore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.explore.explore">
            function <span class="apidocSignatureSpan">npm.</span>explore
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.explore.completion">
            function <span class="apidocSignatureSpan">npm.explore.</span>completion
            <span class="apidocSignatureSpan">(opts, filter, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.explore.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.extract">module npm.extract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.extract.extract">
            function <span class="apidocSignatureSpan">npm.</span>extract
            <span class="apidocSignatureSpan">(staging, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.extract.init">
            function <span class="apidocSignatureSpan">npm.extract.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.extract.teardown">
            function <span class="apidocSignatureSpan">npm.extract.</span>teardown
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.fetch_opts">module npm.fetch_opts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.fetch_opts.fromPacote">
            function <span class="apidocSignatureSpan">npm.fetch_opts.</span>fromPacote
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.fetch_package_metadata">module npm.fetch_package_metadata</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.fetch_package_metadata.fetch_package_metadata">
            function <span class="apidocSignatureSpan">npm.</span>fetch_package_metadata
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.fetch_package_metadata.addBundled">
            function <span class="apidocSignatureSpan">npm.fetch_package_metadata.</span>addBundled
            <span class="apidocSignatureSpan">(pkg, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.finalize">module npm.finalize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.finalize.finalize">
            function <span class="apidocSignatureSpan">npm.</span>finalize
            <span class="apidocSignatureSpan">(staging, pkg, log)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.finalize.rollback">
            function <span class="apidocSignatureSpan">npm.finalize.</span>rollback
            <span class="apidocSignatureSpan">(top, staging, pkg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.flatten_tree">module npm.flatten_tree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.flatten_tree.flatten_tree">
            function <span class="apidocSignatureSpan">npm.</span>flatten_tree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.flatten_tree.flatName">
            function <span class="apidocSignatureSpan">npm.flatten_tree.</span>flatName
            <span class="apidocSignatureSpan">(path, child)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.flatten_tree.flatNameFromTree">
            function <span class="apidocSignatureSpan">npm.flatten_tree.</span>flatNameFromTree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.help">module npm.help</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.help.help">
            function <span class="apidocSignatureSpan">npm.</span>help
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.help.completion">
            function <span class="apidocSignatureSpan">npm.help.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.install">module npm.install</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.install.install">
            function <span class="apidocSignatureSpan">npm.</span>install
            <span class="apidocSignatureSpan">(where, args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.install.Installer">
            function <span class="apidocSignatureSpan">npm.install.</span>Installer
            <span class="apidocSignatureSpan">(where, dryrun, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.install.completion">
            function <span class="apidocSignatureSpan">npm.install.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.install.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.legacy">module npm.legacy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.legacy.login">
            function <span class="apidocSignatureSpan">npm.legacy.</span>login
            <span class="apidocSignatureSpan">(creds, registry, scope, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.link">module npm.link</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.link.link">
            function <span class="apidocSignatureSpan">npm.</span>link
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.link.completion">
            function <span class="apidocSignatureSpan">npm.link.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.link.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.locker">module npm.locker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.locker.lock">
            function <span class="apidocSignatureSpan">npm.locker.</span>lock
            <span class="apidocSignatureSpan">(base, name, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.locker.unlock">
            function <span class="apidocSignatureSpan">npm.locker.</span>unlock
            <span class="apidocSignatureSpan">(base, name, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.ls">module npm.ls</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ls.ls">
            function <span class="apidocSignatureSpan">npm.</span>ls
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ls.completion">
            function <span class="apidocSignatureSpan">npm.ls.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.ls.fromTree">
            function <span class="apidocSignatureSpan">npm.ls.</span>fromTree
            <span class="apidocSignatureSpan">(dir, physicalTree, args, silent, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.ls.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.metrics">module npm.metrics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.metrics.save">
            function <span class="apidocSignatureSpan">npm.metrics.</span>save
            <span class="apidocSignatureSpan">(itWorked)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.metrics.send">
            function <span class="apidocSignatureSpan">npm.metrics.</span>send
            <span class="apidocSignatureSpan">(metricsFile, metricsRegistry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.metrics.start">
            function <span class="apidocSignatureSpan">npm.metrics.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.metrics.stop">
            function <span class="apidocSignatureSpan">npm.metrics.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.mutate_into_logical_tree">module npm.mutate_into_logical_tree</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.mutate_into_logical_tree.mutate_into_logical_tree">
            function <span class="apidocSignatureSpan">npm.</span>mutate_into_logical_tree
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.mutate_into_logical_tree.asReadInstalled">
            function <span class="apidocSignatureSpan">npm.mutate_into_logical_tree.</span>asReadInstalled
            <span class="apidocSignatureSpan">(tree)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.no_progress_while_running">module npm.no_progress_while_running</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.no_progress_while_running.startRunning">
            function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>startRunning
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.no_progress_while_running.stopRunning">
            function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>stopRunning
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.no_progress_while_running.tillDone">
            function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>tillDone
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.node">module npm.node</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.node.create">
            function <span class="apidocSignatureSpan">npm.node.</span>create
            <span class="apidocSignatureSpan">(node, template, isNotTop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.node.reset">
            function <span class="apidocSignatureSpan">npm.node.</span>reset
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.oauth">module npm.oauth</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.oauth.login">
            function <span class="apidocSignatureSpan">npm.oauth.</span>login
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.owner">module npm.owner</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.owner.owner">
            function <span class="apidocSignatureSpan">npm.</span>owner
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.owner.completion">
            function <span class="apidocSignatureSpan">npm.owner.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.owner.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.pack">module npm.pack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.pack">
            function <span class="apidocSignatureSpan">npm.</span>pack
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.completion">
            function <span class="apidocSignatureSpan">npm.pack.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.packDirectory">
            function <span class="apidocSignatureSpan">npm.pack.</span>packDirectory
            <span class="apidocSignatureSpan">(mani, dir, target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.packGitDep">
            function <span class="apidocSignatureSpan">npm.pack.</span>packGitDep
            <span class="apidocSignatureSpan">(manifest, dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pack.prepareDirectory">
            function <span class="apidocSignatureSpan">npm.pack.</span>prepareDirectory
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.pack.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.parse_json">module npm.parse_json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.parse_json.parse_json">
            function <span class="apidocSignatureSpan">npm.</span>parse_json
            <span class="apidocSignatureSpan">(content)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.parse_json.noExceptions">
            function <span class="apidocSignatureSpan">npm.parse_json.</span>noExceptions
            <span class="apidocSignatureSpan">(content)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.profile">module npm.profile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.profile.profile">
            function <span class="apidocSignatureSpan">npm.</span>profile
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.profile.completion">
            function <span class="apidocSignatureSpan">npm.profile.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.profile.</span>subcommands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.profile.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.prune">module npm.prune</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.prune.prune">
            function <span class="apidocSignatureSpan">npm.</span>prune
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.prune.Pruner">
            function <span class="apidocSignatureSpan">npm.prune.</span>Pruner
            <span class="apidocSignatureSpan">(where, dryrun, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.prune.completion">
            function <span class="apidocSignatureSpan">npm.prune.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.prune.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.publish">module npm.publish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.publish.publish">
            function <span class="apidocSignatureSpan">npm.</span>publish
            <span class="apidocSignatureSpan">(args, isRetry, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.publish.completion">
            function <span class="apidocSignatureSpan">npm.publish.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.publish.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.pulse_till_done">module npm.pulse_till_done</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pulse_till_done.pulse_till_done">
            function <span class="apidocSignatureSpan">npm.</span>pulse_till_done
            <span class="apidocSignatureSpan">(prefix, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.pulse_till_done.withPromise">
            function <span class="apidocSignatureSpan">npm.pulse_till_done.</span>withPromise
            <span class="apidocSignatureSpan">(prefix, promise)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.read_shrinkwrap">module npm.read_shrinkwrap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap.read_shrinkwrap">
            function <span class="apidocSignatureSpan">npm.</span>read_shrinkwrap
            <span class="apidocSignatureSpan">(child, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap._isDiff">
            function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>_isDiff
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap._parsePkgLock">
            function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>_parsePkgLock
            <span class="apidocSignatureSpan">(str, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_shrinkwrap.andInflate">
            function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>andInflate
            <span class="apidocSignatureSpan">(child, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.read_user_info">module npm.read_user_info</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_user_info.email">
            function <span class="apidocSignatureSpan">npm.read_user_info.</span>email
            <span class="apidocSignatureSpan">(msg, email, opts, isRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_user_info.otp">
            function <span class="apidocSignatureSpan">npm.read_user_info.</span>otp
            <span class="apidocSignatureSpan">(msg, otp, isRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_user_info.password">
            function <span class="apidocSignatureSpan">npm.read_user_info.</span>password
            <span class="apidocSignatureSpan">(msg, password, isRetry)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.read_user_info.username">
            function <span class="apidocSignatureSpan">npm.read_user_info.</span>username
            <span class="apidocSignatureSpan">(msg, username, opts, isRetry)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.rebuild">module npm.rebuild</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.rebuild.rebuild">
            function <span class="apidocSignatureSpan">npm.</span>rebuild
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.rebuild.completion">
            function <span class="apidocSignatureSpan">npm.rebuild.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.rebuild.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.repo">module npm.repo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.repo.repo">
            function <span class="apidocSignatureSpan">npm.</span>repo
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.repo.completion">
            function <span class="apidocSignatureSpan">npm.repo.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.repo.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.restart">module npm.restart</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.restart.restart">
            function <span class="apidocSignatureSpan">npm.</span>restart
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.restart.completion">
            function <span class="apidocSignatureSpan">npm.restart.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.restart.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.run_script">module npm.run_script</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.run_script.run_script">
            function <span class="apidocSignatureSpan">npm.</span>run_script
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.run_script.completion">
            function <span class="apidocSignatureSpan">npm.run_script.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.run_script.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.saml">module npm.saml</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.saml.login">
            function <span class="apidocSignatureSpan">npm.saml.</span>login
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.save">module npm.save</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save.getSaveType">
            function <span class="apidocSignatureSpan">npm.save.</span>getSaveType
            <span class="apidocSignatureSpan">(tree, arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save.saveRequested">
            function <span class="apidocSignatureSpan">npm.save.</span>saveRequested
            <span class="apidocSignatureSpan">(tree, andReturn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save.saveShrinkwrap">
            function <span class="apidocSignatureSpan">npm.save.</span>saveShrinkwrap
            <span class="apidocSignatureSpan">(tree, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.save_stack">module npm.save_stack</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save_stack.save_stack">
            function <span class="apidocSignatureSpan">npm.</span>save_stack
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save_stack.super_">
            function <span class="apidocSignatureSpan">npm.save_stack.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.save_stack.prototype">module npm.save_stack.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.save_stack.prototype.completeWith">
            function <span class="apidocSignatureSpan">npm.save_stack.prototype.</span>completeWith
            <span class="apidocSignatureSpan">(er)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.search">module npm.search</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.search.search">
            function <span class="apidocSignatureSpan">npm.</span>search
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.search.completion">
            function <span class="apidocSignatureSpan">npm.search.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.search.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.shrinkwrap">module npm.shrinkwrap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.shrinkwrap.shrinkwrap">
            function <span class="apidocSignatureSpan">npm.</span>shrinkwrap
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.shrinkwrap.createShrinkwrap">
            function <span class="apidocSignatureSpan">npm.shrinkwrap.</span>createShrinkwrap
            <span class="apidocSignatureSpan">(tree, opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.shrinkwrap.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.sso">module npm.sso</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.sso.login">
            function <span class="apidocSignatureSpan">npm.sso.</span>login
            <span class="apidocSignatureSpan">(creds, registry, scope, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.star">module npm.star</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.star.star">
            function <span class="apidocSignatureSpan">npm.</span>star
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.star.completion">
            function <span class="apidocSignatureSpan">npm.star.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.star.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.start">module npm.start</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.start.start">
            function <span class="apidocSignatureSpan">npm.</span>start
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.start.completion">
            function <span class="apidocSignatureSpan">npm.start.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.start.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.stop">module npm.stop</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.stop.stop">
            function <span class="apidocSignatureSpan">npm.</span>stop
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.stop.completion">
            function <span class="apidocSignatureSpan">npm.stop.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.stop.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.team">module npm.team</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.team.team">
            function <span class="apidocSignatureSpan">npm.</span>team
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.team.completion">
            function <span class="apidocSignatureSpan">npm.team.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.team.</span>subcommands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.team.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.token">module npm.token</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.token.token">
            function <span class="apidocSignatureSpan">npm.</span>token
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.token._validateCIDRList">
            function <span class="apidocSignatureSpan">npm.token.</span>_validateCIDRList
            <span class="apidocSignatureSpan">(cidrs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.token.completion">
            function <span class="apidocSignatureSpan">npm.token.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">npm.token.</span>subcommands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.token.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.umask">module npm.umask</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.umask.fromString">
            function <span class="apidocSignatureSpan">npm.umask.</span>fromString
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.umask.toString">
            function <span class="apidocSignatureSpan">npm.umask.</span>toString
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.umask.validate">
            function <span class="apidocSignatureSpan">npm.umask.</span>validate
            <span class="apidocSignatureSpan">(data, k, val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.unbuild">module npm.unbuild</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unbuild.unbuild">
            function <span class="apidocSignatureSpan">npm.</span>unbuild
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unbuild.rmStuff">
            function <span class="apidocSignatureSpan">npm.unbuild.</span>rmStuff
            <span class="apidocSignatureSpan">(pkg, folder, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.unbuild.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.uninstall">module npm.uninstall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.uninstall.uninstall">
            function <span class="apidocSignatureSpan">npm.</span>uninstall
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.uninstall.Uninstaller">
            function <span class="apidocSignatureSpan">npm.uninstall.</span>Uninstaller
            <span class="apidocSignatureSpan">(where, dryrun, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.uninstall.completion">
            function <span class="apidocSignatureSpan">npm.uninstall.</span>completion
            <span class="apidocSignatureSpan">(opts, filter, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.uninstall.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.unpublish">module npm.unpublish</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unpublish.unpublish">
            function <span class="apidocSignatureSpan">npm.</span>unpublish
            <span class="apidocSignatureSpan">(args, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unpublish.completion">
            function <span class="apidocSignatureSpan">npm.unpublish.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.unpublish.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.unsupported">module npm.unsupported</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unsupported.checkForBrokenNode">
            function <span class="apidocSignatureSpan">npm.unsupported.</span>checkForBrokenNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unsupported.checkForUnsupportedNode">
            function <span class="apidocSignatureSpan">npm.unsupported.</span>checkForUnsupportedNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.unsupported.checkVersion">
            function <span class="apidocSignatureSpan">npm.unsupported.</span>checkVersion
            <span class="apidocSignatureSpan">(version)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.validate_args">module npm.validate_args</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.validate_args.validate_args">
            function <span class="apidocSignatureSpan">npm.</span>validate_args
            <span class="apidocSignatureSpan">(idealTree, args, next)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.validate_args.isInstallable">
            function <span class="apidocSignatureSpan">npm.validate_args.</span>isInstallable
            <span class="apidocSignatureSpan">(pkg, next)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.view">module npm.view</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.view.view">
            function <span class="apidocSignatureSpan">npm.</span>view
            <span class="apidocSignatureSpan">(args, silent, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.view.completion">
            function <span class="apidocSignatureSpan">npm.view.</span>completion
            <span class="apidocSignatureSpan">(opts, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">npm.view.</span>usage</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.npm.writable">module npm.writable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.writable.writable">
            function <span class="apidocSignatureSpan">npm.</span>writable
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.writable.fsAccessImplementation">
            function <span class="apidocSignatureSpan">npm.writable.</span>fsAccessImplementation
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.npm.writable.fsOpenImplementation">
            function <span class="apidocSignatureSpan">npm.writable.</span>fsOpenImplementation
            <span class="apidocSignatureSpan">(dir, done)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm" id="apidoc.module.npm">module npm</a></h1>


    <h2>
        <a href="#apidoc.element.npm.access" id="apidoc.element.npm.access">
        function <span class="apidocSignatureSpan">npm.</span>access
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function access(args, cb) {
  var cmd = args.shift()
  var params
  return parseParams(cmd, args, function (err, p) {
    if (err) { return cb(err) }
    params = p
    return mapToRegistry(params.package, npm.config, invokeCmd)
  })

  function invokeCmd (err, uri, auth, base) {
    if (err) { return cb(err) }
    params.auth = auth
    try {
      return npm.registry.access(cmd, uri, params, function (err, data) {
        if (!err &amp;&amp; data) {
          output(JSON.stringify(data, undefined, 2))
        }
        cb(err, data)
      })
    } catch (e) {
      cb(e.message + '\n\nUsage:\n' + access.usage)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return mapToRegistry(params.package, npm.config, invokeCmd)
})

function invokeCmd (err, uri, auth, base) {
  if (err) { return cb(err) }
  params.auth = auth
  try {
    return npm.registry.<span class="apidocCodeKeywordSpan">access</span>(cmd, uri, params, function (err, data) {
      if (!err &amp;&amp; data) {
        output(JSON.stringify(data, undefined, 2))
      }
      cb(err, data)
    })
  } catch (e) {
    cb(e.message + '\n\nUsage:\n' + access.usage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata" id="apidoc.element.npm.all_package_metadata">
        function <span class="apidocSignatureSpan">npm.</span>all_package_metadata
        <span class="apidocSignatureSpan">(staleness)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allPackageMetadata(staleness) {
  var stream = ms.through.obj()

  mapToRegistry('-/all', npm.config, function (er, uri, auth) {
    if (er) return stream.emit('error', er)

    var cacheBase = cacheFile(npm.config.get('cache'))(uri)
    var cachePath = path.join(cacheBase, '.cache.json')

    createEntryStream(cachePath, uri, auth, staleness, function (err, entryStream, latest, newEntries) {
      if (err) return stream.emit('error', err)
      log.silly('all-package-metadata', 'entry stream created')
      if (entryStream &amp;&amp; newEntries) {
        createCacheWriteStream(cachePath, latest, function (err, writeStream) {
          if (err) return stream.emit('error', err)
          log.silly('all-package-metadata', 'output stream created')
          ms.pipeline.obj(entryStream, writeStream, stream)
        })
      } else if (entryStream) {
        ms.pipeline.obj(entryStream, stream)
      } else {
        stream.emit('error', new Error('No search sources available'))
      }
    })
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.and_finish_tracker" id="apidoc.element.npm.and_finish_tracker">
        function <span class="apidocSignatureSpan">npm.</span>and_finish_tracker
        <span class="apidocSignatureSpan">(tracker, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and_finish_tracker = function (tracker, cb) {
  validate('OF', [tracker, cb])
  return function () {
    tracker.finish()
    cb.apply(null, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.bugs" id="apidoc.element.npm.bugs">
        function <span class="apidocSignatureSpan">npm.</span>bugs
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bugs(args, cb) {
  var n = args.length ? args[0] : '.'
  fetchPackageMetadata(n, '.', {fullMetadata: true}, function (er, d) {
    if (er) return cb(er)

    var url = d.bugs &amp;&amp; ((typeof d.bugs === 'string') ? d.bugs : d.bugs.url)
    if (!url) {
      url = 'https://www.npmjs.org/package/' + d.name
    }
    log.silly('bugs', 'url', url)
    opener(url, { command: npm.config.get('browser') }, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ci" id="apidoc.element.npm.ci">
        function <span class="apidocSignatureSpan">npm.</span>ci
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ci(args, cb) {
  return new Installer({
    config: npm.config,
    log: npmlog
  })
  .run()
  .then(
    (details) =&gt; console.error(`added ${details.pkgCount} packages in ${
      details.runTime / 1000
    }s`)
  )
  .then(() =&gt; cb(), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.completion" id="apidoc.element.npm.completion">
        function <span class="apidocSignatureSpan">npm.</span>completion
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function completion(args, cb) {
  if (isWindowsShell) {
    var e = new Error('npm completion supported only in MINGW / Git bash on Windows')
    e.code = 'ENOTSUP'
    e.errno = require('constants').ENOTSUP
    return cb(e)
  }

  // if the COMP_* isn't in the env, then just dump the script.
  if (process.env.COMP_CWORD === undefined ||
      process.env.COMP_LINE === undefined ||
      process.env.COMP_POINT === undefined) {
    return dumpScript(cb)
  }

  console.error(process.env.COMP_CWORD)
  console.error(process.env.COMP_LINE)
  console.error(process.env.COMP_POINT)

  // get the partial line and partial word,
  // if the point isn't at the end.
  // ie, tabbing at: npm foo b|ar
  var w = +process.env.COMP_CWORD
  var words = args.map(unescape)
  var word = words[w]
  var line = process.env.COMP_LINE
  var point = +process.env.COMP_POINT
  var partialLine = line.substr(0, point)
  var partialWords = words.slice(0, w)

  // figure out where in that last word the point is.
  var partialWord = args[w]
  var i = partialWord.length
  while (partialWord.substr(0, i) !== partialLine.substr(-1 * i) &amp;&amp; i &gt; 0) {
    i--
  }
  partialWord = unescape(partialWord.substr(0, i))
  partialWords.push(partialWord)

  var opts = {
    words: words,
    w: w,
    word: word,
    line: line,
    lineLength: line.length,
    point: point,
    partialLine: partialLine,
    partialWords: partialWords,
    partialWord: partialWord,
    raw: args
  }

  cb = wrapCb(cb, opts)

  console.error(opts)

  if (partialWords.slice(0, -1).indexOf('--') === -1) {
    if (word.charAt(0) === '-') return configCompl(opts, cb)
    if (words[w - 1] &amp;&amp;
        words[w - 1].charAt(0) === '-' &amp;&amp;
        !isFlag(words[w - 1])) {
      // awaiting a value for a non-bool config.
      // don't even try to do this for now
      console.error('configValueCompl')
      return configValueCompl(opts, cb)
    }
  }

  // try to find the npm command.
  // it's the first thing after all the configs.
  // take a little shortcut and use npm's arg parsing logic.
  // don't have to worry about the last arg being implicitly
  // boolean'ed, since the last block will catch that.
  var parsed = opts.conf =
    nopt(configTypes, shorthands, partialWords.slice(0, -1), 0)
  // check if there's a command already.
  console.error(parsed)
  var cmd = parsed.argv.remain[1]
  if (!cmd) return cmdCompl(opts, cb)

  Object.keys(parsed).forEach(function (k) {
    npm.config.set(k, parsed[k])
  })

  // at this point, if words[1] is some kind of npm command,
  // then complete on it.
  // otherwise, do nothing
  cmd = npm.commands[cmd]
  if (cmd &amp;&amp; cmd.completion) return cmd.completion(opts, cb)

  // nothing to do.
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.get" id="apidoc.element.npm.config.get">
        function <span class="apidocSignatureSpan">npm.</span>config.get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // now actually fire up npm and run the command.
  // this is how to use npm programmatically:
  conf._exit = true
  npm.load(conf, function (er) {
    if (er) return errorHandler(er)
    npm.commands[npm.command](npm.argv, function (err) {
      // https://www.youtube.com/watch?v=7nfPu8qTiQU
      if (!err &amp;&amp; npm.<span class="apidocCodeKeywordSpan">config.get</span>('ham-it-up') &amp;&amp; !npm.config
.get('json') &amp;&amp; !npm.config.get('parseable') &amp;&amp; npm.command !== 'completion') {
        output('\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\n')
      }
      errorHandler.apply(this, arguments)
    })
  })
})()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.set" id="apidoc.element.npm.config.set">
        function <span class="apidocSignatureSpan">npm.</span>config.set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } catch (e) {
    return cb(new Error('no such auth module'))
  }
  auth.login(creds, registry, scope, function (err, newCreds) {
    if (err) return cb(err)

    npm.config.del('_token', 'user') // prevent legacy pollution
    if (scope) npm.<span class="apidocCodeKeywordSpan">config.set</span>(scope + ':registry', registry, 'user&amp;apos
;)
    npm.config.setCredentialsByURI(registry, newCreds)
    npm.config.save('user', cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.toLifecycle" id="apidoc.element.npm.config.toLifecycle">
        function <span class="apidocSignatureSpan">npm.</span>config.toLifecycle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.toPacote" id="apidoc.element.npm.config.toPacote">
        function <span class="apidocSignatureSpan">npm.</span>config.toPacote
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.dedupe" id="apidoc.element.npm.dedupe">
        function <span class="apidocSignatureSpan">npm.</span>dedupe
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dedupe(args, cb) {
  validate('AF', arguments)
  // the /path/to/node_modules/..
  var where = path.resolve(npm.dir, '..')
  var dryrun = false
  if (npm.command.match(/^find/)) dryrun = true
  if (npm.config.get('dry-run')) dryrun = true
  if (dryrun &amp;&amp; !npm.config.get('json')) npm.config.set('parseable', true)

  new Deduper(where, dryrun).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deprecate" id="apidoc.element.npm.deprecate">
        function <span class="apidocSignatureSpan">npm.</span>deprecate
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecate(args, cb) {
  var pkg = args[0]
  var msg = args[1]
  if (msg === undefined) return cb('Usage: ' + deprecate.usage)

  // fetch the data and make sure it exists.
  var p = npa(pkg)

  // npa makes the default spec "latest", but for deprecation
  // "*" is the appropriate default.
  var spec = p.rawSpec === '' ? '*' : p.fetchSpec

  mapToRegistry(p.name, npm.config, function (er, uri, auth) {
    if (er) return cb(er)

    var params = {
      version: spec,
      message: msg,
      auth: auth
    }
    npm.registry.deprecate(uri, params, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (er) return cb(er)

    var params = {
      version: spec,
      message: msg,
      auth: auth
    }
    npm.registry.<span class="apidocCodeKeywordSpan">deprecate</span>(uri, params, cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deref" id="apidoc.element.npm.deref">
        function <span class="apidocSignatureSpan">npm.</span>deref
        <span class="apidocSignatureSpan">(c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deref = function (c) {
  if (!c) return ''
  if (c.match(/[A-Z]/)) {
    c = c.replace(/([A-Z])/g, function (m) {
      return '-' + m.toLowerCase()
    })
  }
  if (plumbing.indexOf(c) !== -1) return c
  var a = abbrevs[c]
  if (aliases[a]) a = aliases[a]
  return a
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  process.argv.splice(1, 1, 'npm', '-g')
}

log.verbose('cli', process.argv)

var conf = nopt(types, shorthands)
npm.argv = conf.argv.remain
if (npm.<span class="apidocCodeKeywordSpan">deref</span>(npm.argv[0])) npm.command = npm.argv.shift()
else conf.usage = true

if (conf.version) {
  console.log(npm.version)
  return errorHandler.exit(0)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.diff_trees" id="apidoc.element.npm.diff_trees">
        function <span class="apidocSignatureSpan">npm.</span>diff_trees
        <span class="apidocSignatureSpan">(oldTree, newTree, differences, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff_trees = function (oldTree, newTree, differences, log, next) {
  validate('OOAOF', arguments)
  pushAll(differences, sortActions(diffTrees(oldTree, newTree)))
  log.finish()
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.edit" id="apidoc.element.npm.edit">
        function <span class="apidocSignatureSpan">npm.</span>edit
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function edit(args, cb) {
  var p = args[0]
  if (args.length !== 1 || !p) return cb(edit.usage)
  var e = npm.config.get('editor')
  if (!e) {
    return cb(new Error(
      "No editor set.  Set the 'editor' config, or $EDITOR environ."
    ))
  }
  p = p.split('/')
       .join('/node_modules/')
       .replace(/(\/node_modules)+/, '/node_modules')
  var f = path.resolve(npm.dir, p)
  fs.lstat(f, function (er) {
    if (er) return cb(er)
    editor(f, { editor: e }, noProgressTillDone(function (er) {
      if (er) return cb(er)
      npm.commands.rebuild(args, cb)
    }))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.error_handler" id="apidoc.element.npm.error_handler">
        function <span class="apidocSignatureSpan">npm.</span>error_handler
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errorHandler(er) {
  log.disableProgress()
  if (!npm.config || !npm.config.loaded) {
    // logging won't work unless we pretend that it's ready
    er = er || new Error('Exit prior to config file resolving.')
    console.error(er.stack || er.message)
  }

  if (cbCalled) {
    er = er || new Error('Callback called more than once.')
  }

  cbCalled = true
  if (!er) return exit(0)
  if (typeof er === 'string') {
    log.error('', er)
    return exit(1, true)
  } else if (!(er instanceof Error)) {
    log.error('weird error', er)
    return exit(1, true)
  }

  var m = er.code || er.message.match(/^(?:Error: )?(E[A-Z]+)/)
  if (m &amp;&amp; !er.code) {
    er.code = m
  }

  ;[
    'type',
    'stack',
    'statusCode',
    'pkgid'
  ].forEach(function (k) {
    var v = er[k]
    if (!v) return
    log.verbose(k, v)
  })

  log.verbose('cwd', process.cwd())

  var os = require('os')
  log.verbose('', os.type() + ' ' + os.release())
  log.verbose('argv', process.argv.map(JSON.stringify).join(' '))
  log.verbose('node', process.version)
  log.verbose('npm ', 'v' + npm.version)

  ;[
    'file',
    'path',
    'code',
    'errno',
    'syscall'
  ].forEach(function (k) {
    var v = er[k]
    if (v) log.error(k, v)
  })

  var msg = errorMessage(er)
  msg.summary.concat(msg.detail).forEach(function (errline) {
    log.error.apply(log, errline)
  })
  if (npm.config.get('json')) {
    var error = {
      error: {
        code: er.code,
        summary: messageText(msg.summary),
        detail: messageText(msg.detail)
      }
    }
    console.log(JSON.stringify(error, null, 2))
  }

  exit(typeof er.errno === 'number' ? er.errno : 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.exists" id="apidoc.element.npm.exists">
        function <span class="apidocSignatureSpan">npm.</span>exists
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight('exists:' + dir, done)
  if (!done) return
  fs.access(dir, fs.F_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.explore" id="apidoc.element.npm.explore">
        function <span class="apidocSignatureSpan">npm.</span>explore
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function explore(args, cb) {
  if (args.length &lt; 1 || !args[0]) return cb(explore.usage)
  var p = args.shift()

  var cwd = path.resolve(npm.dir, p)
  var opts = {cwd: cwd, stdio: 'inherit'}

  var shellArgs = []
  if (args) {
    if (isWindowsShell) {
      var execCmd = escapeExecPath(args.shift())
      var execArgs = [execCmd].concat(args.map(escapeArg))
      opts.windowsVerbatimArguments = true
      shellArgs = ['/d', '/s', '/c'].concat(execArgs)
    } else {
      shellArgs.unshift('-c')
      shellArgs = ['-c', args.map(escapeArg).join(' ').trim()]
    }
  }

  var sh = npm.config.get('shell')
  fs.stat(cwd, function (er, s) {
    if (er || !s.isDirectory()) {
      return cb(new Error(
        "It doesn't look like " + p + ' is installed.'
      ))
    }

    if (!shellArgs.length) {
      output(
        '\nExploring ' + cwd + '\n' +
          "Type 'exit' or ^D when finished\n"
      )
    }

    var shell = spawn(sh, shellArgs, opts)
    shell.on('close', function (er) {
      // only fail if non-interactive.
      if (!shellArgs.length) return cb()
      cb(er)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.extract" id="apidoc.element.npm.extract">
        function <span class="apidocSignatureSpan">npm.</span>extract
        <span class="apidocSignatureSpan">(staging, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extract(staging, pkg, log) {
  log.silly('extract', packageId(pkg))
  const extractTo = moduleStagingPath(staging, pkg)
  if (!pacoteOpts) {
    pacoteOpts = require('../../config/pacote')
  }
  const opts = pacoteOpts({
    integrity: pkg.package._integrity,
    resolved: pkg.package._resolved
  })
  const args = [
    pkg.package._requested,
    extractTo,
    opts
  ]
  return BB.fromNode((cb) =&gt; {
    let launcher = localWorker
    let msg = args
    const spec = typeof args[0] === 'string' ? npa(args[0]) : args[0]
    args[0] = spec.raw
    if (ENABLE_WORKERS &amp;&amp; (isRegistry(spec) || spec.type === 'remote')) {
      // We can't serialize these options
      opts.loglevel = opts.log.level
      opts.log = null
      opts.dirPacker = null
      // workers will run things in parallel!
      launcher = workers
      try {
        msg = JSON.stringify(msg)
      } catch (e) {
        return cb(e)
      }
    }
    launcher(msg, cb)
  }).then(() =&gt; {
    if (pkg.package.bundleDependencies || anyBundled(pkg)) {
      return readBundled(pkg, staging, extractTo)
    }
  }).then(() =&gt; {
    return gentlyRm(path.join(extractTo, 'node_modules'))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  })
}

cache.unpack = unpack
function unpack (pkg, ver, unpackTarget, dmode, fmode, uid, gid) {
  return unbuild([unpackTarget], true).then(() =&gt; {
    const opts = pacoteOpts({dmode, fmode, uid, gid, offline: true})
    return pacote.<span class="apidocCodeKeywordSpan">extract</span>(npa.resolve(pkg, ver), unpackTarget, opts)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.fetch_package_metadata" id="apidoc.element.npm.fetch_package_metadata">
        function <span class="apidocSignatureSpan">npm.</span>fetch_package_metadata
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function limited() {
  var self = this
  var args = Array.prototype.slice.call(arguments)
  if (running &gt;= maxRunning) {
    queue.push({self: this, args: args})
    return
  }
  var cb = typeof args[args.length-1] === 'function' &amp;&amp; args.pop()
  ++ running
  args.push(function () {
    var cbargs = arguments
    -- running
    cb &amp;&amp; process.nextTick(function () {
      cb.apply(self, cbargs)
    })
    if (queue.length) {
      var next = queue.shift()
      limited.apply(next.self, next.args)
    }
  })
  func.apply(self, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.finalize" id="apidoc.element.npm.finalize">
        function <span class="apidocSignatureSpan">npm.</span>finalize
        <span class="apidocSignatureSpan">(staging, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function (staging, pkg, log) {
  log.silly('finalize', pkg.realpath)

  const extractedTo = moduleStagingPath(staging, pkg)

  const delpath = path.join(path.dirname(pkg.realpath), '.' + path.basename(pkg.realpath) + '.DELETE')
  let movedDestAway = false

  const requested = pkg.package._requested || getRequested(pkg)
  if (requested.type === 'directory') {
    const relative = path.relative(path.dirname(pkg.path), pkg.realpath)
    return makeParentPath(pkg.path)
      .then(() =&gt; symlink(relative, pkg.path, 'junction'))
      .catch((ex) =&gt; {
        return rimraf(pkg.path).then(() =&gt; symlink(relative, pkg.path, 'junction'))
      })
  } else {
    return makeParentPath(pkg.realpath)
      .then(moveStagingToDestination)
      .then(restoreOldNodeModules)
      .catch((err) =&gt; {
        if (movedDestAway) {
          return rimraf(pkg.realpath).then(moveOldDestinationBack).then(() =&gt; {
            throw err
          })
        } else {
          throw err
        }
      })
      .then(() =&gt; rimraf(delpath))
  }

  function makeParentPath (dir) {
    return mkdirp(path.dirname(dir))
  }

  function moveStagingToDestination () {
    return destinationIsClear()
      .then(actuallyMoveStaging)
      .catch(() =&gt; moveOldDestinationAway().then(actuallyMoveStaging))
  }

  function destinationIsClear () {
    return lstat(pkg.realpath).then(() =&gt; {
      throw new Error('destination exists')
    }, () =&gt; {})
  }

  function actuallyMoveStaging () {
    return move(extractedTo, pkg.realpath, moveOpts)
  }

  function moveOldDestinationAway () {
    return rimraf(delpath).then(() =&gt; {
      return move(pkg.realpath, delpath, moveOpts)
    }).then(() =&gt; { movedDestAway = true })
  }

  function moveOldDestinationBack () {
    return move(delpath, pkg.realpath, moveOpts).then(() =&gt; { movedDestAway = false })
  }

  function restoreOldNodeModules () {
    if (!movedDestAway) return
    return readdir(path.join(delpath, 'node_modules')).catch(() =&gt; []).then((modules) =&gt; {
      if (!modules.length) return
      return mkdirp(path.join(pkg.realpath, 'node_modules')).then(() =&gt; Bluebird.map(modules, (file) =&gt; {
        const from = path.join(delpath, 'node_modules', file)
        const to = path.join(pkg.realpath, 'node_modules', file)
        return move(from, to, moveOpts)
      }))
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.flatten_tree" id="apidoc.element.npm.flatten_tree">
        function <span class="apidocSignatureSpan">npm.</span>flatten_tree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenTree(tree) {
  validate('O', arguments)
  var seen = new Set()
  var flat = {}
  var todo = [[tree, '/']]
  while (todo.length) {
    var next = todo.shift()
    var pkg = next[0]
    seen.add(pkg)
    var path = next[1]
    flat[path] = pkg
    if (path !== '/') path += '/'
    for (var ii = 0; ii &lt; pkg.children.length; ++ii) {
      var child = pkg.children[ii]
      if (!seen.has(child)) {
        todo.push([child, flatName(path, child)])
      }
    }
  }
  return flat
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.help" id="apidoc.element.npm.help">
        function <span class="apidocSignatureSpan">npm.</span>help
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function help(args, cb) {
  var argv = npm.config.get('argv').cooked

  var argnum = 0
  if (args.length === 2 &amp;&amp; ~~args[0]) {
    argnum = ~~args.shift()
  }

  // npm help foo bar baz: search topics
  if (args.length &gt; 1 &amp;&amp; args[0]) {
    return npm.commands['help-search'](args, argnum, cb)
  }

  var section = npm.deref(args[0]) || args[0]

  // npm help &lt;noargs&gt;:  show basic usage
  if (!section) {
    var valid = argv[0] === 'help' ? 0 : 1
    return npmUsage(valid, cb)
  }

  // npm &lt;command&gt; -h: show command usage
  if (npm.config.get('usage') &amp;&amp;
      npm.commands[section] &amp;&amp;
      npm.commands[section].usage) {
    npm.config.set('loglevel', 'silent')
    log.level = 'silent'
    output(npm.commands[section].usage)
    return cb()
  }

  // npm apihelp &lt;section&gt;: Prefer section 3 over section 1
  var apihelp = argv.length &amp;&amp; argv[0].indexOf('api') !== -1
  var pref = apihelp ? [3, 1, 5, 7] : [1, 3, 5, 7]
  if (argnum) {
    pref = [ argnum ].concat(pref.filter(function (n) {
      return n !== argnum
    }))
  }

  // npm help &lt;section&gt;: Try to find the path
  var manroot = path.resolve(__dirname, '..', 'man')

  // legacy
  if (section === 'global') section = 'folders'
  else if (section === 'json') section = 'package.json'

  // find either /section.n or /npm-section.n
  // The glob is used in the glob.  The regexp is used much
  // further down.  Globs and regexps are different
  var compextglob = '.+(gz|bz2|lzma|[FYzZ]|xz)'
  var compextre = '\\.(gz|bz2|lzma|[FYzZ]|xz)$'
  var f = '+(npm-' + section + '|' + section + ').[0-9]?(' + compextglob + ')'
  return glob(manroot + '/*/' + f, function (er, mans) {
    if (er) return cb(er)

    if (!mans.length) return npm.commands['help-search'](args, cb)

    mans = mans.map(function (man) {
      var ext = path.extname(man)
      if (man.match(new RegExp(compextre))) man = path.basename(man, ext)

      return man
    })

    viewMan(pickMan(mans, pref), cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    hits: found,
    totalHits: totalHits
  })
})

// if only one result, then just show that help section.
if (results.length === 1) {
  return npm.commands.<span class="apidocCodeKeywordSpan">help</span>([results[0].file.replace(/\.md$/, '')], cb)
}

if (results.length === 0) {
  output('No results for ' + args.map(JSON.stringify).join(' '))
  return cb()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.install" id="apidoc.element.npm.install">
        function <span class="apidocSignatureSpan">npm.</span>install
        <span class="apidocSignatureSpan">(where, args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function install(where, args, cb) {
  if (!cb) {
    cb = args
    args = where
    where = null
  }
  var globalTop = path.resolve(npm.globalDir, '..')
  if (!where) {
    where = npm.config.get('global')
          ? globalTop
          : npm.prefix
  }
  validate('SAF', [where, args, cb])
  // the /path/to/node_modules/..
  var dryrun = !!npm.config.get('dry-run')

  if (npm.config.get('dev')) {
    log.warn('install', 'Usage of the `--dev` option is deprecated. Use `--only=dev` instead.')
  }

  if (where === globalTop &amp;&amp; !args.length) {
    args = ['.']
  }
  args = args.filter(function (a) {
    return path.resolve(a) !== npm.prefix
  })

  new Installer(where, dryrun, args).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// if it's a folder, a random not-installed thing, or not a scoped package,
// then link or install it first
if (pkg[0] !== '@' &amp;&amp; (pkg.indexOf('/') !== -1 || pkg.indexOf('\\') !== -1)) {
  return fs.lstat(path.resolve(pkg), function (er, st) {
    if (er || !st.isDirectory()) {
      npm.commands.<span class="apidocCodeKeywordSpan">install</span>(t, pkg, n)
    } else {
      rp = path.resolve(pkg)
      linkPkg(rp, n)
    }
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.link" id="apidoc.element.npm.link">
        function <span class="apidocSignatureSpan">npm.</span>link
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function link(args, cb) {
  if (process.platform === 'win32') {
    var semver = require('semver')
    if (!semver.gte(process.version, '0.7.9')) {
      var msg = 'npm link not supported on windows prior to node 0.7.9'
      var e = new Error(msg)
      e.code = 'ENOTSUP'
      e.errno = require('constants').ENOTSUP
      return cb(e)
    }
  }

  if (npm.config.get('global')) {
    return cb(new Error(
      'link should never be --global.\n' +
      'Please re-run this command with --local'
    ))
  }

  if (args.length === 1 &amp;&amp; args[0] === '.') args = []
  if (args.length) return linkInstall(args, cb)
  linkPkg(npm.prefix, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.load" id="apidoc.element.npm.load">
        function <span class="apidocSignatureSpan">npm.</span>load
        <span class="apidocSignatureSpan">(cli, cb_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (cli, cb_) {
  if (!cb_ &amp;&amp; typeof cli === 'function') {
    cb_ = cli
    cli = {}
  }
  if (!cb_) cb_ = function () {}
  if (!cli) cli = {}
  loadListeners.push(cb_)
  if (loaded || loadErr) return cb(loadErr)
  if (loading) return
  loading = true
  var onload = true

  function cb (er) {
    if (loadErr) return
    loadErr = er
    if (er) return cb_(er)
    if (npm.config.get('force')) {
      log.warn('using --force', 'I sure hope you know what you are doing.')
    }
    npm.config.loaded = true
    loaded = true
    loadCb(loadErr = er)
    onload = onload &amp;&amp; npm.config.get('onload-script')
    if (onload) {
      try {
        require(onload)
      } catch (err) {
        log.warn('onload-script', 'failed to require onload script', onload)
        log.warn('onload-script', err)
      }
      onload = false
    }
  }

  log.pause()

  load(npm, cli, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.argv.unshift(npm.command)
  npm.command = 'help'
}

// now actually fire up npm and run the command.
// this is how to use npm programmatically:
conf._exit = true
npm.<span class="apidocCodeKeywordSpan">load</span>(conf, function (er) {
  if (er) return errorHandler(er)
  npm.commands[npm.command](npm.argv, function (err) {
    // https://www.youtube.com/watch?v=7nfPu8qTiQU
    if (!err &amp;&amp; npm.config.get('ham-it-up') &amp;&amp; !npm.config.get('json') &amp;&amp; !npm.config
.get('parseable') &amp;&amp; npm.command !== 'completion') {
      output('\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\n')
    }
    errorHandler.apply(this, arguments)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ls" id="apidoc.element.npm.ls">
        function <span class="apidocSignatureSpan">npm.</span>ls
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ls(args, silent, cb) {
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }
  var dir = path.resolve(npm.dir, '..')
  readPackageTree(dir, function (_, physicalTree) {
    if (!physicalTree) physicalTree = {package: {}, path: dir}
    physicalTree.isTop = true
    readShrinkwrap.andInflate(physicalTree, function () {
      lsFromTree(dir, computeMetadata(physicalTree), args, silent, cb)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.mutate_into_logical_tree" id="apidoc.element.npm.mutate_into_logical_tree">
        function <span class="apidocSignatureSpan">npm.</span>mutate_into_logical_tree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mutate_into_logical_tree = function (tree) {
  validate('O', arguments)

  validateAllPeerDeps(tree, function (tree, pkgname, version) {
    if (!tree.missingPeers) tree.missingPeers = {}
    tree.missingPeers[pkgname] = version
  })

  var flat = flattenTree(tree)

  Object.keys(flat).sort().forEach(function (flatname) {
    var node = flat[flatname]
    if (!(node.requiredBy &amp;&amp; node.requiredBy.length)) return

    if (node.parent) {
      // If a node is a cycle that never reaches the root of the logical
      // tree then we'll leave it attached to the root, or else it
      // would go missing. Further we'll note that this is the node in the
      // cycle that we picked arbitrarily to be the one attached to the root.
      // others will fall
      if (isDisconnectedCycle(node)) {
        node.cycleTop = true
      // Nor do we want to disconnect non-cyclical extraneous modules from the tree.
      } else if (node.requiredBy.length) {
        // regular deps though, we do, as we're moving them into the capable
        // hands of the modules that require them.
        node.parent.children = without(node.parent.children, node)
      }
    }

    node.requiredBy.forEach(function (parentNode) {
      parentNode.children = union(parentNode.children, [node])
    })
  })
  return tree
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.owner" id="apidoc.element.npm.owner">
        function <span class="apidocSignatureSpan">npm.</span>owner
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function owner(args, cb) {
  var action = args.shift()
  switch (action) {
    case 'ls': case 'list': return ls(args[0], cb)
    case 'add': return add(args[0], args[1], cb)
    case 'rm': case 'remove': return rm(args[0], args[1], cb)
    default: return unknown(action, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack" id="apidoc.element.npm.pack">
        function <span class="apidocSignatureSpan">npm.</span>pack
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pack(args, silent, cb) {
  const cwd = process.cwd()
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }

  if (args.length === 0) args = ['.']

  BB.all(
    args.map((arg) =&gt; pack_(arg, cwd))
  ).then((files) =&gt; {
    if (!silent) {
      output(files.map((f) =&gt; path.relative(cwd, f)).join('\n'))
    }
    cb(null, files)
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.parse_json" id="apidoc.element.npm.parse_json">
        function <span class="apidocSignatureSpan">npm.</span>parse_json
        <span class="apidocSignatureSpan">(content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_json = function (content) {
  return parseJsonWithErrors(stripBOM(content))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.profile" id="apidoc.element.npm.profile">
        function <span class="apidocSignatureSpan">npm.</span>profile
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function profileCmd(args, cb) {
  if (args.length === 0) return cb(new Error(profileCmd.usage))
  log.gauge.show('profile')
  switch (args[0]) {
    case 'enable-2fa':
    case 'enable-tfa':
    case 'enable2fa':
    case 'enabletfa':
      withCb(enable2fa(args.slice(1)), cb)
      break
    case 'disable-2fa':
    case 'disable-tfa':
    case 'disable2fa':
    case 'disabletfa':
      withCb(disable2fa(), cb)
      break
    case 'get':
      withCb(get(args.slice(1)), cb)
      break
    case 'set':
      withCb(set(args.slice(1)), cb)
      break
    default:
      cb(new Error('Unknown profile command: ' + args[0]))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.prune" id="apidoc.element.npm.prune">
        function <span class="apidocSignatureSpan">npm.</span>prune
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prune(args, cb) {
  var dryrun = !!npm.config.get('dry-run')
  new Pruner('.', dryrun, args).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.publish" id="apidoc.element.npm.publish">
        function <span class="apidocSignatureSpan">npm.</span>publish
        <span class="apidocSignatureSpan">(args, isRetry, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(args, isRetry, cb) {
  if (typeof cb !== 'function') {
    cb = isRetry
    isRetry = false
  }
  if (args.length === 0) args = ['.']
  if (args.length !== 1) return cb(publish.usage)

  log.verbose('publish', args)

  const t = npm.config.get('tag').trim()
  if (semver.validRange(t)) {
    return cb(new Error('Tag name must not be a valid SemVer range: ' + t))
  }

  publish_(args[0]).then((pkg) =&gt; {
    output(`+ ${pkg._id}`)
    cb()
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  params.access = config.get('access')
}

log.showProgress('publish:' + pkg._id)
return BB.fromNode((cb) =&gt; {
  registry.<span class="apidocCodeKeywordSpan">publish</span>(registryBase, params, cb)
}).catch((err) =&gt; {
  if (
    err.code === 'EPUBLISHCONFLICT' &amp;&amp;
    npm.config.get('force') &amp;&amp;
    !isRetry
  ) {
    log.warn('publish', 'Forced publish over ' + pkg._id)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pulse_till_done" id="apidoc.element.npm.pulse_till_done">
        function <span class="apidocSignatureSpan">npm.</span>pulse_till_done
        <span class="apidocSignatureSpan">(prefix, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pulse_till_done = function (prefix, cb) {
  validate('SF', [prefix, cb])
  if (!prefix) prefix = 'network'
  pulseStart(prefix)
  return function () {
    pulseStop()
    cb.apply(null, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap" id="apidoc.element.npm.read_shrinkwrap">
        function <span class="apidocSignatureSpan">npm.</span>read_shrinkwrap
        <span class="apidocSignatureSpan">(child, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readShrinkwrap(child, next) {
  if (child.package._shrinkwrap) return process.nextTick(next)
  BB.join(
    maybeReadFile('npm-shrinkwrap.json', child),
    // Don't read non-root lockfiles
    child.isTop &amp;&amp; maybeReadFile('package-lock.json', child),
    child.isTop &amp;&amp; maybeReadFile('package.json', child),
    (shrinkwrap, lockfile, pkgJson) =&gt; {
      if (shrinkwrap &amp;&amp; lockfile) {
        log.warn('read-shrinkwrap', 'Ignoring package-lock.json because there is already an npm-shrinkwrap.json. Please use only
 one of the two.')
      }
      const name = shrinkwrap ? 'npm-shrinkwrap.json' : 'package-lock.json'
      const parsed = parsePkgLock(shrinkwrap || lockfile, name)
      if (parsed &amp;&amp; parsed.lockfileVersion !== PKGLOCK_VERSION) {
        log.warn('read-shrinkwrap', `This version of npm is compatible with lockfileVersion@${PKGLOCK_VERSION}, but ${name} was
generated for lockfileVersion@${parsed.lockfileVersion || 0}. I'll try to do my best with it!`)
      }
      child.package._shrinkwrap = parsed
    }
  ).then(() =&gt; next(), next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.rebuild" id="apidoc.element.npm.rebuild">
        function <span class="apidocSignatureSpan">npm.</span>rebuild
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rebuild(args, cb) {
  var opt = { depth: npm.config.get('depth'), dev: true }
  readInstalled(npm.prefix, opt, function (er, data) {
    log.info('readInstalled', typeof data)
    if (er) return cb(er)
    var set = filter(data, args)
    var folders = Object.keys(set).filter(function (f) {
      return f !== npm.prefix
    })
    if (!folders.length) return cb()
    log.silly('rebuild set', folders)
    cleanBuild(folders, set, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       .join('/node_modules/')
       .replace(/(\/node_modules)+/, '/node_modules')
  var f = path.resolve(npm.dir, p)
  fs.lstat(f, function (er) {
    if (er) return cb(er)
    editor(f, { editor: e }, noProgressTillDone(function (er) {
      if (er) return cb(er)
      npm.commands.<span class="apidocCodeKeywordSpan">rebuild</span>(args, cb)
    }))
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.repo" id="apidoc.element.npm.repo">
        function <span class="apidocSignatureSpan">npm.</span>repo
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repo(args, cb) {
  var n = args.length ? args[0] : '.'
  fetchPackageMetadata(n, '.', {fullMetadata: true}, function (er, d) {
    if (er) return cb(er)
    getUrlAndOpen(d, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.restart" id="apidoc.element.npm.restart">
        function <span class="apidocSignatureSpan">npm.</span>restart
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands['run-script']([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.run_script" id="apidoc.element.npm.run_script">
        function <span class="apidocSignatureSpan">npm.</span>run_script
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runScript(args, cb) {
  if (!args.length) return list(cb)

  var pkgdir = npm.localPrefix
  var cmd = args.shift()

  readJson(path.resolve(pkgdir, 'package.json'), function (er, d) {
    if (er) return cb(er)
    run(d, pkgdir, cmd, args, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.save_stack" id="apidoc.element.npm.save_stack">
        function <span class="apidocSignatureSpan">npm.</span>save_stack
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SaveStack(fn) {
  Error.call(this)
  Error.captureStackTrace(this, fn || SaveStack)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.search" id="apidoc.element.npm.search">
        function <span class="apidocSignatureSpan">npm.</span>search
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function search(args, cb) {
  var searchOpts = {
    description: npm.config.get('description'),
    exclude: prepareExcludes(npm.config.get('searchexclude')),
    include: prepareIncludes(args, npm.config.get('searchopts')),
    limit: npm.config.get('searchlimit'),
    log: log,
    staleness: npm.config.get('searchstaleness'),
    unicode: npm.config.get('unicode')
  }

  if (searchOpts.include.length === 0) {
    return cb(new Error('search must be called with arguments'))
  }

  // Used later to figure out whether we had any packages go out
  var anyOutput = false

  var entriesStream = ms.through.obj()

  var esearchWritten = false
  esearch(searchOpts).on('data', function (pkg) {
    entriesStream.write(pkg)
    !esearchWritten &amp;&amp; (esearchWritten = true)
  }).on('error', function (e) {
    if (esearchWritten) {
      // If esearch errored after already starting output, we can't fall back.
      return entriesStream.emit('error', e)
    }
    log.warn('search', 'fast search endpoint errored. Using old search.')
    allPackageSearch(searchOpts).on('data', function (pkg) {
      entriesStream.write(pkg)
    }).on('error', function (e) {
      entriesStream.emit('error', e)
    }).on('end', function () {
      entriesStream.end()
    })
  }).on('end', function () {
    entriesStream.end()
  })

  // Grab a configured output stream that will spit out packages in the
  // desired format.
  var outputStream = formatPackageStream({
    args: args, // --searchinclude options are not highlighted
    long: npm.config.get('long'),
    description: npm.config.get('description'),
    json: npm.config.get('json'),
    parseable: npm.config.get('parseable'),
    color: npm.color
  })
  outputStream.on('data', function (chunk) {
    if (!anyOutput) { anyOutput = true }
    output(chunk.toString('utf8'))
  })

  log.silly('search', 'searching packages')
  ms.pipe(entriesStream, outputStream, function (er) {
    if (er) return cb(er)
    if (!anyOutput &amp;&amp; !npm.config.get('json') &amp;&amp; !npm.config.get('parseable')) {
      output('No matches found for ' + (args.map(JSON.stringify).join(' ')))
    }
    log.silly('search', 'search completed')
    log.clearProgress()
    cb(null, {})
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.shrinkwrap" id="apidoc.element.npm.shrinkwrap">
        function <span class="apidocSignatureSpan">npm.</span>shrinkwrap
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shrinkwrap(args, silent, cb) {
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }

  if (args.length) {
    log.warn('shrinkwrap', "doesn't take positional args")
  }

  move(
    path.resolve(npm.prefix, PKGLOCK),
    path.resolve(npm.prefix, SHRINKWRAP),
    { Promise: BB }
  ).then(() =&gt; {
    log.notice('', `${PKGLOCK} has been renamed to ${SHRINKWRAP}. ${SHRINKWRAP} will be used for future installations.`)
    return readFile(path.resolve(npm.prefix, SHRINKWRAP)).then((d) =&gt; {
      return JSON.parse(d)
    })
  }, (err) =&gt; {
    if (err.code !== 'ENOENT') {
      throw err
    } else {
      return readPackageTree(npm.localPrefix).then(
        id.computeMetadata
      ).then((tree) =&gt; {
        return BB.fromNode((cb) =&gt; {
          createShrinkwrap(tree, {
            silent,
            defaultFile: SHRINKWRAP
          }, cb)
        })
      })
    }
  }).then((data) =&gt; cb(null, data), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.star" id="apidoc.element.npm.star">
        function <span class="apidocSignatureSpan">npm.</span>star
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function star(args, cb) {
  if (!args.length) return cb(star.usage)
  var s = npm.config.get('unicode') ? '\u2605 ' : '(*)'
  var u = npm.config.get('unicode') ? '\u2606 ' : '( )'
  var using = !(npm.command.match(/^un/))
  if (!using) s = u
  asyncMap(args, function (pkg, cb) {
    mapToRegistry(pkg, npm.config, function (er, uri, auth) {
      if (er) return cb(er)

      var params = {
        starred: using,
        auth: auth
      }
      npm.registry.star(uri, params, function (er, data, raw, req) {
        if (!er) {
          output(s + ' ' + pkg)
          log.verbose('star', data)
        }
        cb(er, data, raw, req)
      })
    })
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
mapToRegistry(pkg, npm.config, function (er, uri, auth) {
  if (er) return cb(er)

  var params = {
    starred: using,
    auth: auth
  }
  npm.registry.<span class="apidocCodeKeywordSpan">star</span>(uri, params, function (er, data, raw, req) {
    if (!er) {
      output(s + ' ' + pkg)
      log.verbose('star', data)
    }
    cb(er, data, raw, req)
  })
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.start" id="apidoc.element.npm.start">
        function <span class="apidocSignatureSpan">npm.</span>start
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands['run-script']([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.stop" id="apidoc.element.npm.stop">
        function <span class="apidocSignatureSpan">npm.</span>stop
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands['run-script']([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.team" id="apidoc.element.npm.team">
        function <span class="apidocSignatureSpan">npm.</span>team
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function team(args, cb) {
  // Entities are in the format &lt;scope&gt;:&lt;team&gt;
  var cmd = args.shift()
  var entity = (args.shift() || '').split(':')
  return mapToRegistry('/', npm.config, function (err, uri, auth) {
    if (err) { return cb(err) }
    try {
      return npm.registry.team(cmd, uri, {
        auth: auth,
        scope: entity[0],
        team: entity[1],
        user: args.shift()
      }, function (err, data) {
        !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))
        cb(err, data)
      })
    } catch (e) {
      cb(e.message + '\n\nUsage:\n' + team.usage)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function team (args, cb) {
// Entities are in the format &lt;scope&gt;:&lt;team&gt;
var cmd = args.shift()
var entity = (args.shift() || '').split(':')
return mapToRegistry('/', npm.config, function (err, uri, auth) {
  if (err) { return cb(err) }
  try {
    return npm.registry.<span class="apidocCodeKeywordSpan">team</span>(cmd, uri, {
      auth: auth,
      scope: entity[0],
      team: entity[1],
      user: args.shift()
    }, function (err, data) {
      !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))
      cb(err, data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.token" id="apidoc.element.npm.token">
        function <span class="apidocSignatureSpan">npm.</span>token
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(args, cb) {
  log.gauge.show('token')
  if (args.length === 0) return withCb(list([]), cb)
  switch (args[0]) {
    case 'list':
    case 'ls':
      withCb(list(), cb)
      break
    case 'delete':
    case 'revoke':
    case 'remove':
    case 'rm':
      withCb(rm(args.slice(1)), cb)
      break
    case 'create':
      withCb(create(args.slice(1)), cb)
      break
    default:
      cb(new Error('Unknown profile command: ' + args[0]))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unbuild" id="apidoc.element.npm.unbuild">
        function <span class="apidocSignatureSpan">npm.</span>unbuild
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unbuild(args, silent, cb) {
  if (typeof silent === 'function') {
    cb = silent
    silent = false
  }
  asyncMap(args, unbuild_(silent), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.uninstall" id="apidoc.element.npm.uninstall">
        function <span class="apidocSignatureSpan">npm.</span>uninstall
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uninstall(args, cb) {
  validate('AF', arguments)
  // the /path/to/node_modules/..
  const dryrun = !!npm.config.get('dry-run')

  if (args.length === 1 &amp;&amp; args[0] === '.') args = []

  const where = npm.config.get('global') || !args.length
            ? path.resolve(npm.globalDir, '..')
            : npm.prefix

  args = args.filter(function (a) {
    return path.resolve(a) !== where
  })

  if (args.length) {
    new Uninstaller(where, dryrun, args).run(cb)
  } else {
    // remove this package from the global space, if it's installed there
    readJson(path.resolve(npm.localPrefix, 'package.json'), function (er, pkg) {
      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
      if (er) return cb(uninstall.usage)
      new Uninstaller(where, dryrun, [pkg.name]).run(cb)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unpublish" id="apidoc.element.npm.unpublish">
        function <span class="apidocSignatureSpan">npm.</span>unpublish
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unpublish(args, cb) {
  if (args.length &gt; 1) return cb(unpublish.usage)

  var thing = args.length ? npa(args[0]) : {}
  var project = thing.name
  var version = thing.rawSpec

  log.silly('unpublish', 'args[0]', args[0])
  log.silly('unpublish', 'thing', thing)
  if (!version &amp;&amp; !npm.config.get('force')) {
    return cb(
      'Refusing to delete entire project.\n' +
      'Run with --force to do this.\n' +
      unpublish.usage
    )
  }

  if (!project || path.resolve(project) === npm.localPrefix) {
    // if there's a package.json in the current folder, then
    // read the package name and version out of that.
    var cwdJson = path.join(npm.localPrefix, 'package.json')
    return readJson(cwdJson, function (er, data) {
      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
      if (er) return cb('Usage:\n' + unpublish.usage)
      log.verbose('unpublish', data)
      gotProject(data.name, data.version, data.publishConfig, cb)
    })
  }
  return gotProject(project, version, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (
  err.code === 'EPUBLISHCONFLICT' &amp;&amp;
  npm.config.get('force') &amp;&amp;
  !isRetry
) {
  log.warn('publish', 'Forced publish over ' + pkg._id)
  return BB.fromNode((cb) =&gt; {
    npm.commands.<span class="apidocCodeKeywordSpan">unpublish</span>([pkg._id], cb)
  }).finally(() =&gt; {
    // ignore errors.  Use the force.  Reach out with your feelings.
    return upload(arg, pkg, true, cached).catch(() =&gt; {
      // but if it fails again, then report the first error.
      throw err
    })
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.validate_args" id="apidoc.element.npm.validate_args">
        function <span class="apidocSignatureSpan">npm.</span>validate_args
        <span class="apidocSignatureSpan">(idealTree, args, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_args = function (idealTree, args, next) {
  validate('OAF', arguments)
  var force = npm.config.get('force')

  asyncMap(args, function (pkg, done) {
    chain([
      [hasMinimumFields, pkg],
      [checkSelf, idealTree, pkg, force],
      [isInstallable, pkg]
    ], done)
  }, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.view" id="apidoc.element.npm.view">
        function <span class="apidocSignatureSpan">npm.</span>view
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function view(args, silent, cb) {
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }

  if (!args.length) args = ['.']

  var pkg = args.shift()
  var nv
  if (/^[.]@/.test(pkg)) {
    nv = npa.resolve(null, pkg.slice(2))
  } else {
    nv = npa(pkg)
  }
  var name = nv.name
  var local = (name === '.' || !name)

  if (npm.config.get('global') &amp;&amp; local) {
    return cb(new Error('Cannot use view command in global mode.'))
  }

  if (local) {
    var dir = npm.prefix
    readJson(path.resolve(dir, 'package.json'), function (er, d) {
      d = d || {}
      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
      if (!d.name) return cb(new Error('Invalid package.json'))

      var p = d.name
      nv = npa(p)
      if (pkg &amp;&amp; ~pkg.indexOf('@')) {
        nv.rawSpec = pkg.split('@')[pkg.indexOf('@')]
      }

      fetchAndRead(nv, args, silent, cb)
    })
  } else {
    fetchAndRead(nv, args, silent, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.writable" id="apidoc.element.npm.writable">
        function <span class="apidocSignatureSpan">npm.</span>writable
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight('writable:' + dir, done)
  if (!done) return
  fs.access(dir, fs.W_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.access" id="apidoc.module.npm.access">module npm.access</a></h1>


    <h2>
        <a href="#apidoc.element.npm.access.access" id="apidoc.element.npm.access.access">
        function <span class="apidocSignatureSpan">npm.</span>access
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function access(args, cb) {
  var cmd = args.shift()
  var params
  return parseParams(cmd, args, function (err, p) {
    if (err) { return cb(err) }
    params = p
    return mapToRegistry(params.package, npm.config, invokeCmd)
  })

  function invokeCmd (err, uri, auth, base) {
    if (err) { return cb(err) }
    params.auth = auth
    try {
      return npm.registry.access(cmd, uri, params, function (err, data) {
        if (!err &amp;&amp; data) {
          output(JSON.stringify(data, undefined, 2))
        }
        cb(err, data)
      })
    } catch (e) {
      cb(e.message + '\n\nUsage:\n' + access.usage)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return mapToRegistry(params.package, npm.config, invokeCmd)
})

function invokeCmd (err, uri, auth, base) {
  if (err) { return cb(err) }
  params.auth = auth
  try {
    return npm.registry.<span class="apidocCodeKeywordSpan">access</span>(cmd, uri, params, function (err, data) {
      if (!err &amp;&amp; data) {
        output(JSON.stringify(data, undefined, 2))
      }
      cb(err, data)
    })
  } catch (e) {
    cb(e.message + '\n\nUsage:\n' + access.usage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.access.completion" id="apidoc.element.npm.access.completion">
        function <span class="apidocSignatureSpan">npm.access.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain
  if (argv.length === 2) {
    return cb(null, access.subcommands)
  }

  switch (argv[2]) {
    case 'grant':
      if (argv.length === 3) {
        return cb(null, ['read-only', 'read-write'])
      } else {
        return cb(null, [])
      }
    case 'public':
    case 'restricted':
    case 'ls-packages':
    case 'ls-collaborators':
    case 'edit':
      return cb(null, [])
    case 'revoke':
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + ' not recognized'))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.actions" id="apidoc.module.npm.actions">module npm.actions</a></h1>


    <h2>
        <a href="#apidoc.element.npm.actions.doOne" id="apidoc.element.npm.actions.doOne">
        function <span class="apidocSignatureSpan">npm.actions.</span>doOne
        <span class="apidocSignatureSpan">(cmd, staging, pkg, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doOne(cmd, staging, pkg, log, next) {
  validate('SSOOF', arguments)
  const prepped = prepareAction([cmd, pkg], staging, log)
  return withInit(actions[cmd], () =&gt; {
    return execAction(prepped)
  }).nodeify(next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.actions.doParallel" id="apidoc.element.npm.actions.doParallel">
        function <span class="apidocSignatureSpan">npm.actions.</span>doParallel
        <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doParallel(type, staging, actionsToRun, log, next) {
  validate('SSAOF', arguments)
  const acts = actionsToRun.reduce((acc, todo) =&gt; {
    if (todo[0] === type) {
      acc.push(prepareAction(todo, staging, log))
    }
    return acc
  }, [])
  log.silly('doParallel', type + ' ' + acts.length)
  time(log)
  if (!acts.length) { return next() }
  return withInit(actions[type], () =&gt; {
    return BB.map(acts, execAction, {
      concurrency: npm.limit.action
    })
  }).nodeify((err) =&gt; {
    log.finish()
    timeEnd(log)
    next(err)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.actions.doReverseSerial" id="apidoc.element.npm.actions.doReverseSerial">
        function <span class="apidocSignatureSpan">npm.actions.</span>doReverseSerial
        <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doReverseSerial(type, staging, actionsToRun, log, next) {
  validate('SSAOF', arguments)
  log.silly('doReverseSerial', '%s %d', type, actionsToRun.length)
  runSerial(type, staging, [].concat(actionsToRun).reverse(), log, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.actions.doSerial" id="apidoc.element.npm.actions.doSerial">
        function <span class="apidocSignatureSpan">npm.actions.</span>doSerial
        <span class="apidocSignatureSpan">(type, staging, actionsToRun, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doSerial(type, staging, actionsToRun, log, next) {
  validate('SSAOF', arguments)
  log.silly('doSerial', '%s %d', type, actionsToRun.length)
  runSerial(type, staging, actionsToRun, log, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.all_package_metadata" id="apidoc.module.npm.all_package_metadata">module npm.all_package_metadata</a></h1>


    <h2>
        <a href="#apidoc.element.npm.all_package_metadata.all_package_metadata" id="apidoc.element.npm.all_package_metadata.all_package_metadata">
        function <span class="apidocSignatureSpan">npm.</span>all_package_metadata
        <span class="apidocSignatureSpan">(staleness)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function allPackageMetadata(staleness) {
  var stream = ms.through.obj()

  mapToRegistry('-/all', npm.config, function (er, uri, auth) {
    if (er) return stream.emit('error', er)

    var cacheBase = cacheFile(npm.config.get('cache'))(uri)
    var cachePath = path.join(cacheBase, '.cache.json')

    createEntryStream(cachePath, uri, auth, staleness, function (err, entryStream, latest, newEntries) {
      if (err) return stream.emit('error', err)
      log.silly('all-package-metadata', 'entry stream created')
      if (entryStream &amp;&amp; newEntries) {
        createCacheWriteStream(cachePath, latest, function (err, writeStream) {
          if (err) return stream.emit('error', err)
          log.silly('all-package-metadata', 'output stream created')
          ms.pipeline.obj(entryStream, writeStream, stream)
        })
      } else if (entryStream) {
        ms.pipeline.obj(entryStream, stream)
      } else {
        stream.emit('error', new Error('No search sources available'))
      }
    })
  })
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createCacheEntryStream" id="apidoc.element.npm.all_package_metadata._createCacheEntryStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createCacheEntryStream
        <span class="apidocSignatureSpan">(cacheFile, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCacheEntryStream(cacheFile, cb) {
  log.verbose('all-package-metadata', 'creating entry stream from local cache')
  log.verbose('all-package-metadata', cacheFile)
  fs.stat(cacheFile, function (err, stat) {
    if (err) return cb(err)
    // TODO - This isn't very helpful if `cacheFile` is empty or just `{}`
    var entryStream = ms.pipeline.obj(
      fs.createReadStream(cacheFile),
      jsonstream.parse('*'),
      // I believe this passthrough is necessary cause `jsonstream` returns
      // weird custom streams that behave funny sometimes.
      ms.through.obj()
    )
    extractUpdated(entryStream, 'cached-entry-stream', cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createCacheWriteStream" id="apidoc.element.npm.all_package_metadata._createCacheWriteStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createCacheWriteStream
        <span class="apidocSignatureSpan">(cacheFile, latest, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createCacheWriteStream(cacheFile, latest, cb) {
  _ensureCacheDirExists(cacheFile, function (err) {
    if (err) return cb(err)
    log.silly('all-package-metadata', 'creating output stream')
    var outStream = _createCacheOutStream()
    var cacheFileStream = writeStreamAtomic(cacheFile)
    var inputStream = _createCacheInStream(cacheFileStream, outStream, latest)

    // Glue together the various streams so they fail together.
    // `cacheFileStream` errors are already handled by the `inputStream`
    // pipeline
    var errEmitted = false
    linkStreams(inputStream, outStream, function () { errEmitted = true })

    cacheFileStream.on('close', function () { !errEmitted &amp;&amp; outStream.end() })

    cb(null, ms.duplex.obj(inputStream, outStream))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createEntryStream" id="apidoc.element.npm.all_package_metadata._createEntryStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createEntryStream
        <span class="apidocSignatureSpan">(cachePath, uri, auth, staleness, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createEntryStream(cachePath, uri, auth, staleness, cb) {
  createCacheEntryStream(cachePath, function (err, cacheStream, cacheLatest) {
    cacheLatest = cacheLatest || 0
    if (err) {
      log.warn('', 'Failed to read search cache. Rebuilding')
      log.silly('all-package-metadata', 'cache read error: ', err)
    }
    createEntryUpdateStream(uri, auth, staleness, cacheLatest, function (err, updateStream, updatedLatest) {
      updatedLatest = updatedLatest || 0
      var latest = updatedLatest || cacheLatest
      if (!cacheStream &amp;&amp; !updateStream) {
        return cb(new Error('No search sources available'))
      }
      if (err) {
        log.warn('', 'Search data request failed, search might be stale')
        log.silly('all-package-metadata', 'update request error: ', err)
      }
      if (cacheStream &amp;&amp; updateStream) {
        // Deduped, unioned, sorted stream from the combination of both.
        cb(null,
          createMergedStream(cacheStream, updateStream),
          latest,
          !!updatedLatest)
      } else {
        // Either one works if one or the other failed
        cb(null, cacheStream || updateStream, latest, !!updatedLatest)
      }
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createEntryUpdateStream" id="apidoc.element.npm.all_package_metadata._createEntryUpdateStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createEntryUpdateStream
        <span class="apidocSignatureSpan">(all, auth, staleness, latest, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createEntryUpdateStream(all, auth, staleness, latest, cb) {
  log.verbose('all-package-metadata', 'creating remote entry stream')
  var params = {
    timeout: 600,
    follow: true,
    staleOk: true,
    auth: auth,
    streaming: true
  }
  var partialUpdate = false
  if (latest &amp;&amp; (Date.now() - latest &lt; (staleness * 1000))) {
    // Skip the request altogether if our `latest` isn't stale.
    log.verbose('all-package-metadata', 'Local data up to date, skipping update')
    return cb(null)
  } else if (latest === 0) {
    log.warn('', 'Building the local index for the first time, please be patient')
    log.verbose('all-package-metadata', 'No cached data: requesting full metadata db')
  } else {
    log.verbose('all-package-metadata', 'Cached data present with timestamp:', latest, 'requesting partial index update')
    all += '/since?stale=update_after&amp;startkey=' + latest
    partialUpdate = true
  }
  npm.registry.request(all, params, function (er, res) {
    if (er) return cb(er)
    log.silly('all-package-metadata', 'request stream opened, code:', res.statusCode)
    // NOTE - The stream returned by `request` seems to be very persnickety
    //        and this is almost a magic incantation to get it to work.
    //        Modify how `res` is used here at your own risk.
    var entryStream = ms.pipeline.obj(
      res,
      ms.through(function (chunk, enc, cb) {
        cb(null, chunk)
      }),
      gunzip(),
      jsonstream.parse('*', function (pkg, key) {
        if (key[0] === '_updated' || key[0][0] !== '_') {
          return pkg
        }
      })
    )
    if (partialUpdate) {
      // The `/all/since` endpoint doesn't return `_updated`, so we
      // just use the request's own timestamp.
      cb(null, entryStream, Date.parse(res.headers.date))
    } else {
      extractUpdated(entryStream, 'entry-update-stream', cb)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.all_package_metadata._createMergedStream" id="apidoc.element.npm.all_package_metadata._createMergedStream">
        function <span class="apidocSignatureSpan">npm.all_package_metadata.</span>_createMergedStream
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMergedStream(a, b) {
  linkStreams(a, b)
  return sortedUnionStream(b, a, function (pkg) { return pkg.name })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.and_finish_tracker" id="apidoc.module.npm.and_finish_tracker">module npm.and_finish_tracker</a></h1>


    <h2>
        <a href="#apidoc.element.npm.and_finish_tracker.and_finish_tracker" id="apidoc.element.npm.and_finish_tracker.and_finish_tracker">
        function <span class="apidocSignatureSpan">npm.</span>and_finish_tracker
        <span class="apidocSignatureSpan">(tracker, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">and_finish_tracker = function (tracker, cb) {
  validate('OF', [tracker, cb])
  return function () {
    tracker.finish()
    cb.apply(null, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.and_finish_tracker.now" id="apidoc.element.npm.and_finish_tracker.now">
        function <span class="apidocSignatureSpan">npm.and_finish_tracker.</span>now
        <span class="apidocSignatureSpan">(tracker, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">now = function (tracker, cb) {
  validate('OF', [tracker, cb])
  tracker.finish()
  cb.apply(null, Array.prototype.slice.call(arguments, 2))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.packageLockOnly = opts.packageLockOnly != null
  ? opts.packageLockOnly : npm.config.get('package-lock-only')
this.rollback = opts.rollback != null ? opts.rollback : npm.config.get('rollback')
this.link = opts.link != null ? opts.link : npm.config.get('link')
this.saveOnlyLock = opts.saveOnlyLock
this.global = opts.global != null ? opts.global : this.where === path.resolve(npm.globalDir, '..')
this.started = Date.<span class="apidocCodeKeywordSpan">now</span>()
}
Installer.prototype = {}

Installer.prototype.run = function (_cb) {
validate('F|', arguments)

var result
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.bugs" id="apidoc.module.npm.bugs">module npm.bugs</a></h1>


    <h2>
        <a href="#apidoc.element.npm.bugs.bugs" id="apidoc.element.npm.bugs.bugs">
        function <span class="apidocSignatureSpan">npm.</span>bugs
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bugs(args, cb) {
  var n = args.length ? args[0] : '.'
  fetchPackageMetadata(n, '.', {fullMetadata: true}, function (er, d) {
    if (er) return cb(er)

    var url = d.bugs &amp;&amp; ((typeof d.bugs === 'string') ? d.bugs : d.bugs.url)
    if (!url) {
      url = 'https://www.npmjs.org/package/' + d.name
    }
    log.silly('bugs', 'url', url)
    opener(url, { command: npm.config.get('browser') }, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.bugs.completion" id="apidoc.element.npm.bugs.completion">
        function <span class="apidocSignatureSpan">npm.bugs.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.ci" id="apidoc.module.npm.ci">module npm.ci</a></h1>


    <h2>
        <a href="#apidoc.element.npm.ci.ci" id="apidoc.element.npm.ci.ci">
        function <span class="apidocSignatureSpan">npm.</span>ci
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ci(args, cb) {
  return new Installer({
    config: npm.config,
    log: npmlog
  })
  .run()
  .then(
    (details) =&gt; console.error(`added ${details.pkgCount} packages in ${
      details.runTime / 1000
    }s`)
  )
  .then(() =&gt; cb(), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ci.completion" id="apidoc.element.npm.ci.completion">
        function <span class="apidocSignatureSpan">npm.ci.</span>completion
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cb) =&gt; cb(null, [])</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.completion" id="apidoc.module.npm.completion">module npm.completion</a></h1>


    <h2>
        <a href="#apidoc.element.npm.completion.completion" id="apidoc.element.npm.completion.completion">
        function <span class="apidocSignatureSpan">npm.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  if (opts.w &gt; 3) return cb()

  var fs = require('graceful-fs')
  var path = require('path')
  var bashExists = null
  var zshExists = null
  fs.stat(path.resolve(process.env.HOME, '.bashrc'), function (er) {
    bashExists = !er
    next()
  })
  fs.stat(path.resolve(process.env.HOME, '.zshrc'), function (er) {
    zshExists = !er
    next()
  })
  function next () {
    if (zshExists === null || bashExists === null) return
    var out = []
    if (zshExists) out.push('~/.zshrc')
    if (bashExists) out.push('~/.bashrc')
    if (opts.w === 2) {
      out = out.map(function (m) {
        return ['&gt;&gt;', m]
      })
    }
    cb(null, out)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.config" id="apidoc.module.npm.config">module npm.config</a></h1>




    <h2>
        <a href="#apidoc.element.npm.config.get" id="apidoc.element.npm.config.get">
        function <span class="apidocSignatureSpan">npm.config.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // now actually fire up npm and run the command.
  // this is how to use npm programmatically:
  conf._exit = true
  npm.load(conf, function (er) {
    if (er) return errorHandler(er)
    npm.commands[npm.command](npm.argv, function (err) {
      // https://www.youtube.com/watch?v=7nfPu8qTiQU
      if (!err &amp;&amp; npm.config.<span class="apidocCodeKeywordSpan">get</span>('ham-it-up') &amp;&amp; !npm.config
.get('json') &amp;&amp; !npm.config.get('parseable') &amp;&amp; npm.command !== 'completion') {
        output('\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\n')
      }
      errorHandler.apply(this, arguments)
    })
  })
})()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.set" id="apidoc.element.npm.config.set">
        function <span class="apidocSignatureSpan">npm.config.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } catch (e) {
    return cb(new Error('no such auth module'))
  }
  auth.login(creds, registry, scope, function (err, newCreds) {
    if (err) return cb(err)

    npm.config.del('_token', 'user') // prevent legacy pollution
    if (scope) npm.config.<span class="apidocCodeKeywordSpan">set</span>(scope + ':registry', registry, 'user&amp;apos
;)
    npm.config.setCredentialsByURI(registry, newCreds)
    npm.config.save('user', cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.toLifecycle" id="apidoc.element.npm.config.toLifecycle">
        function <span class="apidocSignatureSpan">npm.config.</span>toLifecycle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.toPacote" id="apidoc.element.npm.config.toPacote">
        function <span class="apidocSignatureSpan">npm.config.</span>toPacote
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.config.get" id="apidoc.module.npm.config.get">module npm.config.get</a></h1>


    <h2>
        <a href="#apidoc.element.npm.config.get.get" id="apidoc.element.npm.config.get.get">
        function <span class="apidocSignatureSpan">npm.config.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // now actually fire up npm and run the command.
  // this is how to use npm programmatically:
  conf._exit = true
  npm.load(conf, function (er) {
    if (er) return errorHandler(er)
    npm.commands[npm.command](npm.argv, function (err) {
      // https://www.youtube.com/watch?v=7nfPu8qTiQU
      if (!err &amp;&amp; npm.config.<span class="apidocCodeKeywordSpan">get</span>('ham-it-up') &amp;&amp; !npm.config
.get('json') &amp;&amp; !npm.config.get('parseable') &amp;&amp; npm.command !== 'completion') {
        output('\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\n')
      }
      errorHandler.apply(this, arguments)
    })
  })
})()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.get.duck" id="apidoc.element.npm.config.get.duck">
        function <span class="apidocSignatureSpan">npm.config.get.</span>duck
        <span class="apidocSignatureSpan">(thisType, argTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duck = function (thisType, argTypes) {
  return duck.matches(thisType, argTypes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.config.set" id="apidoc.module.npm.config.set">module npm.config.set</a></h1>


    <h2>
        <a href="#apidoc.element.npm.config.set.set" id="apidoc.element.npm.config.set.set">
        function <span class="apidocSignatureSpan">npm.config.</span>set
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } catch (e) {
    return cb(new Error('no such auth module'))
  }
  auth.login(creds, registry, scope, function (err, newCreds) {
    if (err) return cb(err)

    npm.config.del('_token', 'user') // prevent legacy pollution
    if (scope) npm.config.<span class="apidocCodeKeywordSpan">set</span>(scope + ':registry', registry, 'user&amp;apos
;)
    npm.config.setCredentialsByURI(registry, newCreds)
    npm.config.save('user', cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.set.duck" id="apidoc.element.npm.config.set.duck">
        function <span class="apidocSignatureSpan">npm.config.set.</span>duck
        <span class="apidocSignatureSpan">(thisType, argTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duck = function (thisType, argTypes) {
  return duck.matches(thisType, argTypes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.config.toLifecycle" id="apidoc.module.npm.config.toLifecycle">module npm.config.toLifecycle</a></h1>


    <h2>
        <a href="#apidoc.element.npm.config.toLifecycle.toLifecycle" id="apidoc.element.npm.config.toLifecycle.toLifecycle">
        function <span class="apidocSignatureSpan">npm.config.</span>toLifecycle
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.toLifecycle.duck" id="apidoc.element.npm.config.toLifecycle.duck">
        function <span class="apidocSignatureSpan">npm.config.toLifecycle.</span>duck
        <span class="apidocSignatureSpan">(thisType, argTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duck = function (thisType, argTypes) {
  return duck.matches(thisType, argTypes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.config.toPacote" id="apidoc.module.npm.config.toPacote">module npm.config.toPacote</a></h1>


    <h2>
        <a href="#apidoc.element.npm.config.toPacote.toPacote" id="apidoc.element.npm.config.toPacote.toPacote">
        function <span class="apidocSignatureSpan">npm.config.</span>toPacote
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gf() {
  if (!gf[kMethods].length &amp;&amp; gf[kDefaultMethod]) {
    return gf[kDefaultMethod].func.apply(this, arguments)
  } else {
    return gf.applyGenfun(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.config.toPacote.duck" id="apidoc.element.npm.config.toPacote.duck">
        function <span class="apidocSignatureSpan">npm.config.toPacote.</span>duck
        <span class="apidocSignatureSpan">(thisType, argTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">duck = function (thisType, argTypes) {
  return duck.matches(thisType, argTypes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.core" id="apidoc.module.npm.core">module npm.core</a></h1>






    <h2>
        <a href="#apidoc.element.npm.core.Conf" id="apidoc.element.npm.core.Conf">
        function <span class="apidocSignatureSpan">npm.core.</span>Conf
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Conf(base) {
  if (!(this instanceof Conf)) return new Conf(base)

  CC.call(this)

  if (base) {
    if (base instanceof Conf) {
      this.root = base.list[0] || base.root
    } else {
      this.root = base
    }
  } else {
    this.root = configDefs.defaults
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.core.load" id="apidoc.element.npm.core.load">
        function <span class="apidocSignatureSpan">npm.core.</span>load
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load() {
  var cli, builtin, cb
  for (var i = 0; i &lt; arguments.length; i++) {
    switch (typeof arguments[i]) {
      case 'string': builtin = arguments[i]; break
      case 'object': cli = arguments[i]; break
      case 'function': cb = arguments[i]; break
    }
  }

  if (!cb) cb = function () {}

  if (exports.loaded) {
    var ret = exports.loaded
    if (cli) {
      ret = new Conf(ret)
      ret.unshift(cli)
    }
    return process.nextTick(cb.bind(null, null, ret))
  }

  // either a fresh object, or a clone of the passed in obj
  if (!cli) {
    cli = {}
  } else {
    cli = Object.keys(cli).reduce(function (c, k) {
      c[k] = cli[k]
      return c
    }, {})
  }

  loadCbs.push(cb)
  if (loading) return

  loading = true

  cb = once(function (er, conf) {
    if (!er) {
      exports.loaded = conf
      loading = false
    }
    loadCbs.forEach(function (fn) {
      fn(er, conf)
    })
    loadCbs.length = 0
  })

  // check for a builtin if provided.
  exports.usingBuiltin = !!builtin
  var rc = exports.rootConf = new Conf()
  if (builtin) {
    rc.addFile(builtin, 'builtin')
  } else {
    rc.add({}, 'builtin')
  }

  rc.on('load', function () {
    load_(builtin, rc, cli, cb)
  })
  rc.on('error', cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.argv.unshift(npm.command)
  npm.command = 'help'
}

// now actually fire up npm and run the command.
// this is how to use npm programmatically:
conf._exit = true
npm.<span class="apidocCodeKeywordSpan">load</span>(conf, function (er) {
  if (er) return errorHandler(er)
  npm.commands[npm.command](npm.argv, function (err) {
    // https://www.youtube.com/watch?v=7nfPu8qTiQU
    if (!err &amp;&amp; npm.config.get('ham-it-up') &amp;&amp; !npm.config.get('json') &amp;&amp; !npm.config
.get('parseable') &amp;&amp; npm.command !== 'completion') {
      output('\n ðŸŽµ I Have the Honour to Be Your Obedient Servant,ðŸŽµ ~ npm ðŸ“œðŸ–‹\n')
    }
    errorHandler.apply(this, arguments)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.core.validate" id="apidoc.element.npm.core.validate">
        function <span class="apidocSignatureSpan">npm.core.</span>validate
        <span class="apidocSignatureSpan">(cl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(cl) {
  // warn about invalid configs at every level.
  cl.list.forEach(function (conf) {
    nopt.clean(conf, configDefs.types)
  })

  nopt.clean(cl.root, configDefs.types)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.warn(m + ' ' + util.format.apply(util, [].slice.call(arguments, 1)))
  } }
}

exports.Umask = Umask
function Umask () {}
function validateUmask (data, k, val) {
  return umask.<span class="apidocCodeKeywordSpan">validate</span>(data, k, val)
}

function validateSemver (data, k, val) {
  if (!semver.valid(val)) return false
  data[k] = semver.valid(val)
}
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.dedupe" id="apidoc.module.npm.dedupe">module npm.dedupe</a></h1>


    <h2>
        <a href="#apidoc.element.npm.dedupe.dedupe" id="apidoc.element.npm.dedupe.dedupe">
        function <span class="apidocSignatureSpan">npm.</span>dedupe
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dedupe(args, cb) {
  validate('AF', arguments)
  // the /path/to/node_modules/..
  var where = path.resolve(npm.dir, '..')
  var dryrun = false
  if (npm.command.match(/^find/)) dryrun = true
  if (npm.config.get('dry-run')) dryrun = true
  if (dryrun &amp;&amp; !npm.config.get('json')) npm.config.set('parseable', true)

  new Deduper(where, dryrun).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.dedupe.Deduper" id="apidoc.element.npm.dedupe.Deduper">
        function <span class="apidocSignatureSpan">npm.dedupe.</span>Deduper
        <span class="apidocSignatureSpan">(where, dryrun)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Deduper(where, dryrun) {
  validate('SB', arguments)
  Installer.call(this, where, dryrun, [])
  this.noPackageJsonOk = true
  this.topLevelLifecycles = false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.defaults" id="apidoc.module.npm.defaults">module npm.defaults</a></h1>


    <h2>
        <a href="#apidoc.element.npm.defaults.Umask" id="apidoc.element.npm.defaults.Umask">
        function <span class="apidocSignatureSpan">npm.defaults.</span>Umask
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Umask() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.deprecate" id="apidoc.module.npm.deprecate">module npm.deprecate</a></h1>


    <h2>
        <a href="#apidoc.element.npm.deprecate.deprecate" id="apidoc.element.npm.deprecate.deprecate">
        function <span class="apidocSignatureSpan">npm.</span>deprecate
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecate(args, cb) {
  var pkg = args[0]
  var msg = args[1]
  if (msg === undefined) return cb('Usage: ' + deprecate.usage)

  // fetch the data and make sure it exists.
  var p = npa(pkg)

  // npa makes the default spec "latest", but for deprecation
  // "*" is the appropriate default.
  var spec = p.rawSpec === '' ? '*' : p.fetchSpec

  mapToRegistry(p.name, npm.config, function (er, uri, auth) {
    if (er) return cb(er)

    var params = {
      version: spec,
      message: msg,
      auth: auth
    }
    npm.registry.deprecate(uri, params, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (er) return cb(er)

    var params = {
      version: spec,
      message: msg,
      auth: auth
    }
    npm.registry.<span class="apidocCodeKeywordSpan">deprecate</span>(uri, params, cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deprecate.completion" id="apidoc.element.npm.deprecate.completion">
        function <span class="apidocSignatureSpan">npm.deprecate.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // first, get a list of remote packages this user owns.
  // once we have a user account, then don't complete anything.
  if (opts.conf.argv.remain.length &gt; 2) return cb()
  // get the list of packages by user
  var path = '/-/by-user/'
  mapToRegistry(path, npm.config, function (er, uri, c) {
    if (er) return cb(er)

    if (!(c &amp;&amp; c.username)) return cb()

    var params = {
      timeout: 60000,
      auth: c
    }
    npm.registry.get(uri + c.username, params, function (er, list) {
      if (er) return cb()
      console.error(list)
      return cb(null, list[c.username])
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.deps" id="apidoc.module.npm.deps">module npm.deps</a></h1>


    <h2>
        <a href="#apidoc.element.npm.deps._replaceModuleByName" id="apidoc.element.npm.deps._replaceModuleByName">
        function <span class="apidocSignatureSpan">npm.deps.</span>_replaceModuleByName
        <span class="apidocSignatureSpan">(obj, key, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceModuleByName(obj, key, child) {
  var childName = moduleName(child)
  return replaceModule(obj, key, child, function (replacing, child) {
    return moduleName(replacing) === childName
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps._replaceModuleByPath" id="apidoc.element.npm.deps._replaceModuleByPath">
        function <span class="apidocSignatureSpan">npm.deps.</span>_replaceModuleByPath
        <span class="apidocSignatureSpan">(obj, key, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceModuleByPath(obj, key, child) {
  return replaceModule(obj, key, child, function (replacing, child) {
    return replacing.path === child.path
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.computeMetadata" id="apidoc.element.npm.deps.computeMetadata">
        function <span class="apidocSignatureSpan">npm.deps.</span>computeMetadata
        <span class="apidocSignatureSpan">(tree, seen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeMetadata(tree, seen) {
  if (!seen) seen = new Set()
  if (!tree || seen.has(tree)) return
  seen.add(tree)
  if (tree.parent == null) {
    resetMetadata(tree)
    tree.isTop = true
  }
  tree.location = flatNameFromTree(tree)

  function findChild (name, spec, kind) {
    try {
      var req = childDependencySpecifier(tree, name, spec)
    } catch (err) {
      return
    }
    var child = findRequirement(tree, req.name, req)
    if (child) {
      resolveWithExistingModule(child, tree)
      return true
    }
    return
  }

  const deps = tree.package.dependencies || {}
  const reqs = tree.swRequires || {}
  for (let name of Object.keys(deps)) {
    if (findChild(name, deps[name])) continue
    if (name in reqs &amp;&amp; findChild(name, reqs[name])) continue
    tree.missingDeps[name] = deps[name]
  }
  if (tree.isTop) {
    const devDeps = tree.package.devDependencies || {}
    for (let name of Object.keys(devDeps)) {
      if (findChild(name, devDeps[name])) continue
      tree.missingDevDeps[name] = devDeps[name]
    }
  }

  tree.children.filter((child) =&gt; !child.removed).forEach((child) =&gt; computeMetadata(child, seen))

  return tree
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.computeVersionSpec" id="apidoc.element.npm.deps.computeVersionSpec">
        function <span class="apidocSignatureSpan">npm.deps.</span>computeVersionSpec
        <span class="apidocSignatureSpan">(tree, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function computeVersionSpec(tree, child) {
  validate('OO', arguments)
  var requested
  var childReq = child.package._requested
  if (childReq &amp;&amp; (isNotEmpty(childReq.saveSpec) || (isNotEmpty(childReq.rawSpec) &amp;&amp; isNotEmpty(childReq.fetchSpec)))) {
    requested = child.package._requested
  } else if (child.package._from) {
    requested = npa(child.package._from)
  } else {
    requested = npa.resolve(child.package.name, child.package.version)
  }
  if (isRegistry(requested)) {
    var version = child.package.version
    var rangeDescriptor = ''
    if (semver.valid(version, true) &amp;&amp;
        semver.gte(version, '0.1.0', true) &amp;&amp;
        !npm.config.get('save-exact')) {
      rangeDescriptor = npm.config.get('save-prefix')
    }
    return rangeDescriptor + version
  } else if (requested.type === 'directory' || requested.type === 'file') {
    return 'file:' + unixFormatPath(path.relative(tree.path, requested.fetchSpec))
  } else {
    return requested.saveSpec || requested.rawSpec
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.earliestInstallable" id="apidoc.element.npm.deps.earliestInstallable">
        function <span class="apidocSignatureSpan">npm.deps.</span>earliestInstallable
        <span class="apidocSignatureSpan">(requiredBy, tree, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">earliestInstallable = function (requiredBy, tree, pkg, log) {
  validate('OOOO', arguments)

  function undeletedModuleMatches (child) {
    return !child.removed &amp;&amp; moduleName(child) === pkg.name
  }
  const undeletedMatches = tree.children.filter(undeletedModuleMatches)
  if (undeletedMatches.length) {
    // if there's a conflict with another child AT THE SAME level then we're replacing it, so
    // mark it as removed and continue with resolution normally.
    if (tree === requiredBy) {
      undeletedMatches.forEach((pkg) =&gt; {
        if (pkg.fromBundle) reportBundleOverride(pkg, log)
        removeObsoleteDep(pkg, log)
      })
    } else {
      return null
    }
  }

  // If any of the children of this tree have conflicting
  // binaries then we need to decline to install this package here.
  var binaryMatches = pkg.bin &amp;&amp; tree.children.some(function (child) {
    if (child.removed || !child.package.bin) return false
    return Object.keys(child.package.bin).some(function (bin) {
      return pkg.bin[bin]
    })
  })

  if (binaryMatches) return null

  // if this tree location requested the same module then we KNOW it
  // isn't compatible because if it were findRequirement would have
  // found that version.
  var deps = tree.package.dependencies || {}
  if (!tree.removed &amp;&amp; requiredBy !== tree &amp;&amp; deps[pkg.name]) {
    return null
  }

  var devDeps = tree.package.devDependencies || {}
  if (tree.isTop &amp;&amp; devDeps[pkg.name]) {
    var requested = childDependencySpecifier(tree, pkg.name, devDeps[pkg.name])
    if (!doesChildVersionMatch({package: pkg}, requested, tree)) {
      return null
    }
  }

  if (tree.phantomChildren &amp;&amp; tree.phantomChildren[pkg.name]) return null

  if (tree.isTop) return tree
  if (tree.isGlobal) return tree

  if (npm.config.get('global-style') &amp;&amp; tree.parent.isTop) return tree
  if (npm.config.get('legacy-bundling')) return tree

  if (!preserveSymlinks() &amp;&amp; /^[.][.][\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return tree

  return (earliestInstallable(requiredBy, tree.parent, pkg, log) || tree)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.failedDependency" id="apidoc.element.npm.deps.failedDependency">
        function <span class="apidocSignatureSpan">npm.deps.</span>failedDependency
        <span class="apidocSignatureSpan">(tree, name, pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function failedDependency(tree, name, pkg) {
  if (name) {
    if (isDepOptional(tree, name, pkg || {})) {
      return false
    }
  }

  tree.failed = true

  if (tree.isTop) return true

  if (tree.userRequired) return true

  if (!tree.requiredBy) return false

  let anyFailed = false
  for (var ii = 0; ii &lt; tree.requiredBy.length; ++ii) {
    var requireParent = tree.requiredBy[ii]
    if (failedDependency(requireParent, moduleName(tree), tree)) {
      anyFailed = true
    }
  }
  return anyFailed
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.findRequirement" id="apidoc.element.npm.deps.findRequirement">
        function <span class="apidocSignatureSpan">npm.deps.</span>findRequirement
        <span class="apidocSignatureSpan">(tree, name, requested, requestor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findRequirement = function (tree, name, requested, requestor) {
  validate('OSO', [tree, name, requested])
  if (!requestor) requestor = tree
  var nameMatch = function (child) {
    return moduleName(child) === name &amp;&amp; child.parent &amp;&amp; !child.removed
  }
  var versionMatch = function (child) {
    return doesChildVersionMatch(child, requested, requestor)
  }
  if (nameMatch(tree)) {
    // this *is* the module, but it doesn't match the version, so a
    // new copy will have to be installed
    return versionMatch(tree) ? tree : null
  }

  var matches = tree.children.filter(nameMatch)
  if (matches.length) {
    matches = matches.filter(versionMatch)
    // the module exists as a dependent, but the version doesn't match, so
    // a new copy will have to be installed above here
    if (matches.length) return matches[0]
    return null
  }
  if (tree.isTop) return null
  if (!preserveSymlinks() &amp;&amp; /^[.][.][\\/]/.test(path.relative(tree.parent.realpath, tree.realpath))) return null
  return findRequirement(tree.parent, name, requested, requestor)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.getAllMetadata" id="apidoc.element.npm.deps.getAllMetadata">
        function <span class="apidocSignatureSpan">npm.deps.</span>getAllMetadata
        <span class="apidocSignatureSpan">(args, tree, where, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllMetadata = function (args, tree, where, next) {
  asyncMap(args, function (arg, done) {
    let spec
    try {
      spec = npa(arg)
    } catch (e) {
      return done(e)
    }
    if (spec.type !== 'file' &amp;&amp; spec.type !== 'directory' &amp;&amp; (spec.name == null || spec.rawSpec === '')) {
      return fs.stat(path.join(arg, 'package.json'), (err) =&gt; {
        if (err) {
          var version = matchingDep(tree, spec.name)
          if (version) {
            try {
              return fetchPackageMetadata(npa.resolve(spec.name, version), where, done)
            } catch (e) {
              return done(e)
            }
          } else {
            return fetchPackageMetadata(spec, where, done)
          }
        } else {
          try {
            return fetchPackageMetadata(npa('file:' + arg), where, done)
          } catch (e) {
            return done(e)
          }
        }
      })
    } else {
      return fetchPackageMetadata(spec, where, done)
    }
  }, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.loadDeps" id="apidoc.element.npm.deps.loadDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>loadDeps
        <span class="apidocSignatureSpan">(tree, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadDeps(tree, log, next) {
  validate('OOF', arguments)
  if (tree.loaded || (tree.parent &amp;&amp; tree.parent.failed) || tree.removed) return andFinishTracker.now(log, next)
  if (tree.parent) tree.loaded = true
  if (!tree.package.dependencies) tree.package.dependencies = {}
  asyncMap(Object.keys(tree.package.dependencies), function (dep, done) {
    var version = tree.package.dependencies[dep]
    if (tree.package.optionalDependencies &amp;&amp;
        tree.package.optionalDependencies[dep] &amp;&amp;
        !npm.config.get('optional')) {
      return done()
    }

    addDependency(dep, version, tree, log.newGroup('loadDep:' + dep), andHandleOptionalErrors(log, tree, dep, done))
  }, andForEachChild(loadDeps, andFinishTracker(log, next)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.loadDevDeps" id="apidoc.element.npm.deps.loadDevDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>loadDevDeps
        <span class="apidocSignatureSpan">(tree, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDevDeps = function (tree, log, next) {
  validate('OOF', arguments)
  if (!tree.package.devDependencies) return andFinishTracker.now(log, next)
  asyncMap(Object.keys(tree.package.devDependencies), function (dep, done) {
    // things defined as both dev dependencies and regular dependencies are treated
    // as the former
    if (tree.package.dependencies[dep]) return done()

    var logGroup = log.newGroup('loadDevDep:' + dep)
    addDependency(dep, tree.package.devDependencies[dep], tree, logGroup, done)
  }, andForEachChild(loadDeps, andFinishTracker(log, next)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.loadExtraneous" id="apidoc.element.npm.deps.loadExtraneous">
        function <span class="apidocSignatureSpan">npm.deps.</span>loadExtraneous
        <span class="apidocSignatureSpan">(tree, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadExtraneous = function (tree, log, next) {
  var seen = new Set()

  function loadExtraneous (tree) {
    if (seen.has(tree)) return
    seen.add(tree)
    for (var child of tree.children) {
      if (child.loaded) continue
      resolveWithExistingModule(child, tree)
      loadExtraneous(child)
    }
  }
  loadExtraneous(tree)
  log.finish()
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.loadRequestedDeps" id="apidoc.element.npm.deps.loadRequestedDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>loadRequestedDeps
        <span class="apidocSignatureSpan">(args, tree, saveToDependencies, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadRequestedDeps = function (args, tree, saveToDependencies, log, next) {
  validate('AOOF', [args, tree, log, next])
  asyncMap(args, function (pkg, done) {
    var depLoaded = andAddParentToErrors(tree, done)
    resolveWithNewModule(pkg, tree, log.newGroup('loadRequestedDeps'), iferr(depLoaded, function (child, tracker) {
      validate('OO', arguments)
      if (npm.config.get('global')) {
        child.isGlobal = true
      }
      var childName = moduleName(child)
      child.saveSpec = computeVersionSpec(tree, child)
      child.userRequired = true
      child.save = getSaveType(tree, child)
      const types = ['dependencies', 'devDependencies', 'optionalDependencies']
      if (child.save) {
        tree.package[child.save][childName] = child.saveSpec
        // Astute readers might notice that this exact same code exists in
        // save.js under a different guise. That code is responsible for deps
        // being removed from the final written `package.json`. The removal in
        // this function is specifically to prevent "installed as both X and Y"
        // warnings when moving an existing dep between different dep fields.
        //
        // Or, try it by removing this loop, and do `npm i -P x &amp;&amp; npm i -D x`
        for (let saveType of types) {
          if (child.save !== saveType) {
            delete tree.package[saveType][childName]
          }
        }
      }

      // For things the user asked to install, that aren't a dependency (or
      // won't be when we're done), flag it as "depending" on the user
      // themselves, so we don't remove it as a dep that no longer exists
      var childIsDep = addRequiredDep(tree, child)
      if (!childIsDep) child.userRequired = true
      depLoaded(null, child, tracker)
    }))
  }, andForEachChild(loadDeps, andFinishTracker(log, next)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.prefetchDeps" id="apidoc.element.npm.deps.prefetchDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>prefetchDeps
        <span class="apidocSignatureSpan">(tree, deps, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prefetchDeps(tree, deps, log, next) {
  validate('OOOF', arguments)
  var skipOptional = !npm.config.get('optional')
  var seen = new Set()
  const finished = andFinishTracker(log, next)
  const fpm = BB.promisify(fetchPackageMetadata)
  resolveBranchDeps(tree.package, deps).then(
    () =&gt; finished(), finished
  )

  function resolveBranchDeps (pkg, deps) {
    return BB.resolve(null).then(() =&gt; {
      var allDependencies = Object.keys(deps).map((dep) =&gt; {
        return npa.resolve(dep, deps[dep])
      }).filter((dep) =&gt; {
        return isRegistry(dep) &amp;&amp;
               !seen.has(dep.toString()) &amp;&amp;
               !findRequirement(tree, dep.name, dep)
      })
      if (skipOptional) {
        var optDeps = pkg.optionalDependencies || {}
        allDependencies = allDependencies.filter((dep) =&gt; !optDeps[dep.name])
      }
      return BB.map(allDependencies, (dep) =&gt; {
        seen.add(dep.toString())
        return fpm(dep, '', {tracker: log.newItem('fetchMetadata')}).then(
          (pkg) =&gt; {
            return pkg &amp;&amp; pkg.dependencies &amp;&amp; resolveBranchDeps(pkg, pkg.dependencies)
          },
          () =&gt; null
        )
      })
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.removeDeps" id="apidoc.element.npm.deps.removeDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>removeDeps
        <span class="apidocSignatureSpan">(args, tree, saveToDependencies, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDeps = function (args, tree, saveToDependencies, next) {
  validate('AOSF|AOZF', [args, tree, saveToDependencies, next])
  for (let pkg of args) {
    var pkgName = moduleName(pkg)
    var toRemove = tree.children.filter(moduleNameMatches(pkgName))
    var pkgToRemove = toRemove[0] || createChild({package: {name: pkgName}})
    var saveType = getSaveType(tree, pkg) || 'dependencies'
    if (tree.isTop &amp;&amp; saveToDependencies) {
      pkgToRemove.save = saveType
    }
    if (tree.package[saveType][pkgName]) {
      delete tree.package[saveType][pkgName]
      if (saveType === 'optionalDependencies' &amp;&amp; tree.package.dependencies[pkgName]) {
        delete tree.package.dependencies[pkgName]
      }
    }
    replaceModuleByPath(tree, 'removedChildren', pkgToRemove)
    for (let parent of pkgToRemove.requiredBy) {
      parent.requires = parent.requires.filter((child) =&gt; child !== pkgToRemove)
    }
    pkgToRemove.requiredBy = pkgToRemove.requiredBy.filter((parent) =&gt; parent !== tree)
    flagAsRemoving(pkgToRemove)
  }
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.removeExtraneous" id="apidoc.element.npm.deps.removeExtraneous">
        function <span class="apidocSignatureSpan">npm.deps.</span>removeExtraneous
        <span class="apidocSignatureSpan">(args, tree, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeExtraneous = function (args, tree, next) {
  for (let pkg of args) {
    var pkgName = moduleName(pkg)
    var toRemove = tree.children.filter(moduleNameMatches(pkgName))
    if (toRemove.length) {
      removeObsoleteDep(toRemove[0])
    }
  }
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.removeObsoleteDep" id="apidoc.element.npm.deps.removeObsoleteDep">
        function <span class="apidocSignatureSpan">npm.deps.</span>removeObsoleteDep
        <span class="apidocSignatureSpan">(child, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeObsoleteDep(child, log) {
  if (child.removed) return
  child.removed = true
  if (log) {
    log.silly('removeObsoleteDep', 'removing ' + packageId(child) +
      ' from the tree as its been replaced by a newer version or is no longer required')
  }
  // remove from physical tree
  if (child.parent) {
    child.parent.children = child.parent.children.filter(function (pchild) { return pchild !== child })
  }
  // remove from logical tree
  var requires = child.requires || []
  requires.forEach(function (requirement) {
    requirement.requiredBy = requirement.requiredBy.filter(function (reqBy) { return reqBy !== child })
    // we don't just check requirement.requires because that doesn't account
    // for circular deps.  isExtraneous does.
    if (isExtraneous(requirement)) removeObsoleteDep(requirement, log)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.updatePhantomChildren" id="apidoc.element.npm.deps.updatePhantomChildren">
        function <span class="apidocSignatureSpan">npm.deps.</span>updatePhantomChildren
        <span class="apidocSignatureSpan">(current, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updatePhantomChildren = function (current, child) {
  validate('OO', arguments)
  while (current &amp;&amp; current !== child.parent) {
    if (!current.phantomChildren) current.phantomChildren = {}
    current.phantomChildren[moduleName(child)] = child
    current = current.parent
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.validateAllPeerDeps" id="apidoc.element.npm.deps.validateAllPeerDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>validateAllPeerDeps
        <span class="apidocSignatureSpan">(tree, onInvalid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateAllPeerDeps = function (tree, onInvalid) {
  validateAllPeerDeps(tree, onInvalid, new Set())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.deps.validatePeerDeps" id="apidoc.element.npm.deps.validatePeerDeps">
        function <span class="apidocSignatureSpan">npm.deps.</span>validatePeerDeps
        <span class="apidocSignatureSpan">(tree, onInvalid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validatePeerDeps = function (tree, onInvalid) {
  if (!tree.package.peerDependencies) return
  Object.keys(tree.package.peerDependencies).forEach(function (pkgname) {
    var version = tree.package.peerDependencies[pkgname]
    try {
      var spec = npa.resolve(pkgname, version)
    } catch (e) {}
    var match = spec &amp;&amp; findRequirement(tree.parent || tree, pkgname, spec)
    if (!match) onInvalid(tree, pkgname, version)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.diff_trees" id="apidoc.module.npm.diff_trees">module npm.diff_trees</a></h1>


    <h2>
        <a href="#apidoc.element.npm.diff_trees.diff_trees" id="apidoc.element.npm.diff_trees.diff_trees">
        function <span class="apidocSignatureSpan">npm.</span>diff_trees
        <span class="apidocSignatureSpan">(oldTree, newTree, differences, log, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff_trees = function (oldTree, newTree, differences, log, next) {
  validate('OOAOF', arguments)
  pushAll(differences, sortActions(diffTrees(oldTree, newTree)))
  log.finish()
  next()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.diff_trees._diffTrees" id="apidoc.element.npm.diff_trees._diffTrees">
        function <span class="apidocSignatureSpan">npm.diff_trees.</span>_diffTrees
        <span class="apidocSignatureSpan">(oldTree, newTree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_diffTrees = function (oldTree, newTree) {
  validate('OO', arguments)
  var differences = []
  var flatOldTree = flattenTree(oldTree)
  var flatNewTree = flattenTree(newTree)
  var toRemove = {}
  var toRemoveByName = {}

  // Build our tentative remove list.  We don't add remove actions yet
  // because we might resuse them as part of a move.
  Object.keys(flatOldTree).forEach(function (flatname) {
    if (flatname === '/') return
    if (flatNewTree[flatname]) return
    var pkg = flatOldTree[flatname]
    if (pkg.isInLink &amp;&amp; /^[.][.][/\\]/.test(path.relative(newTree.realpath, pkg.realpath))) return

    toRemove[flatname] = pkg
    var name = moduleName(pkg)
    if (!toRemoveByName[name]) toRemoveByName[name] = []
    toRemoveByName[name].push({flatname: flatname, pkg: pkg})
  })

  // generate our add/update/move actions
  Object.keys(flatNewTree).forEach(function (flatname) {
    if (flatname === '/') return
    var pkg = flatNewTree[flatname]
    var oldPkg = pkg.oldPkg = flatOldTree[flatname]
    if (oldPkg) {
      // if the versions are equivalent then we don't need to updateâ€¦ unless
      // the user explicitly asked us to.
      if (!pkg.userRequired &amp;&amp; pkgAreEquiv(oldPkg, pkg)) return
      setAction(differences, 'update', pkg)
    } else {
      var name = moduleName(pkg)
      // find any packages we're removing that share the same name and are equivalent
      var removing = (toRemoveByName[name] || []).filter((rm) =&gt; pkgAreEquiv(rm.pkg, pkg))
      var bundlesOrFromBundle = pkg.fromBundle || pkg.package.bundleDependencies
      // if we have any removes that match AND we're not working with a bundle then upgrade to a move
      if (removing.length &amp;&amp; !bundlesOrFromBundle) {
        var toMv = removing.shift()
        toRemoveByName[name] = toRemoveByName[name].filter((rm) =&gt; rm !== toMv)
        pkg.fromPath = toMv.pkg.path
        setAction(differences, 'move', pkg)
        delete toRemove[toMv.flatname]
      // we don't generate add actions for things found in links (which already exist on disk) or
      // for bundled modules (which will be installed when we install their parent)
      } else if (!(pkg.isInLink &amp;&amp; pkg.fromBundle)) {
        setAction(differences, 'add', pkg)
      }
    }
  })

  // finally generate our remove actions from any not consumed by moves
  Object
    .keys(toRemove)
    .map((flatname) =&gt; toRemove[flatname])
    .forEach((pkg) =&gt; setAction(differences, 'remove', pkg))

  const includeDev = npm.config.get('dev') ||
    (!/^prod(uction)?$/.test(npm.config.get('only')) &amp;&amp; !npm.config.get('production')) ||
    /^dev(elopment)?$/.test(npm.config.get('only')) ||
    /^dev(elopment)?$/.test(npm.config.get('also'))
  const includeProd = !/^dev(elopment)?$/.test(npm.config.get('only'))
  if (!includeProd || !includeDev) {
    log.silly('diff-trees', 'filtering actions:', 'includeDev', includeDev, 'includeProd', includeProd)
    differences = differences.filter((diff) =&gt; {
      const pkg = diff[1]
      const pkgIsOnlyDev = isOnlyDev(pkg)
      return (!includeProd &amp;&amp; pkgIsOnlyDev) || (includeDev &amp;&amp; pkgIsOnlyDev) || (includeProd &amp;&amp; !pkgIsOnlyDev)
    })
  }
  return differences
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.diff_trees.sortActions" id="apidoc.element.npm.diff_trees.sortActions">
        function <span class="apidocSignatureSpan">npm.diff_trees.</span>sortActions
        <span class="apidocSignatureSpan">(differences)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sortActions = function (differences) {
  var actions = {}
  differences.forEach(function (action) {
    var child = action[1]
    actions[child.location] = action
  })

  var sorted = []
  var added = {}

  var sortedlocs = Object.keys(actions).sort(sortByLocation)

  // We're going to sort the actions taken on top level dependencies first, before
  // considering the order of transitive deps. Because we're building our list
  // from the bottom up, this means we will return a list with top level deps LAST.
  // This is important in terms of keeping installations as consistent as possible
  // as folks add new dependencies.
  var toplocs = sortedlocs.filter(function (location) {
    var mod = actions[location][1]
    if (!mod.requiredBy) return true
    // If this module is required by any non-top level module
    // or by any extraneous module, eg user requested or existing
    // then we don't want to give this priority sorting.
    return !mod.requiredBy.some(isNotTopOrExtraneous)
  })

  toplocs.concat(sortedlocs).forEach(function (location) {
    sortByDeps(actions[location])
  })

  function sortByLocation (aa, bb) {
    return bb.localeCompare(aa)
  }
  function sortModuleByLocation (aa, bb) {
    return sortByLocation(aa &amp;&amp; aa.location, bb &amp;&amp; bb.location)
  }
  function sortByDeps (action) {
    var mod = action[1]
    if (added[mod.location]) return
    added[mod.location] = action
    if (!mod.requiredBy) mod.requiredBy = []
    mod.requiredBy.sort(sortModuleByLocation).forEach(function (mod) {
      if (actions[mod.location]) sortByDeps(actions[mod.location])
    })
    sorted.unshift(action)
  }

  return sorted
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.edit" id="apidoc.module.npm.edit">module npm.edit</a></h1>


    <h2>
        <a href="#apidoc.element.npm.edit.edit" id="apidoc.element.npm.edit.edit">
        function <span class="apidocSignatureSpan">npm.</span>edit
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function edit(args, cb) {
  var p = args[0]
  if (args.length !== 1 || !p) return cb(edit.usage)
  var e = npm.config.get('editor')
  if (!e) {
    return cb(new Error(
      "No editor set.  Set the 'editor' config, or $EDITOR environ."
    ))
  }
  p = p.split('/')
       .join('/node_modules/')
       .replace(/(\/node_modules)+/, '/node_modules')
  var f = path.resolve(npm.dir, p)
  fs.lstat(f, function (er) {
    if (er) return cb(er)
    editor(f, { editor: e }, noProgressTillDone(function (er) {
      if (er) return cb(er)
      npm.commands.rebuild(args, cb)
    }))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.edit.completion" id="apidoc.element.npm.edit.completion">
        function <span class="apidocSignatureSpan">npm.edit.</span>completion
        <span class="apidocSignatureSpan">(opts, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedShallow(opts, filter, cb) {
  if (typeof cb !== 'function') {
    cb = filter
    filter = null
  }
  var conf = opts.conf
  var args = conf.argv.remain
  if (args.length &gt; 3) return cb()
  var local
  var global
  var localDir = npm.dir
  var globalDir = npm.globalDir
  if (npm.config.get('global')) {
    local = []
    next()
  } else {
    fs.readdir(localDir, function (er, pkgs) {
      local = (pkgs || []).filter(function (p) {
        return p.charAt(0) !== '.'
      })
      next()
    })
  }

  fs.readdir(globalDir, function (er, pkgs) {
    global = (pkgs || []).filter(function (p) {
      return p.charAt(0) !== '.'
    })
    next()
  })
  function next () {
    if (!local || !global) return
    filterInstalled(local, global, filter, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.error_handler" id="apidoc.module.npm.error_handler">module npm.error_handler</a></h1>


    <h2>
        <a href="#apidoc.element.npm.error_handler.error_handler" id="apidoc.element.npm.error_handler.error_handler">
        function <span class="apidocSignatureSpan">npm.</span>error_handler
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errorHandler(er) {
  log.disableProgress()
  if (!npm.config || !npm.config.loaded) {
    // logging won't work unless we pretend that it's ready
    er = er || new Error('Exit prior to config file resolving.')
    console.error(er.stack || er.message)
  }

  if (cbCalled) {
    er = er || new Error('Callback called more than once.')
  }

  cbCalled = true
  if (!er) return exit(0)
  if (typeof er === 'string') {
    log.error('', er)
    return exit(1, true)
  } else if (!(er instanceof Error)) {
    log.error('weird error', er)
    return exit(1, true)
  }

  var m = er.code || er.message.match(/^(?:Error: )?(E[A-Z]+)/)
  if (m &amp;&amp; !er.code) {
    er.code = m
  }

  ;[
    'type',
    'stack',
    'statusCode',
    'pkgid'
  ].forEach(function (k) {
    var v = er[k]
    if (!v) return
    log.verbose(k, v)
  })

  log.verbose('cwd', process.cwd())

  var os = require('os')
  log.verbose('', os.type() + ' ' + os.release())
  log.verbose('argv', process.argv.map(JSON.stringify).join(' '))
  log.verbose('node', process.version)
  log.verbose('npm ', 'v' + npm.version)

  ;[
    'file',
    'path',
    'code',
    'errno',
    'syscall'
  ].forEach(function (k) {
    var v = er[k]
    if (v) log.error(k, v)
  })

  var msg = errorMessage(er)
  msg.summary.concat(msg.detail).forEach(function (errline) {
    log.error.apply(log, errline)
  })
  if (npm.config.get('json')) {
    var error = {
      error: {
        code: er.code,
        summary: messageText(msg.summary),
        detail: messageText(msg.detail)
      }
    }
    console.log(JSON.stringify(error, null, 2))
  }

  exit(typeof er.errno === 'number' ? er.errno : 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.error_handler.exit" id="apidoc.element.npm.error_handler.exit">
        function <span class="apidocSignatureSpan">npm.error_handler.</span>exit
        <span class="apidocSignatureSpan">(code, noLog)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exit(code, noLog) {
  exitCode = exitCode || process.exitCode || code

  var doExit = npm.config.loaded ? npm.config.get('_exit') : true
  log.verbose('exit', [code, doExit])
  if (log.level === 'silent') noLog = true

  if (rollbacks.length) {
    chain(rollbacks.map(function (f) {
      return function (cb) {
        npm.commands.unbuild([f], true, cb)
      }
    }), function (er) {
      if (er) {
        log.error('error rolling back', er)
        if (!code) {
          errorHandler(er)
        } else {
          if (!noLog) writeLogFile()
          reallyExit(er)
        }
      } else {
        if (!noLog &amp;&amp; code) writeLogFile()
        reallyExit()
      }
    })
    rollbacks.length = 0
  } else if (code &amp;&amp; !noLog) {
    writeLogFile()
  } else {
    reallyExit()
  }

  function reallyExit (er) {
    if (er &amp;&amp; !code) code = typeof er.errno === 'number' ? er.errno : 1

    itWorked = !code

    // Exit directly -- nothing in the CLI should still be running in the
    // background at this point, and this makes sure anything left dangling
    // for whatever reason gets thrown away, instead of leaving the CLI open
    //
    // Commands that expect long-running actions should just delay `cb()`
    process.stdout.write('', () =&gt; {
      process.exit(code)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var conf = nopt(types, shorthands)
npm.argv = conf.argv.remain
if (npm.deref(npm.argv[0])) npm.command = npm.argv.shift()
else conf.usage = true

if (conf.version) {
  console.log(npm.version)
  return errorHandler.<span class="apidocCodeKeywordSpan">exit</span>(0)
}

if (conf.versions) {
  npm.command = 'version'
  conf.usage = false
  npm.argv = []
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.exists" id="apidoc.module.npm.exists">module npm.exists</a></h1>


    <h2>
        <a href="#apidoc.element.npm.exists.exists" id="apidoc.element.npm.exists.exists">
        function <span class="apidocSignatureSpan">npm.</span>exists
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight('exists:' + dir, done)
  if (!done) return
  fs.access(dir, fs.F_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.exists.fsAccessImplementation" id="apidoc.element.npm.exists.fsAccessImplementation">
        function <span class="apidocSignatureSpan">npm.exists.</span>fsAccessImplementation
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight('exists:' + dir, done)
  if (!done) return
  fs.access(dir, fs.F_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.exists.fsStatImplementation" id="apidoc.element.npm.exists.fsStatImplementation">
        function <span class="apidocSignatureSpan">npm.exists.</span>fsStatImplementation
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsStatImplementation(dir, done) {
  done = inflight('exists:' + dir, done)
  if (!done) return
  fs.stat(dir, function (er) { done(accessError(dir, er)) })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.explore" id="apidoc.module.npm.explore">module npm.explore</a></h1>


    <h2>
        <a href="#apidoc.element.npm.explore.explore" id="apidoc.element.npm.explore.explore">
        function <span class="apidocSignatureSpan">npm.</span>explore
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function explore(args, cb) {
  if (args.length &lt; 1 || !args[0]) return cb(explore.usage)
  var p = args.shift()

  var cwd = path.resolve(npm.dir, p)
  var opts = {cwd: cwd, stdio: 'inherit'}

  var shellArgs = []
  if (args) {
    if (isWindowsShell) {
      var execCmd = escapeExecPath(args.shift())
      var execArgs = [execCmd].concat(args.map(escapeArg))
      opts.windowsVerbatimArguments = true
      shellArgs = ['/d', '/s', '/c'].concat(execArgs)
    } else {
      shellArgs.unshift('-c')
      shellArgs = ['-c', args.map(escapeArg).join(' ').trim()]
    }
  }

  var sh = npm.config.get('shell')
  fs.stat(cwd, function (er, s) {
    if (er || !s.isDirectory()) {
      return cb(new Error(
        "It doesn't look like " + p + ' is installed.'
      ))
    }

    if (!shellArgs.length) {
      output(
        '\nExploring ' + cwd + '\n' +
          "Type 'exit' or ^D when finished\n"
      )
    }

    var shell = spawn(sh, shellArgs, opts)
    shell.on('close', function (er) {
      // only fail if non-interactive.
      if (!shellArgs.length) return cb()
      cb(er)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.explore.completion" id="apidoc.element.npm.explore.completion">
        function <span class="apidocSignatureSpan">npm.explore.</span>completion
        <span class="apidocSignatureSpan">(opts, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedShallow(opts, filter, cb) {
  if (typeof cb !== 'function') {
    cb = filter
    filter = null
  }
  var conf = opts.conf
  var args = conf.argv.remain
  if (args.length &gt; 3) return cb()
  var local
  var global
  var localDir = npm.dir
  var globalDir = npm.globalDir
  if (npm.config.get('global')) {
    local = []
    next()
  } else {
    fs.readdir(localDir, function (er, pkgs) {
      local = (pkgs || []).filter(function (p) {
        return p.charAt(0) !== '.'
      })
      next()
    })
  }

  fs.readdir(globalDir, function (er, pkgs) {
    global = (pkgs || []).filter(function (p) {
      return p.charAt(0) !== '.'
    })
    next()
  })
  function next () {
    if (!local || !global) return
    filterInstalled(local, global, filter, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.extract" id="apidoc.module.npm.extract">module npm.extract</a></h1>


    <h2>
        <a href="#apidoc.element.npm.extract.extract" id="apidoc.element.npm.extract.extract">
        function <span class="apidocSignatureSpan">npm.</span>extract
        <span class="apidocSignatureSpan">(staging, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extract(staging, pkg, log) {
  log.silly('extract', packageId(pkg))
  const extractTo = moduleStagingPath(staging, pkg)
  if (!pacoteOpts) {
    pacoteOpts = require('../../config/pacote')
  }
  const opts = pacoteOpts({
    integrity: pkg.package._integrity,
    resolved: pkg.package._resolved
  })
  const args = [
    pkg.package._requested,
    extractTo,
    opts
  ]
  return BB.fromNode((cb) =&gt; {
    let launcher = localWorker
    let msg = args
    const spec = typeof args[0] === 'string' ? npa(args[0]) : args[0]
    args[0] = spec.raw
    if (ENABLE_WORKERS &amp;&amp; (isRegistry(spec) || spec.type === 'remote')) {
      // We can't serialize these options
      opts.loglevel = opts.log.level
      opts.log = null
      opts.dirPacker = null
      // workers will run things in parallel!
      launcher = workers
      try {
        msg = JSON.stringify(msg)
      } catch (e) {
        return cb(e)
      }
    }
    launcher(msg, cb)
  }).then(() =&gt; {
    if (pkg.package.bundleDependencies || anyBundled(pkg)) {
      return readBundled(pkg, staging, extractTo)
    }
  }).then(() =&gt; {
    return gentlyRm(path.join(extractTo, 'node_modules'))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  })
}

cache.unpack = unpack
function unpack (pkg, ver, unpackTarget, dmode, fmode, uid, gid) {
  return unbuild([unpackTarget], true).then(() =&gt; {
    const opts = pacoteOpts({dmode, fmode, uid, gid, offline: true})
    return pacote.<span class="apidocCodeKeywordSpan">extract</span>(npa.resolve(pkg, ver), unpackTarget, opts)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.extract.init" id="apidoc.element.npm.extract.init">
        function <span class="apidocSignatureSpan">npm.extract.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  if (ENABLE_WORKERS) {
    workers = workerFarm({
      maxConcurrentCallsPerWorker: npm.limit.fetch,
      maxRetries: 1
    }, WORKER_PATH)
  }
  return BB.resolve()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function timeEnd (log) {
process.emit('timeEnd', 'action:' + log.name)
}

function withInit (action, body) {
return BB.using(
  action.<span class="apidocCodeKeywordSpan">init</span>().disposer(() =&gt; action.teardown()),
  body
)
}

function prepareAction (action, staging, log) {
validate('ASO', arguments)
validate('SO', action)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.extract.teardown" id="apidoc.element.npm.extract.teardown">
        function <span class="apidocSignatureSpan">npm.extract.</span>teardown
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">() =&gt; {
  if (ENABLE_WORKERS) {
    workerFarm.end(workers)
    workers = null
  }
  return BB.resolve()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function timeEnd (log) {
process.emit('timeEnd', 'action:' + log.name)
}

function withInit (action, body) {
return BB.using(
  action.init().disposer(() =&gt; action.<span class="apidocCodeKeywordSpan">teardown</span>()),
  body
)
}

function prepareAction (action, staging, log) {
validate('ASO', arguments)
validate('SO', action)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.fetch_opts" id="apidoc.module.npm.fetch_opts">module npm.fetch_opts</a></h1>


    <h2>
        <a href="#apidoc.element.npm.fetch_opts.fromPacote" id="apidoc.element.npm.fetch_opts.fromPacote">
        function <span class="apidocSignatureSpan">npm.fetch_opts.</span>fromPacote
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromPacote(opts) {
  return {
    cache: getCacheMode(opts),
    cacheManager: opts.cache,
    ca: opts.ca,
    cert: opts.cert,
    headers: getHeaders('', opts.registry, opts),
    key: opts.key,
    localAddress: opts.localAddress,
    maxSockets: opts.maxSockets,
    proxy: opts.proxy,
    referer: opts.refer,
    retry: opts.retry,
    strictSSL: !!opts.strictSSL,
    timeout: opts.timeout,
    uid: opts.uid,
    gid: opts.gid
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  log: log,
  creds: creds,
  registry: registry,
  auth: {
    otp: npm.config.get('otp')
  },
  scope: scope,
  opts: fetchOpts.<span class="apidocCodeKeywordSpan">fromPacote</span>(pacoteOpts())
}
login(conf).then((newCreds) =&gt; cb(null, newCreds)).catch(cb)
}

function login (conf) {
return profile.login(openerPromise, loginPrompter, conf)
.catch((err) =&gt; {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.fetch_package_metadata" id="apidoc.module.npm.fetch_package_metadata">module npm.fetch_package_metadata</a></h1>


    <h2>
        <a href="#apidoc.element.npm.fetch_package_metadata.fetch_package_metadata" id="apidoc.element.npm.fetch_package_metadata.fetch_package_metadata">
        function <span class="apidocSignatureSpan">npm.</span>fetch_package_metadata
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function limited() {
  var self = this
  var args = Array.prototype.slice.call(arguments)
  if (running &gt;= maxRunning) {
    queue.push({self: this, args: args})
    return
  }
  var cb = typeof args[args.length-1] === 'function' &amp;&amp; args.pop()
  ++ running
  args.push(function () {
    var cbargs = arguments
    -- running
    cb &amp;&amp; process.nextTick(function () {
      cb.apply(self, cbargs)
    })
    if (queue.length) {
      var next = queue.shift()
      limited.apply(next.self, next.args)
    }
  })
  func.apply(self, args)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.fetch_package_metadata.addBundled" id="apidoc.element.npm.fetch_package_metadata.addBundled">
        function <span class="apidocSignatureSpan">npm.fetch_package_metadata.</span>addBundled
        <span class="apidocSignatureSpan">(pkg, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addBundled(pkg, next) {
  validate('OF', arguments)
  if (!pacoteOpts) {
    pacoteOpts = require('./config/pacote')
  }
  if (pkg._bundled !== undefined) return next(null, pkg)

  if (!pkg.bundleDependencies &amp;&amp; pkg._requested.type !== 'directory') return next(null, pkg)
  const requested = pkg._requested || npa(pkg._from)
  if (requested.type === 'directory') {
    pkg._bundled = null
    return readPackageTree(pkg._requested.fetchSpec, function (er, tree) {
      if (tree) pkg._bundled = tree.children
      return next(null, pkg)
    })
  }
  pkg._bundled = null
  const target = tempFilename('unpack')
  const opts = pacoteOpts({integrity: pkg._integrity})
  pacote.extract(pkg._resolved || pkg._requested || npa.resolve(pkg.name, pkg.version), target, opts).then(() =&gt; {
    log.silly('addBundled', 'read tarball')
    readPackageTree(target, (err, tree) =&gt; {
      if (err) { return next(err) }
      log.silly('cleanup', 'remove extracted module')
      rimraf(target, function () {
        if (tree) {
          pkg._bundled = tree.children
        }
        next(null, pkg)
      })
    })
  }, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.finalize" id="apidoc.module.npm.finalize">module npm.finalize</a></h1>


    <h2>
        <a href="#apidoc.element.npm.finalize.finalize" id="apidoc.element.npm.finalize.finalize">
        function <span class="apidocSignatureSpan">npm.</span>finalize
        <span class="apidocSignatureSpan">(staging, pkg, log)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function (staging, pkg, log) {
  log.silly('finalize', pkg.realpath)

  const extractedTo = moduleStagingPath(staging, pkg)

  const delpath = path.join(path.dirname(pkg.realpath), '.' + path.basename(pkg.realpath) + '.DELETE')
  let movedDestAway = false

  const requested = pkg.package._requested || getRequested(pkg)
  if (requested.type === 'directory') {
    const relative = path.relative(path.dirname(pkg.path), pkg.realpath)
    return makeParentPath(pkg.path)
      .then(() =&gt; symlink(relative, pkg.path, 'junction'))
      .catch((ex) =&gt; {
        return rimraf(pkg.path).then(() =&gt; symlink(relative, pkg.path, 'junction'))
      })
  } else {
    return makeParentPath(pkg.realpath)
      .then(moveStagingToDestination)
      .then(restoreOldNodeModules)
      .catch((err) =&gt; {
        if (movedDestAway) {
          return rimraf(pkg.realpath).then(moveOldDestinationBack).then(() =&gt; {
            throw err
          })
        } else {
          throw err
        }
      })
      .then(() =&gt; rimraf(delpath))
  }

  function makeParentPath (dir) {
    return mkdirp(path.dirname(dir))
  }

  function moveStagingToDestination () {
    return destinationIsClear()
      .then(actuallyMoveStaging)
      .catch(() =&gt; moveOldDestinationAway().then(actuallyMoveStaging))
  }

  function destinationIsClear () {
    return lstat(pkg.realpath).then(() =&gt; {
      throw new Error('destination exists')
    }, () =&gt; {})
  }

  function actuallyMoveStaging () {
    return move(extractedTo, pkg.realpath, moveOpts)
  }

  function moveOldDestinationAway () {
    return rimraf(delpath).then(() =&gt; {
      return move(pkg.realpath, delpath, moveOpts)
    }).then(() =&gt; { movedDestAway = true })
  }

  function moveOldDestinationBack () {
    return move(delpath, pkg.realpath, moveOpts).then(() =&gt; { movedDestAway = false })
  }

  function restoreOldNodeModules () {
    if (!movedDestAway) return
    return readdir(path.join(delpath, 'node_modules')).catch(() =&gt; []).then((modules) =&gt; {
      if (!modules.length) return
      return mkdirp(path.join(pkg.realpath, 'node_modules')).then(() =&gt; Bluebird.map(modules, (file) =&gt; {
        const from = path.join(delpath, 'node_modules', file)
        const to = path.join(pkg.realpath, 'node_modules', file)
        return move(from, to, moveOpts)
      }))
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.finalize.rollback" id="apidoc.element.npm.finalize.rollback">
        function <span class="apidocSignatureSpan">npm.finalize.</span>rollback
        <span class="apidocSignatureSpan">(top, staging, pkg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (top, staging, pkg) {
  return Bluebird.try(() =&gt; {
    const requested = pkg.package._requested || getRequested(pkg)
    if (requested &amp;&amp; requested.type === 'directory') return Promise.resolve()
    // strictly speaking rolling back a finalize should ONLY remove module that
    // was being finalized, not any of the things under it. But currently
    // those modules are guaranteed to be useless so we may as well remove them too.
    // When/if we separate `commit` step and can rollback to previous versions
    // of upgraded modules then we'll need to revisit thisâ€¦
    return gentlyRm(pkg.path, false, top).catch((err) =&gt; {
      log.warn('rollback', `Rolling back ${packageId(pkg)} failed (this is probably harmless): ${err.message ? err.message : err
}`)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.flatten_tree" id="apidoc.module.npm.flatten_tree">module npm.flatten_tree</a></h1>


    <h2>
        <a href="#apidoc.element.npm.flatten_tree.flatten_tree" id="apidoc.element.npm.flatten_tree.flatten_tree">
        function <span class="apidocSignatureSpan">npm.</span>flatten_tree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flattenTree(tree) {
  validate('O', arguments)
  var seen = new Set()
  var flat = {}
  var todo = [[tree, '/']]
  while (todo.length) {
    var next = todo.shift()
    var pkg = next[0]
    seen.add(pkg)
    var path = next[1]
    flat[path] = pkg
    if (path !== '/') path += '/'
    for (var ii = 0; ii &lt; pkg.children.length; ++ii) {
      var child = pkg.children[ii]
      if (!seen.has(child)) {
        todo.push([child, flatName(path, child)])
      }
    }
  }
  return flat
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.flatten_tree.flatName" id="apidoc.element.npm.flatten_tree.flatName">
        function <span class="apidocSignatureSpan">npm.flatten_tree.</span>flatName
        <span class="apidocSignatureSpan">(path, child)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatName(path, child) {
  validate('SO', arguments)
  return path + (moduleName(child) || 'TOP')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.flatten_tree.flatNameFromTree" id="apidoc.element.npm.flatten_tree.flatNameFromTree">
        function <span class="apidocSignatureSpan">npm.flatten_tree.</span>flatNameFromTree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function flatNameFromTree(tree) {
  validate('O', arguments)
  if (tree.isTop) return '/'
  var path = flatNameFromTree(tree.parent)
  if (path !== '/') path += '/'
  return flatName(path, tree)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.help" id="apidoc.module.npm.help">module npm.help</a></h1>


    <h2>
        <a href="#apidoc.element.npm.help.help" id="apidoc.element.npm.help.help">
        function <span class="apidocSignatureSpan">npm.</span>help
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function help(args, cb) {
  var argv = npm.config.get('argv').cooked

  var argnum = 0
  if (args.length === 2 &amp;&amp; ~~args[0]) {
    argnum = ~~args.shift()
  }

  // npm help foo bar baz: search topics
  if (args.length &gt; 1 &amp;&amp; args[0]) {
    return npm.commands['help-search'](args, argnum, cb)
  }

  var section = npm.deref(args[0]) || args[0]

  // npm help &lt;noargs&gt;:  show basic usage
  if (!section) {
    var valid = argv[0] === 'help' ? 0 : 1
    return npmUsage(valid, cb)
  }

  // npm &lt;command&gt; -h: show command usage
  if (npm.config.get('usage') &amp;&amp;
      npm.commands[section] &amp;&amp;
      npm.commands[section].usage) {
    npm.config.set('loglevel', 'silent')
    log.level = 'silent'
    output(npm.commands[section].usage)
    return cb()
  }

  // npm apihelp &lt;section&gt;: Prefer section 3 over section 1
  var apihelp = argv.length &amp;&amp; argv[0].indexOf('api') !== -1
  var pref = apihelp ? [3, 1, 5, 7] : [1, 3, 5, 7]
  if (argnum) {
    pref = [ argnum ].concat(pref.filter(function (n) {
      return n !== argnum
    }))
  }

  // npm help &lt;section&gt;: Try to find the path
  var manroot = path.resolve(__dirname, '..', 'man')

  // legacy
  if (section === 'global') section = 'folders'
  else if (section === 'json') section = 'package.json'

  // find either /section.n or /npm-section.n
  // The glob is used in the glob.  The regexp is used much
  // further down.  Globs and regexps are different
  var compextglob = '.+(gz|bz2|lzma|[FYzZ]|xz)'
  var compextre = '\\.(gz|bz2|lzma|[FYzZ]|xz)$'
  var f = '+(npm-' + section + '|' + section + ').[0-9]?(' + compextglob + ')'
  return glob(manroot + '/*/' + f, function (er, mans) {
    if (er) return cb(er)

    if (!mans.length) return npm.commands['help-search'](args, cb)

    mans = mans.map(function (man) {
      var ext = path.extname(man)
      if (man.match(new RegExp(compextre))) man = path.basename(man, ext)

      return man
    })

    viewMan(pickMan(mans, pref), cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    hits: found,
    totalHits: totalHits
  })
})

// if only one result, then just show that help section.
if (results.length === 1) {
  return npm.commands.<span class="apidocCodeKeywordSpan">help</span>([results[0].file.replace(/\.md$/, '')], cb)
}

if (results.length === 0) {
  output('No results for ' + args.map(JSON.stringify).join(' '))
  return cb()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.help.completion" id="apidoc.element.npm.help.completion">
        function <span class="apidocSignatureSpan">npm.help.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  if (opts.conf.argv.remain.length &gt; 2) return cb(null, [])
  getSections(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.install" id="apidoc.module.npm.install">module npm.install</a></h1>


    <h2>
        <a href="#apidoc.element.npm.install.install" id="apidoc.element.npm.install.install">
        function <span class="apidocSignatureSpan">npm.</span>install
        <span class="apidocSignatureSpan">(where, args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function install(where, args, cb) {
  if (!cb) {
    cb = args
    args = where
    where = null
  }
  var globalTop = path.resolve(npm.globalDir, '..')
  if (!where) {
    where = npm.config.get('global')
          ? globalTop
          : npm.prefix
  }
  validate('SAF', [where, args, cb])
  // the /path/to/node_modules/..
  var dryrun = !!npm.config.get('dry-run')

  if (npm.config.get('dev')) {
    log.warn('install', 'Usage of the `--dev` option is deprecated. Use `--only=dev` instead.')
  }

  if (where === globalTop &amp;&amp; !args.length) {
    args = ['.']
  }
  args = args.filter(function (a) {
    return path.resolve(a) !== npm.prefix
  })

  new Installer(where, dryrun, args).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// if it's a folder, a random not-installed thing, or not a scoped package,
// then link or install it first
if (pkg[0] !== '@' &amp;&amp; (pkg.indexOf('/') !== -1 || pkg.indexOf('\\') !== -1)) {
  return fs.lstat(path.resolve(pkg), function (er, st) {
    if (er || !st.isDirectory()) {
      npm.commands.<span class="apidocCodeKeywordSpan">install</span>(t, pkg, n)
    } else {
      rp = path.resolve(pkg)
      linkPkg(rp, n)
    }
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.install.Installer" id="apidoc.element.npm.install.Installer">
        function <span class="apidocSignatureSpan">npm.install.</span>Installer
        <span class="apidocSignatureSpan">(where, dryrun, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Installer(where, dryrun, args, opts) {
  validate('SBA|SBAO', arguments)
  if (!opts) opts = {}
  this.where = where
  this.dryrun = dryrun
  this.args = args
  // fakechildren are children created from the lockfile and lack relationship data
  // the only exist when the tree does not match the lockfile
  // this is fine when doing full tree installs/updates but not ok when modifying only
  // a few deps via `npm install` or `npm uninstall`.
  this.currentTree = null
  this.idealTree = null
  this.differences = []
  this.todo = []
  this.progress = {}
  this.noPackageJsonOk = !!args.length
  this.topLevelLifecycles = !args.length

  this.autoPrune = npm.config.get('package-lock')

  const dev = npm.config.get('dev')
  const only = npm.config.get('only')
  const onlyProd = /^prod(uction)?$/.test(only)
  const onlyDev = /^dev(elopment)?$/.test(only)
  const prod = npm.config.get('production')
  this.dev = opts.dev != null ? opts.dev : dev || (!onlyProd &amp;&amp; !prod) || onlyDev
  this.prod = opts.prod != null ? opts.prod : !onlyDev

  this.packageLockOnly = opts.packageLockOnly != null
    ? opts.packageLockOnly : npm.config.get('package-lock-only')
  this.rollback = opts.rollback != null ? opts.rollback : npm.config.get('rollback')
  this.link = opts.link != null ? opts.link : npm.config.get('link')
  this.saveOnlyLock = opts.saveOnlyLock
  this.global = opts.global != null ? opts.global : this.where === path.resolve(npm.globalDir, '..')
  this.started = Date.now()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.install.completion" id="apidoc.element.npm.install.completion">
        function <span class="apidocSignatureSpan">npm.install.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  validate('OF', arguments)
  // install can complete to a folder with a package.json, or any package.
  // if it has a slash, then it's gotta be a folder
  // if it starts with https?://, then just give up, because it's a url
  if (/^https?:\/\//.test(opts.partialWord)) {
    // do not complete to URLs
    return cb(null, [])
  }

  if (/\//.test(opts.partialWord)) {
    // Complete fully to folder if there is exactly one match and it
    // is a folder containing a package.json file.  If that is not the
    // case we return 0 matches, which will trigger the default bash
    // complete.
    var lastSlashIdx = opts.partialWord.lastIndexOf('/')
    var partialName = opts.partialWord.slice(lastSlashIdx + 1)
    var partialPath = opts.partialWord.slice(0, lastSlashIdx)
    if (partialPath === '') partialPath = '/'

    var annotatePackageDirMatch = function (sibling, cb) {
      var fullPath = path.join(partialPath, sibling)
      if (sibling.slice(0, partialName.length) !== partialName) {
        return cb(null, null) // not name match
      }
      fs.readdir(fullPath, function (err, contents) {
        if (err) return cb(null, { isPackage: false })

        cb(
          null,
          {
            fullPath: fullPath,
            isPackage: contents.indexOf('package.json') !== -1
          }
        )
      })
    }

    return fs.readdir(partialPath, function (err, siblings) {
      if (err) return cb(null, []) // invalid dir: no matching

      asyncMap(siblings, annotatePackageDirMatch, function (err, matches) {
        if (err) return cb(err)

        var cleaned = matches.filter(function (x) { return x !== null })
        if (cleaned.length !== 1) return cb(null, [])
        if (!cleaned[0].isPackage) return cb(null, [])

        // Success - only one match and it is a package dir
        return cb(null, [cleaned[0].fullPath])
      })
    })
  }

  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.legacy" id="apidoc.module.npm.legacy">module npm.legacy</a></h1>


    <h2>
        <a href="#apidoc.element.npm.legacy.login" id="apidoc.element.npm.legacy.login">
        function <span class="apidocSignatureSpan">npm.legacy.</span>login
        <span class="apidocSignatureSpan">(creds, registry, scope, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(creds, registry, scope, cb) =&gt; {
  const conf = {
    log: log,
    creds: creds,
    registry: registry,
    auth: {
      otp: npm.config.get('otp')
    },
    scope: scope,
    opts: fetchOpts.fromPacote(pacoteOpts())
  }
  login(conf).then((newCreds) =&gt; cb(null, newCreds)).catch(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log.disableProgress()

try {
  var auth = require('./auth/' + npm.config.get('auth-type'))
} catch (e) {
  return cb(new Error('no such auth module'))
}
auth.<span class="apidocCodeKeywordSpan">login</span>(creds, registry, scope, function (err, newCreds) {
  if (err) return cb(err)

  npm.config.del('_token', 'user') // prevent legacy pollution
  if (scope) npm.config.set(scope + ':registry', registry, 'user')
  npm.config.setCredentialsByURI(registry, newCreds)
  npm.config.save('user', cb)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.link" id="apidoc.module.npm.link">module npm.link</a></h1>


    <h2>
        <a href="#apidoc.element.npm.link.link" id="apidoc.element.npm.link.link">
        function <span class="apidocSignatureSpan">npm.</span>link
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function link(args, cb) {
  if (process.platform === 'win32') {
    var semver = require('semver')
    if (!semver.gte(process.version, '0.7.9')) {
      var msg = 'npm link not supported on windows prior to node 0.7.9'
      var e = new Error(msg)
      e.code = 'ENOTSUP'
      e.errno = require('constants').ENOTSUP
      return cb(e)
    }
  }

  if (npm.config.get('global')) {
    return cb(new Error(
      'link should never be --global.\n' +
      'Please re-run this command with --local'
    ))
  }

  if (args.length === 1 &amp;&amp; args[0] === '.') args = []
  if (args.length) return linkInstall(args, cb)
  linkPkg(npm.prefix, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.link.completion" id="apidoc.element.npm.link.completion">
        function <span class="apidocSignatureSpan">npm.link.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var dir = npm.globalDir
  fs.readdir(dir, function (er, files) {
    cb(er, files.filter(function (f) {
      return !f.match(/^[\._-]/)
    }))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.locker" id="apidoc.module.npm.locker">module npm.locker</a></h1>


    <h2>
        <a href="#apidoc.element.npm.locker.lock" id="apidoc.element.npm.locker.lock">
        function <span class="apidocSignatureSpan">npm.locker.</span>lock
        <span class="apidocSignatureSpan">(base, name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lock(base, name, cb) {
  var lockDir = resolve(npm.cache, '_locks')
  correctMkdir(lockDir, function (er) {
    if (er) return cb(er)

    var opts = {
      stale: npm.config.get('cache-lock-stale'),
      retries: npm.config.get('cache-lock-retries'),
      wait: npm.config.get('cache-lock-wait')
    }
    var lf = lockFileName(base, name)
    lockfile.lock(lf, opts, function (er) {
      if (er) log.warn('locking', lf, 'failed', er)

      if (!er) {
        log.verbose('lock', 'using', lf, 'for', resolve(base, name))
        installLocks[lf] = true
      }

      cb(er)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.locker.unlock" id="apidoc.element.npm.locker.unlock">
        function <span class="apidocSignatureSpan">npm.locker.</span>unlock
        <span class="apidocSignatureSpan">(base, name, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unlock(base, name, cb) {
  var lf = lockFileName(base, name)
  var locked = installLocks[lf]
  if (locked === false) {
    return process.nextTick(cb)
  } else if (locked === true) {
    lockfile.unlock(lf, function (er) {
      if (er) {
        log.warn('unlocking', lf, 'failed', er)
      } else {
        installLocks[lf] = false
        log.verbose('unlock', 'done using', lf, 'for', resolve(base, name))
      }

      cb(er)
    })
  } else {
    var notLocked = new Error(
      'Attempt to unlock ' + resolve(base, name) + ", which hasn't been locked"
    )
    notLocked.code = 'ENOTLOCKED'
    throw notLocked
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.ls" id="apidoc.module.npm.ls">module npm.ls</a></h1>


    <h2>
        <a href="#apidoc.element.npm.ls.ls" id="apidoc.element.npm.ls.ls">
        function <span class="apidocSignatureSpan">npm.</span>ls
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ls(args, silent, cb) {
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }
  var dir = path.resolve(npm.dir, '..')
  readPackageTree(dir, function (_, physicalTree) {
    if (!physicalTree) physicalTree = {package: {}, path: dir}
    physicalTree.isTop = true
    readShrinkwrap.andInflate(physicalTree, function () {
      lsFromTree(dir, computeMetadata(physicalTree), args, silent, cb)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ls.completion" id="apidoc.element.npm.ls.completion">
        function <span class="apidocSignatureSpan">npm.ls.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedDeep(opts, cb) {
  var local
  var global
  var depth = npm.config.get('depth')
  var opt = { depth: depth, dev: true }

  if (npm.config.get('global')) {
    local = []
    next()
  } else {
    readInstalled(npm.prefix, opt, function (er, data) {
      local = getNames(data || {})
      next()
    })
  }

  readInstalled(npm.config.get('prefix'), opt, function (er, data) {
    global = getNames(data || {})
    next()
  })

  function getNames_ (d, n) {
    if (d.realName &amp;&amp; n) {
      if (n[d.realName]) return n
      n[d.realName] = true
    }
    if (!n) n = {}
    Object.keys(d.dependencies || {}).forEach(function (dep) {
      getNames_(d.dependencies[dep], n)
    })
    return n
  }
  function getNames (d) {
    return Object.keys(getNames_(d))
  }

  function next () {
    if (!local || !global) return
    if (!npm.config.get('global')) {
      global = global.map(function (g) {
        return [g, '-g']
      })
    }
    var names = local.concat(global)
    return cb(null, names)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.ls.fromTree" id="apidoc.element.npm.ls.fromTree">
        function <span class="apidocSignatureSpan">npm.ls.</span>fromTree
        <span class="apidocSignatureSpan">(dir, physicalTree, args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromTree = function (dir, physicalTree, args, silent, cb) {
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }

  // npm ls 'foo@~1.3' bar 'baz@&lt;2'
  if (!args) {
    args = []
  } else {
    args = args.map(function (a) {
      if (typeof a === 'object') {
        return [a.package.name, a.package.version, a]
      } else {
        var p = npa(a)
        var name = p.name
        // When version spec is missing, we'll skip using it when filtering.
        // Otherwise, `semver.validRange` would return '*', which won't
        // match prerelease versions.
        var ver = (p.rawSpec &amp;&amp;
                   (semver.validRange(p.rawSpec) || ''))
        return [ name, ver, a ]
      }
    })
  }

  var data = mutateIntoLogicalTree.asReadInstalled(physicalTree)

  pruneNestedExtraneous(data)
  filterByEnv(data)
  filterByLink(data)

  var unlooped = filterFound(unloop(data), args)
  var lite = getLite(unlooped)

  if (silent) return cb(null, data, lite)

  var long = npm.config.get('long')
  var json = npm.config.get('json')
  var out
  if (json) {
    var seen = new Set()
    var d = long ? unlooped : lite
    // the raw data can be circular
    out = JSON.stringify(d, function (k, o) {
      if (typeof o === 'object') {
        if (seen.has(o)) return '[Circular]'
        seen.add(o)
      }
      return o
    }, 2)
  } else if (npm.config.get('parseable')) {
    out = makeParseable(unlooped, long, dir)
  } else if (data) {
    out = makeArchy(unlooped, long, dir)
  }
  output(out)

  if (args.length &amp;&amp; !data._found) process.exitCode = 1

  var er
  // if any errors were found, then complain and exit status 1
  if (lite.problems &amp;&amp; lite.problems.length) {
    er = lite.problems.join('\n')
  }
  cb(er, data, lite)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.metrics" id="apidoc.module.npm.metrics">module npm.metrics</a></h1>


    <h2>
        <a href="#apidoc.element.npm.metrics.save" id="apidoc.element.npm.metrics.save">
        function <span class="apidocSignatureSpan">npm.metrics.</span>save
        <span class="apidocSignatureSpan">(itWorked)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function saveMetrics(itWorked) {
  if (inMetrics) return
  // If the metrics reporter hasn't managed to PUT yet then kill it so that it doesn't
  // step on our updating the anonymous-cli-metrics json
  stopMetrics()
  var metricsFile = path.join(npm.config.get('cache'), 'anonymous-cli-metrics.json')
  var metrics
  try {
    metrics = JSON.parse(fs.readFileSync(metricsFile))
    metrics.metrics.to = new Date().toISOString()
    if (itWorked) {
      ++metrics.metrics.successfulInstalls
    } else {
      ++metrics.metrics.failedInstalls
    }
  } catch (ex) {
    metrics = {
      metricId: uuid.v4(),
      metrics: {
        from: new Date().toISOString(),
        to: new Date().toISOString(),
        successfulInstalls: itWorked ? 1 : 0,
        failedInstalls: itWorked ? 0 : 1
      }
    }
  }
  try {
    fs.writeFileSync(metricsFile, JSON.stringify(metrics))
  } catch (ex) {
    // we couldn't write the error metrics file, um, well, oh well.
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  auth.login(creds, registry, scope, function (err, newCreds) {
    if (err) return cb(err)

    npm.config.del('_token', 'user') // prevent legacy pollution
    if (scope) npm.config.set(scope + ':registry', registry, 'user')
    npm.config.setCredentialsByURI(registry, newCreds)
    npm.config.<span class="apidocCodeKeywordSpan">save</span>('user', cb)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.metrics.send" id="apidoc.element.npm.metrics.send">
        function <span class="apidocSignatureSpan">npm.metrics.</span>send
        <span class="apidocSignatureSpan">(metricsFile, metricsRegistry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sendMetrics(metricsFile, metricsRegistry) {
  inMetrics = true
  var cliMetrics = JSON.parse(fs.readFileSync(metricsFile))
  npm.load({}, function (err) {
    if (err) return
    npm.registry.config.retry.retries = 0
    npm.registry.sendAnonymousCLIMetrics(metricsRegistry, cliMetrics, function (err) {
      if (err) {
        fs.writeFileSync(path.join(path.dirname(metricsFile), 'last-send-metrics-error.txt'), err.stack)
      } else {
        fs.unlinkSync(metricsFile)
      }
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.metrics.start" id="apidoc.element.npm.metrics.start">
        function <span class="apidocSignatureSpan">npm.metrics.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startMetrics() {
  if (inMetrics) return
  // loaded on demand to avoid any recursive deps when `./metrics-launch` requires us.
  var metricsLaunch = require('./metrics-launch.js')
  npm.metricsProcess = metricsLaunch()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.metrics.stop" id="apidoc.element.npm.metrics.stop">
        function <span class="apidocSignatureSpan">npm.metrics.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stopMetrics() {
  if (inMetrics) return
  if (npm.metricsProcess) npm.metricsProcess.kill('SIGKILL')
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.mutate_into_logical_tree" id="apidoc.module.npm.mutate_into_logical_tree">module npm.mutate_into_logical_tree</a></h1>


    <h2>
        <a href="#apidoc.element.npm.mutate_into_logical_tree.mutate_into_logical_tree" id="apidoc.element.npm.mutate_into_logical_tree.mutate_into_logical_tree">
        function <span class="apidocSignatureSpan">npm.</span>mutate_into_logical_tree
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mutate_into_logical_tree = function (tree) {
  validate('O', arguments)

  validateAllPeerDeps(tree, function (tree, pkgname, version) {
    if (!tree.missingPeers) tree.missingPeers = {}
    tree.missingPeers[pkgname] = version
  })

  var flat = flattenTree(tree)

  Object.keys(flat).sort().forEach(function (flatname) {
    var node = flat[flatname]
    if (!(node.requiredBy &amp;&amp; node.requiredBy.length)) return

    if (node.parent) {
      // If a node is a cycle that never reaches the root of the logical
      // tree then we'll leave it attached to the root, or else it
      // would go missing. Further we'll note that this is the node in the
      // cycle that we picked arbitrarily to be the one attached to the root.
      // others will fall
      if (isDisconnectedCycle(node)) {
        node.cycleTop = true
      // Nor do we want to disconnect non-cyclical extraneous modules from the tree.
      } else if (node.requiredBy.length) {
        // regular deps though, we do, as we're moving them into the capable
        // hands of the modules that require them.
        node.parent.children = without(node.parent.children, node)
      }
    }

    node.requiredBy.forEach(function (parentNode) {
      parentNode.children = union(parentNode.children, [node])
    })
  })
  return tree
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.mutate_into_logical_tree.asReadInstalled" id="apidoc.element.npm.mutate_into_logical_tree.asReadInstalled">
        function <span class="apidocSignatureSpan">npm.mutate_into_logical_tree.</span>asReadInstalled
        <span class="apidocSignatureSpan">(tree)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asReadInstalled = function (tree) {
  mutateIntoLogicalTree(tree)
  return translateTree(tree)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var ver = (p.rawSpec &amp;&amp;
                 (semver.validRange(p.rawSpec) || ''))
      return [ name, ver, a ]
    }
  })
}

var data = mutateIntoLogicalTree.<span class="apidocCodeKeywordSpan">asReadInstalled</span>(physicalTree)

pruneNestedExtraneous(data)
filterByEnv(data)
filterByLink(data)

var unlooped = filterFound(unloop(data), args)
var lite = getLite(unlooped)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.no_progress_while_running" id="apidoc.module.npm.no_progress_while_running">module npm.no_progress_while_running</a></h1>


    <h2>
        <a href="#apidoc.element.npm.no_progress_while_running.startRunning" id="apidoc.element.npm.no_progress_while_running.startRunning">
        function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>startRunning
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startRunning = function () {
  if (progressEnabled == null) progressEnabled = log.progressEnabled
  if (progressEnabled) log.disableProgress()
  ++running
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.no_progress_while_running.stopRunning" id="apidoc.element.npm.no_progress_while_running.stopRunning">
        function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>stopRunning
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopRunning = function () {
  --running
  if (progressEnabled &amp;&amp; running === 0) log.enableProgress()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.no_progress_while_running.tillDone" id="apidoc.element.npm.no_progress_while_running.tillDone">
        function <span class="apidocSignatureSpan">npm.no_progress_while_running.</span>tillDone
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noProgressTillDone(cb) {
  startRunning()
  return function () {
    stopRunning()
    cb.apply(this, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.node" id="apidoc.module.npm.node">module npm.node</a></h1>


    <h2>
        <a href="#apidoc.element.npm.node.create" id="apidoc.element.npm.node.create">
        function <span class="apidocSignatureSpan">npm.node.</span>create
        <span class="apidocSignatureSpan">(node, template, isNotTop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">create = function (node, template, isNotTop) {
  if (!template) template = defaultTemplate
  Object.keys(template).forEach(function (key) {
    if (template[key] != null &amp;&amp; typeof template[key] === 'object' &amp;&amp; !(template[key] instanceof Array)) {
      if (!node[key]) node[key] = {}
      return create(node[key], template[key], true)
    }
    if (node[key] != null) return
    node[key] = template[key]
  })
  if (!isNotTop) {
    // isLink is true for the symlink and everything inside it.
    // by contrast, isInLink is true for only the things inside a link
    if (node.isLink == null) node.isLink = isLink(node.parent)
    if (node.isInLink == null) node.isInLink = isInLink(node.parent)
    if (node.fromBundle == null) {
      node.fromBundle = false
    }
  }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Fix typo in `npm install` documentation.
([@watilde](https://github.com/watilde))

#### DEPENDENCY UPDATES

* [`7537fe1`](https://github.com/npm/npm/commit/7537fe1748c27e6f1144b279b256cd3376d5c41c)
`sorted-object@2.0.0`:
Create objects with `{}` instead of `Object.<span class="apidocCodeKeywordSpan">create</span>(null)` to make the results
strictly equal to what, say, parsed JSON would provide.
([@domenic](https://github.com/domenic))
* [`8defb0f`](https://github.com/npm/npm/commit/8defb0f7b3ebdbe15c9ef5036052c10eda7e3161)
`readable-stream@2.0.6`:
Fix sync write issue on 0.10.
([@calvinmetcalf](https://github.com/calvinmetcalf))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.node.reset" id="apidoc.element.npm.node.reset">
        function <span class="apidocSignatureSpan">npm.node.</span>reset
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function (node) {
  reset(node, new Set())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.oauth" id="apidoc.module.npm.oauth">module npm.oauth</a></h1>


    <h2>
        <a href="#apidoc.element.npm.oauth.login" id="apidoc.element.npm.oauth.login">
        function <span class="apidocSignatureSpan">npm.oauth.</span>login
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function login() {
  npm.config.set('sso-type', 'oauth')
  ssoAuth.login.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log.disableProgress()

try {
  var auth = require('./auth/' + npm.config.get('auth-type'))
} catch (e) {
  return cb(new Error('no such auth module'))
}
auth.<span class="apidocCodeKeywordSpan">login</span>(creds, registry, scope, function (err, newCreds) {
  if (err) return cb(err)

  npm.config.del('_token', 'user') // prevent legacy pollution
  if (scope) npm.config.set(scope + ':registry', registry, 'user')
  npm.config.setCredentialsByURI(registry, newCreds)
  npm.config.save('user', cb)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.owner" id="apidoc.module.npm.owner">module npm.owner</a></h1>


    <h2>
        <a href="#apidoc.element.npm.owner.owner" id="apidoc.element.npm.owner.owner">
        function <span class="apidocSignatureSpan">npm.</span>owner
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function owner(args, cb) {
  var action = args.shift()
  switch (action) {
    case 'ls': case 'list': return ls(args[0], cb)
    case 'add': return add(args[0], args[1], cb)
    case 'rm': case 'remove': return rm(args[0], args[1], cb)
    default: return unknown(action, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.owner.completion" id="apidoc.element.npm.owner.completion">
        function <span class="apidocSignatureSpan">npm.owner.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain
  if (argv.length &gt; 4) return cb()
  if (argv.length &lt;= 2) {
    var subs = ['add', 'rm']
    if (opts.partialWord === 'l') subs.push('ls')
    else subs.push('ls', 'list')
    return cb(null, subs)
  }

  npm.commands.whoami([], true, function (er, username) {
    if (er) return cb()

    var un = encodeURIComponent(username)
    var byUser, theUser
    switch (argv[2]) {
      case 'ls':
        // FIXME: there used to be registry completion here, but it stopped
        // making sense somewhere around 50,000 packages on the registry
        return cb()

      case 'rm':
        if (argv.length &gt; 3) {
          theUser = encodeURIComponent(argv[3])
          byUser = '-/by-user/' + theUser + '|' + un
          return mapToRegistry(byUser, npm.config, function (er, uri, auth) {
            if (er) return cb(er)

            console.error(uri)
            npm.registry.get(uri, { auth: auth }, function (er, d) {
              if (er) return cb(er)
              // return the intersection
              return cb(null, d[theUser].filter(function (p) {
                // kludge for server adminery.
                return un === 'isaacs' || d[un].indexOf(p) === -1
              }))
            })
          })
        }
        // else fallthrough
<span class="apidocCodeCommentSpan">        /*eslint no-fallthrough:0*/
</span>      case 'add':
        if (argv.length &gt; 3) {
          theUser = encodeURIComponent(argv[3])
          byUser = '-/by-user/' + theUser + '|' + un
          return mapToRegistry(byUser, npm.config, function (er, uri, auth) {
            if (er) return cb(er)

            console.error(uri)
            npm.registry.get(uri, { auth: auth }, function (er, d) {
              console.error(uri, er || d)
              // return mine that they're not already on.
              if (er) return cb(er)
              var mine = d[un] || []
              var theirs = d[theUser] || []
              return cb(null, mine.filter(function (p) {
                return theirs.indexOf(p) === -1
              }))
            })
          })
        }
        // just list all users who aren't me.
        return mapToRegistry('-/users', npm.config, function (er, uri, auth) {
          if (er) return cb(er)

          npm.registry.get(uri, { auth: auth }, function (er, list) {
            if (er) return cb()
            return cb(null, Object.keys(list).filter(function (n) {
              return n !== un
            }))
          })
        })

      default:
        return cb()
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.pack" id="apidoc.module.npm.pack">module npm.pack</a></h1>


    <h2>
        <a href="#apidoc.element.npm.pack.pack" id="apidoc.element.npm.pack.pack">
        function <span class="apidocSignatureSpan">npm.</span>pack
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pack(args, silent, cb) {
  const cwd = process.cwd()
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }

  if (args.length === 0) args = ['.']

  BB.all(
    args.map((arg) =&gt; pack_(arg, cwd))
  ).then((files) =&gt; {
    if (!silent) {
      output(files.map((f) =&gt; path.relative(cwd, f)).join('\n'))
    }
    cb(null, files)
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.completion" id="apidoc.element.npm.pack.completion">
        function <span class="apidocSignatureSpan">npm.pack.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  validate('OF', arguments)
  // install can complete to a folder with a package.json, or any package.
  // if it has a slash, then it's gotta be a folder
  // if it starts with https?://, then just give up, because it's a url
  if (/^https?:\/\//.test(opts.partialWord)) {
    // do not complete to URLs
    return cb(null, [])
  }

  if (/\//.test(opts.partialWord)) {
    // Complete fully to folder if there is exactly one match and it
    // is a folder containing a package.json file.  If that is not the
    // case we return 0 matches, which will trigger the default bash
    // complete.
    var lastSlashIdx = opts.partialWord.lastIndexOf('/')
    var partialName = opts.partialWord.slice(lastSlashIdx + 1)
    var partialPath = opts.partialWord.slice(0, lastSlashIdx)
    if (partialPath === '') partialPath = '/'

    var annotatePackageDirMatch = function (sibling, cb) {
      var fullPath = path.join(partialPath, sibling)
      if (sibling.slice(0, partialName.length) !== partialName) {
        return cb(null, null) // not name match
      }
      fs.readdir(fullPath, function (err, contents) {
        if (err) return cb(null, { isPackage: false })

        cb(
          null,
          {
            fullPath: fullPath,
            isPackage: contents.indexOf('package.json') !== -1
          }
        )
      })
    }

    return fs.readdir(partialPath, function (err, siblings) {
      if (err) return cb(null, []) // invalid dir: no matching

      asyncMap(siblings, annotatePackageDirMatch, function (err, matches) {
        if (err) return cb(err)

        var cleaned = matches.filter(function (x) { return x !== null })
        if (cleaned.length !== 1) return cb(null, [])
        if (!cleaned[0].isPackage) return cb(null, [])

        // Success - only one match and it is a package dir
        return cb(null, [cleaned[0].fullPath])
      })
    })
  }

  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.packDirectory" id="apidoc.element.npm.pack.packDirectory">
        function <span class="apidocSignatureSpan">npm.pack.</span>packDirectory
        <span class="apidocSignatureSpan">(mani, dir, target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function packDirectory(mani, dir, target) {
  deprCheck(mani)
  return readJson(path.join(dir, 'package.json')).then((pkg) =&gt; {
    return lifecycle(pkg, 'prepack', dir)
  }).then(() =&gt; {
    return readJson(path.join(dir, 'package.json'))
  }).then((pkg) =&gt; {
    return cacache.tmp.withTmp(npm.tmp, {tmpPrefix: 'packing'}, (tmp) =&gt; {
      const tmpTarget = path.join(tmp, path.basename(target))

      const tarOpt = {
        file: tmpTarget,
        cwd: dir,
        prefix: 'package/',
        portable: true,
        // Provide a specific date in the 1980s for the benefit of zip,
        // which is confounded by files dated at the Unix epoch 0.
        mtime: new Date('1985-10-26T08:15:00.000Z'),
        gzip: true
      }

      return packlist({ path: dir })
      // NOTE: node-tar does some Magic Stuff depending on prefixes for files
      //       specifically with @ signs, so we just neutralize that one
      //       and any such future "features" by prepending `./`
        .then((files) =&gt; tar.create(tarOpt, files.map((f) =&gt; `./${f}`)))
        .then(() =&gt; move(tmpTarget, target, {Promise: BB, fs}))
        .then(() =&gt; lifecycle(pkg, 'postpack', dir))
        .then(() =&gt; target)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}).then((pkg) =&gt; {
  return lifecycle(pkg, 'prepublishOnly', arg)
}).then(() =&gt; {
  return readJson(path.join(arg, 'package.json'))
}).then((pkg) =&gt; {
  return cacache.tmp.withTmp(npm.tmp, {tmpPrefix: 'fromDir'}, (tmpDir) =&gt; {
    const target = path.join(tmpDir, 'package.tgz')
    return pack.<span class="apidocCodeKeywordSpan">packDirectory</span>(pkg, arg, target).then(() =&gt; {
      return upload(arg, pkg, false, target)
    })
  })
}).then(() =&gt; {
  return readJson(path.join(arg, 'package.json'))
}).tap((pkg) =&gt; {
  return lifecycle(pkg, 'publish', arg)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.packGitDep" id="apidoc.element.npm.pack.packGitDep">
        function <span class="apidocSignatureSpan">npm.pack.</span>packGitDep
        <span class="apidocSignatureSpan">(manifest, dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function packGitDep(manifest, dir) {
  const stream = new PassThrough()
  readJson(path.join(dir, 'package.json')).then((pkg) =&gt; {
    if (pkg.scripts &amp;&amp; pkg.scripts.prepare) {
      log.verbose('prepareGitDep', `${manifest._spec}: installing devDeps and running prepare script.`)
      const cliArgs = PASSTHROUGH_OPTS.reduce((acc, opt) =&gt; {
        if (npm.config.get(opt, 'cli') != null) {
          acc.push(`--${opt}=${npm.config.get(opt)}`)
        }
        return acc
      }, [])
      const child = cp.spawn(process.env.NODE || process.execPath, [
        require.resolve('../bin/npm-cli.js'),
        'install',
        '--dev',
        '--prod',
        '--ignore-prepublish',
        '--no-progress',
        '--no-save'
      ].concat(cliArgs), {
        cwd: dir,
        env: process.env
      })
      let errData = []
      let errDataLen = 0
      let outData = []
      let outDataLen = 0
      child.stdout.on('data', (data) =&gt; {
        outData.push(data)
        outDataLen += data.length
        log.gauge.pulse('preparing git package')
      })
      child.stderr.on('data', (data) =&gt; {
        errData.push(data)
        errDataLen += data.length
        log.gauge.pulse('preparing git package')
      })
      return BB.fromNode((cb) =&gt; {
        child.on('error', cb)
        child.on('exit', (code, signal) =&gt; {
          if (code &gt; 0) {
            const err = new Error(`${signal}: npm exited with code ${code} while attempting to build ${manifest._requested}. Clone
 the repository manually and run 'npm install' in it for more information.`)
            err.code = code
            err.signal = signal
            cb(err)
          } else {
            cb()
          }
        })
      }).then(() =&gt; {
        if (outDataLen &gt; 0) log.silly('prepareGitDep', '1&gt;', Buffer.concat(outData, outDataLen).toString())
        if (errDataLen &gt; 0) log.silly('prepareGitDep', '2&gt;', Buffer.concat(errData, errDataLen).toString())
      }, (err) =&gt; {
        if (outDataLen &gt; 0) log.error('prepareGitDep', '1&gt;', Buffer.concat(outData, outDataLen).toString())
        if (errDataLen &gt; 0) log.error('prepareGitDep', '2&gt;', Buffer.concat(errData, errDataLen).toString())
        throw err
      })
    }
  }).then(() =&gt; {
    return readJson(path.join(dir, 'package.json'))
  }).then((pkg) =&gt; {
    return cacache.tmp.withTmp(npm.tmp, {
      tmpPrefix: 'pacote-packing'
    }, (tmp) =&gt; {
      const tmpTar = path.join(tmp, 'package.tgz')
      return packDirectory(manifest, dir, tmpTar).then(() =&gt; {
        return pipe(fs.createReadStream(tmpTar), stream)
      })
    })
  }).catch((err) =&gt; stream.emit('error', err))
  return stream
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pack.prepareDirectory" id="apidoc.element.npm.pack.prepareDirectory">
        function <span class="apidocSignatureSpan">npm.pack.</span>prepareDirectory
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prepareDirectory(dir) {
  return readJson(path.join(dir, 'package.json')).then((pkg) =&gt; {
    if (!pkg.name) {
      throw new Error('package.json requires a "name" field')
    }
    if (!pkg.version) {
      throw new Error('package.json requires a valid "version" field')
    }
    if (!pathIsInside(dir, npm.tmp)) {
      if (pkg.scripts &amp;&amp; pkg.scripts.prepublish) {
        prepublishWarning([
          'As of npm@5, `prepublish` scripts are deprecated.',
          'Use `prepare` for build steps and `prepublishOnly` for upload-only.',
          'See the deprecation note in `npm help scripts` for more information.'
        ])
      }
      if (npm.config.get('ignore-prepublish')) {
        return lifecycle(pkg, 'prepare', dir).then(() =&gt; pkg)
      } else {
        return lifecycle(pkg, 'prepublish', dir).then(() =&gt; {
          return lifecycle(pkg, 'prepare', dir)
        }).then(() =&gt; pkg)
      }
    }
    return pkg
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
})
}

function publishFromDirectory (arg) {
// All this readJson is because any of the given scripts might modify the
// package.json in question, so we need to refresh after every step.
return pack.<span class="apidocCodeKeywordSpan">prepareDirectory</span>(arg).then(() =&gt; {
  return readJson(path.join(arg, 'package.json'))
}).then((pkg) =&gt; {
  return lifecycle(pkg, 'prepublishOnly', arg)
}).then(() =&gt; {
  return readJson(path.join(arg, 'package.json'))
}).then((pkg) =&gt; {
  return cacache.tmp.withTmp(npm.tmp, {tmpPrefix: 'fromDir'}, (tmpDir) =&gt; {
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.parse_json" id="apidoc.module.npm.parse_json">module npm.parse_json</a></h1>


    <h2>
        <a href="#apidoc.element.npm.parse_json.parse_json" id="apidoc.element.npm.parse_json.parse_json">
        function <span class="apidocSignatureSpan">npm.</span>parse_json
        <span class="apidocSignatureSpan">(content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse_json = function (content) {
  return parseJsonWithErrors(stripBOM(content))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.parse_json.noExceptions" id="apidoc.element.npm.parse_json.noExceptions">
        function <span class="apidocSignatureSpan">npm.parse_json.</span>noExceptions
        <span class="apidocSignatureSpan">(content)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noExceptions = function (content) {
  try {
    return parseJSON(content)
  } catch (ex) {
    return
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function isLinkable (pkg, cb) {
var globalPackage = path.resolve(npm.globalPrefix, 'lib', 'node_modules', moduleName(pkg))
var globalPackageJson = path.resolve(globalPackage, 'package.json')
fs.stat(globalPackage, function (er) {
  if (er) return cb(true, true)
  fs.readFile(globalPackageJson, function (er, data) {
    var json = parseJSON.<span class="apidocCodeKeywordSpan">noExceptions</span>(data)
    cb(false, json &amp;&amp; json.version === pkg.package.version)
  })
})
}

Installer.prototype.executeActions = function (cb) {
validate('F', arguments)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.profile" id="apidoc.module.npm.profile">module npm.profile</a></h1>


    <h2>
        <a href="#apidoc.element.npm.profile.profile" id="apidoc.element.npm.profile.profile">
        function <span class="apidocSignatureSpan">npm.</span>profile
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function profileCmd(args, cb) {
  if (args.length === 0) return cb(new Error(profileCmd.usage))
  log.gauge.show('profile')
  switch (args[0]) {
    case 'enable-2fa':
    case 'enable-tfa':
    case 'enable2fa':
    case 'enabletfa':
      withCb(enable2fa(args.slice(1)), cb)
      break
    case 'disable-2fa':
    case 'disable-tfa':
    case 'disable2fa':
    case 'disabletfa':
      withCb(disable2fa(), cb)
      break
    case 'get':
      withCb(get(args.slice(1)), cb)
      break
    case 'set':
      withCb(set(args.slice(1)), cb)
      break
    default:
      cb(new Error('Unknown profile command: ' + args[0]))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.profile.completion" id="apidoc.element.npm.profile.completion">
        function <span class="apidocSignatureSpan">npm.profile.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain
  switch (argv[2]) {
    case 'enable-2fa':
    case 'enable-tfa':
      if (argv.length === 3) {
        return cb(null, qw`auth-and-writes auth-only`)
      } else {
        return cb(null, [])
      }
    case 'disable-2fa':
    case 'disable-tfa':
    case 'get':
    case 'set':
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + ' not recognized'))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.prune" id="apidoc.module.npm.prune">module npm.prune</a></h1>


    <h2>
        <a href="#apidoc.element.npm.prune.prune" id="apidoc.element.npm.prune.prune">
        function <span class="apidocSignatureSpan">npm.</span>prune
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prune(args, cb) {
  var dryrun = !!npm.config.get('dry-run')
  new Pruner('.', dryrun, args).run(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.prune.Pruner" id="apidoc.element.npm.prune.Pruner">
        function <span class="apidocSignatureSpan">npm.prune.</span>Pruner
        <span class="apidocSignatureSpan">(where, dryrun, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Pruner(where, dryrun, args) {
  Installer.call(this, where, dryrun, args)
  this.autoPrune = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.prune.completion" id="apidoc.element.npm.prune.completion">
        function <span class="apidocSignatureSpan">npm.prune.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedDeep(opts, cb) {
  var local
  var global
  var depth = npm.config.get('depth')
  var opt = { depth: depth, dev: true }

  if (npm.config.get('global')) {
    local = []
    next()
  } else {
    readInstalled(npm.prefix, opt, function (er, data) {
      local = getNames(data || {})
      next()
    })
  }

  readInstalled(npm.config.get('prefix'), opt, function (er, data) {
    global = getNames(data || {})
    next()
  })

  function getNames_ (d, n) {
    if (d.realName &amp;&amp; n) {
      if (n[d.realName]) return n
      n[d.realName] = true
    }
    if (!n) n = {}
    Object.keys(d.dependencies || {}).forEach(function (dep) {
      getNames_(d.dependencies[dep], n)
    })
    return n
  }
  function getNames (d) {
    return Object.keys(getNames_(d))
  }

  function next () {
    if (!local || !global) return
    if (!npm.config.get('global')) {
      global = global.map(function (g) {
        return [g, '-g']
      })
    }
    var names = local.concat(global)
    return cb(null, names)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.publish" id="apidoc.module.npm.publish">module npm.publish</a></h1>


    <h2>
        <a href="#apidoc.element.npm.publish.publish" id="apidoc.element.npm.publish.publish">
        function <span class="apidocSignatureSpan">npm.</span>publish
        <span class="apidocSignatureSpan">(args, isRetry, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publish(args, isRetry, cb) {
  if (typeof cb !== 'function') {
    cb = isRetry
    isRetry = false
  }
  if (args.length === 0) args = ['.']
  if (args.length !== 1) return cb(publish.usage)

  log.verbose('publish', args)

  const t = npm.config.get('tag').trim()
  if (semver.validRange(t)) {
    return cb(new Error('Tag name must not be a valid SemVer range: ' + t))
  }

  publish_(args[0]).then((pkg) =&gt; {
    output(`+ ${pkg._id}`)
    cb()
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  params.access = config.get('access')
}

log.showProgress('publish:' + pkg._id)
return BB.fromNode((cb) =&gt; {
  registry.<span class="apidocCodeKeywordSpan">publish</span>(registryBase, params, cb)
}).catch((err) =&gt; {
  if (
    err.code === 'EPUBLISHCONFLICT' &amp;&amp;
    npm.config.get('force') &amp;&amp;
    !isRetry
  ) {
    log.warn('publish', 'Forced publish over ' + pkg._id)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.publish.completion" id="apidoc.element.npm.publish.completion">
        function <span class="apidocSignatureSpan">npm.publish.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // publish can complete to a folder with a package.json
  // or a tarball, or a tarball url.
  // for now, not yet implemented.
  return cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.pulse_till_done" id="apidoc.module.npm.pulse_till_done">module npm.pulse_till_done</a></h1>


    <h2>
        <a href="#apidoc.element.npm.pulse_till_done.pulse_till_done" id="apidoc.element.npm.pulse_till_done.pulse_till_done">
        function <span class="apidocSignatureSpan">npm.</span>pulse_till_done
        <span class="apidocSignatureSpan">(prefix, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pulse_till_done = function (prefix, cb) {
  validate('SF', [prefix, cb])
  if (!prefix) prefix = 'network'
  pulseStart(prefix)
  return function () {
    pulseStop()
    cb.apply(null, arguments)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.pulse_till_done.withPromise" id="apidoc.element.npm.pulse_till_done.withPromise">
        function <span class="apidocSignatureSpan">npm.pulse_till_done.</span>withPromise
        <span class="apidocSignatureSpan">(prefix, promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pulseWhile(prefix, promise) {
  if (!promise) {
    promise = prefix
    prefix = ''
  }
  pulseStart(prefix)
  return Bluebird.resolve(promise).finally(() =&gt; pulseStop())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const knownProfileKeys = qw`
name email ${'two-factor auth'} fullname homepage
freenode twitter github created updated`

function get (args) {
const tfa = 'two-factor auth'
const conf = config()
return pulseTillDone.<span class="apidocCodeKeywordSpan">withPromise</span>(profile.get(conf)).then((info) =&gt; {
  if (!info.cidr_whitelist) delete info.cidr_whitelist
  if (conf.json) {
    output(JSON.stringify(info, null, 2))
    return
  }
  const cleaned = {}
  knownProfileKeys.forEach((k) =&gt; { cleaned[k] = info[k] || '' })
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.read_shrinkwrap" id="apidoc.module.npm.read_shrinkwrap">module npm.read_shrinkwrap</a></h1>


    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap.read_shrinkwrap" id="apidoc.element.npm.read_shrinkwrap.read_shrinkwrap">
        function <span class="apidocSignatureSpan">npm.</span>read_shrinkwrap
        <span class="apidocSignatureSpan">(child, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readShrinkwrap(child, next) {
  if (child.package._shrinkwrap) return process.nextTick(next)
  BB.join(
    maybeReadFile('npm-shrinkwrap.json', child),
    // Don't read non-root lockfiles
    child.isTop &amp;&amp; maybeReadFile('package-lock.json', child),
    child.isTop &amp;&amp; maybeReadFile('package.json', child),
    (shrinkwrap, lockfile, pkgJson) =&gt; {
      if (shrinkwrap &amp;&amp; lockfile) {
        log.warn('read-shrinkwrap', 'Ignoring package-lock.json because there is already an npm-shrinkwrap.json. Please use only
 one of the two.')
      }
      const name = shrinkwrap ? 'npm-shrinkwrap.json' : 'package-lock.json'
      const parsed = parsePkgLock(shrinkwrap || lockfile, name)
      if (parsed &amp;&amp; parsed.lockfileVersion !== PKGLOCK_VERSION) {
        log.warn('read-shrinkwrap', `This version of npm is compatible with lockfileVersion@${PKGLOCK_VERSION}, but ${name} was
generated for lockfileVersion@${parsed.lockfileVersion || 0}. I'll try to do my best with it!`)
      }
      child.package._shrinkwrap = parsed
    }
  ).then(() =&gt; next(), next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap._isDiff" id="apidoc.element.npm.read_shrinkwrap._isDiff">
        function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>_isDiff
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDiff(str) {
  return str.match(OURS_RE) &amp;&amp; str.match(THEIRS_RE) &amp;&amp; str.match(END_RE)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap._parsePkgLock" id="apidoc.element.npm.read_shrinkwrap._parsePkgLock">
        function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>_parsePkgLock
        <span class="apidocSignatureSpan">(str, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parsePkgLock(str, filename) {
  if (!str) { return null }
  try {
    return parseJSON(str)
  } catch (e) {
    if (isDiff(str)) {
      log.warn('conflict', `A git conflict was detected in ${filename}. Attempting to auto-resolve.`)
      const pieces = str.split(/[\n\r]+/g).reduce((acc, line) =&gt; {
        if (line.match(PARENT_RE)) acc.state = 'parent'
        else if (line.match(OURS_RE)) acc.state = 'ours'
        else if (line.match(THEIRS_RE)) acc.state = 'theirs'
        else if (line.match(END_RE)) acc.state = 'top'
        else {
          if (acc.state === 'top' || acc.state === 'ours') acc.ours += line
          if (acc.state === 'top' || acc.state === 'theirs') acc.theirs += line
          if (acc.state === 'top' || acc.state === 'parent') acc.parent += line
        }
        return acc
      }, {
        state: 'top',
        ours: '',
        theirs: '',
        parent: ''
      })
      try {
        const ours = parseJSON(pieces.ours)
        const theirs = parseJSON(pieces.theirs)
        return reconcileLockfiles(ours, theirs)
      } catch (_e) {
        log.error('conflict', `Automatic conflict resolution failed. Please manually resolve conflicts in ${filename} and try again
.`)
        log.silly('conflict', `Error during resolution: ${_e}`)
        throw e
      }
    } else {
      throw e
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_shrinkwrap.andInflate" id="apidoc.element.npm.read_shrinkwrap.andInflate">
        function <span class="apidocSignatureSpan">npm.read_shrinkwrap.</span>andInflate
        <span class="apidocSignatureSpan">(child, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">andInflate = function (child, next) {
  readShrinkwrap(child, iferr(next, function () {
    if (child.package._shrinkwrap) {
      return inflateShrinkwrap(child, child.package._shrinkwrap || {}, next)
    } else {
      return next()
    }
  }))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.idealTree.warnings = []
cb()
}

Installer.prototype.loadShrinkwrap = function (cb) {
validate('F', arguments)
log.silly('install', 'loadShrinkwrap')
readShrinkwrap.<span class="apidocCodeKeywordSpan">andInflate</span>(this.idealTree, iferr(cb, () =&gt; {
  computeMetadata(this.idealTree)
  cb()
}))
}

Installer.prototype.getInstalledModules = function () {
return this.differences.filter(function (action) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.read_user_info" id="apidoc.module.npm.read_user_info">module npm.read_user_info</a></h1>


    <h2>
        <a href="#apidoc.element.npm.read_user_info.email" id="apidoc.element.npm.read_user_info.email">
        function <span class="apidocSignatureSpan">npm.read_user_info.</span>email
        <span class="apidocSignatureSpan">(msg, email, opts, isRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readEmail(msg, email, opts, isRetry) {
  if (!msg) msg = 'email (this IS public): '
  if (isRetry &amp;&amp; email) {
    const error = userValidate.email(email)
    if (error) {
      opts.log &amp;&amp; opts.log.warn(error.message)
    } else {
      return email.trim()
    }
  }

  return read({prompt: msg, default: email || ''})
    .then((username) =&gt; readEmail(msg, username, opts, true))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const loginPrompter = (creds) =&gt; {
  const opts = { log: log }
  return read.username('Username:', creds.username, opts).then((u) =&gt; {
    creds.username = u
    return read.password('Password:', creds.password)
  }).then((p) =&gt; {
    creds.password = p
    return read.<span class="apidocCodeKeywordSpan">email</span>('Email: (this IS public) ', creds.email, opts)
  }).then((e) =&gt; {
    creds.email = e
    return creds
  })
}

module.exports.login = (creds, registry, scope, cb) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_user_info.otp" id="apidoc.element.npm.read_user_info.otp">
        function <span class="apidocSignatureSpan">npm.read_user_info.</span>otp
        <span class="apidocSignatureSpan">(msg, otp, isRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readOTP(msg, otp, isRetry) {
  if (!msg) msg = 'Enter OTP: '
  if (isRetry &amp;&amp; otp &amp;&amp; /^[\d ]+$|^[A-Fa-f0-9]{64,64}$/.test(otp)) return otp.replace(/\s+/g, '')

  return read({prompt: msg, default: otp || ''})
    .then((otp) =&gt; readOTP(msg, otp, true))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// FIXME: Work around to not clear everything other than what we're setting
return pulseTillDone.withPromise(profile.get(conf).then((user) =&gt; {
  const newUser = {}
  writableProfileKeys.forEach((k) =&gt; { newUser[k] = user[k] })
  newUser[prop] = value
  return profile.set(newUser, conf).catch((err) =&gt; {
    if (err.code !== 'EOTP') throw err
    return readUserInfo.<span class="apidocCodeKeywordSpan">otp</span>('Enter OTP:  ').then((otp) =&gt; {
      conf.auth.otp = otp
      return profile.set(newUser, conf)
    })
  }).then((result) =&gt; {
    if (conf.json) {
      output(JSON.stringify({[prop]: result[prop]}, null, 2))
    } else if (conf.parseable) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_user_info.password" id="apidoc.element.npm.read_user_info.password">
        function <span class="apidocSignatureSpan">npm.read_user_info.</span>password
        <span class="apidocSignatureSpan">(msg, password, isRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readPassword(msg, password, isRetry) {
  if (!msg) msg = 'npm password: '
  if (isRetry &amp;&amp; password) return password

  return read({prompt: msg, silent: true, default: password || ''})
    .then((password) =&gt; readPassword(msg, password, true))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'Do not include your current or new passwords on the command line.'))
}
if (writableProfileKeys.indexOf(prop) === -1) {
  return Promise.reject(Error(`"${prop}" is not a property we can set. Valid properties are: ` + writableProfileKeys.join
(', ')))
}
return Bluebird.try(() =&gt; {
  if (prop === 'password') {
    return readUserInfo.<span class="apidocCodeKeywordSpan">password</span>('Current password: ').then((current) =&gt; {
      return readPasswords().then((newpassword) =&gt; {
        value = {old: current, new: newpassword}
      })
    })
  } else if (prop === 'email') {
    return readUserInfo.password('Password: ').then((current) =&gt; {
      return {password: current, email: value}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.read_user_info.username" id="apidoc.element.npm.read_user_info.username">
        function <span class="apidocSignatureSpan">npm.read_user_info.</span>username
        <span class="apidocSignatureSpan">(msg, username, opts, isRetry)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readUsername(msg, username, opts, isRetry) {
  if (!msg) msg = 'npm username: '
  if (isRetry &amp;&amp; username) {
    const error = userValidate.username(username)
    if (error) {
      opts.log &amp;&amp; opts.log.warn(error.message)
    } else {
      return Promise.resolve(username.trim())
    }
  }

  return read({prompt: msg, default: username || ''})
    .then((username) =&gt; readUsername(msg, username, opts, true))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

const openerPromise = (url) =&gt; new Promise((resolve, reject) =&gt; {
opener(url, { command: npm.config.get('browser') }, (er) =&gt; er ? reject(er) : resolve())
})

const loginPrompter = (creds) =&gt; {
const opts = { log: log }
return read.<span class="apidocCodeKeywordSpan">username</span>('Username:', creds.username, opts).then((u) =&gt; {
  creds.username = u
  return read.password('Password:', creds.password)
}).then((p) =&gt; {
  creds.password = p
  return read.email('Email: (this IS public) ', creds.email, opts)
}).then((e) =&gt; {
  creds.email = e
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.rebuild" id="apidoc.module.npm.rebuild">module npm.rebuild</a></h1>


    <h2>
        <a href="#apidoc.element.npm.rebuild.rebuild" id="apidoc.element.npm.rebuild.rebuild">
        function <span class="apidocSignatureSpan">npm.</span>rebuild
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rebuild(args, cb) {
  var opt = { depth: npm.config.get('depth'), dev: true }
  readInstalled(npm.prefix, opt, function (er, data) {
    log.info('readInstalled', typeof data)
    if (er) return cb(er)
    var set = filter(data, args)
    var folders = Object.keys(set).filter(function (f) {
      return f !== npm.prefix
    })
    if (!folders.length) return cb()
    log.silly('rebuild set', folders)
    cleanBuild(folders, set, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       .join('/node_modules/')
       .replace(/(\/node_modules)+/, '/node_modules')
  var f = path.resolve(npm.dir, p)
  fs.lstat(f, function (er) {
    if (er) return cb(er)
    editor(f, { editor: e }, noProgressTillDone(function (er) {
      if (er) return cb(er)
      npm.commands.<span class="apidocCodeKeywordSpan">rebuild</span>(args, cb)
    }))
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.rebuild.completion" id="apidoc.element.npm.rebuild.completion">
        function <span class="apidocSignatureSpan">npm.rebuild.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedDeep(opts, cb) {
  var local
  var global
  var depth = npm.config.get('depth')
  var opt = { depth: depth, dev: true }

  if (npm.config.get('global')) {
    local = []
    next()
  } else {
    readInstalled(npm.prefix, opt, function (er, data) {
      local = getNames(data || {})
      next()
    })
  }

  readInstalled(npm.config.get('prefix'), opt, function (er, data) {
    global = getNames(data || {})
    next()
  })

  function getNames_ (d, n) {
    if (d.realName &amp;&amp; n) {
      if (n[d.realName]) return n
      n[d.realName] = true
    }
    if (!n) n = {}
    Object.keys(d.dependencies || {}).forEach(function (dep) {
      getNames_(d.dependencies[dep], n)
    })
    return n
  }
  function getNames (d) {
    return Object.keys(getNames_(d))
  }

  function next () {
    if (!local || !global) return
    if (!npm.config.get('global')) {
      global = global.map(function (g) {
        return [g, '-g']
      })
    }
    var names = local.concat(global)
    return cb(null, names)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.repo" id="apidoc.module.npm.repo">module npm.repo</a></h1>


    <h2>
        <a href="#apidoc.element.npm.repo.repo" id="apidoc.element.npm.repo.repo">
        function <span class="apidocSignatureSpan">npm.</span>repo
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repo(args, cb) {
  var n = args.length ? args[0] : '.'
  fetchPackageMetadata(n, '.', {fullMetadata: true}, function (er, d) {
    if (er) return cb(er)
    getUrlAndOpen(d, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.repo.completion" id="apidoc.element.npm.repo.completion">
        function <span class="apidocSignatureSpan">npm.repo.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.restart" id="apidoc.module.npm.restart">module npm.restart</a></h1>


    <h2>
        <a href="#apidoc.element.npm.restart.restart" id="apidoc.element.npm.restart.restart">
        function <span class="apidocSignatureSpan">npm.</span>restart
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands['run-script']([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.restart.completion" id="apidoc.element.npm.restart.completion">
        function <span class="apidocSignatureSpan">npm.restart.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  installedShallow(opts, function (d) {
    return d.scripts &amp;&amp; d.scripts[stage]
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.run_script" id="apidoc.module.npm.run_script">module npm.run_script</a></h1>


    <h2>
        <a href="#apidoc.element.npm.run_script.run_script" id="apidoc.element.npm.run_script.run_script">
        function <span class="apidocSignatureSpan">npm.</span>run_script
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runScript(args, cb) {
  if (!args.length) return list(cb)

  var pkgdir = npm.localPrefix
  var cmd = args.shift()

  readJson(path.resolve(pkgdir, 'package.json'), function (er, d) {
    if (er) return cb(er)
    run(d, pkgdir, cmd, args, cb)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.run_script.completion" id="apidoc.element.npm.run_script.completion">
        function <span class="apidocSignatureSpan">npm.run_script.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // see if there's already a package specified.
  var argv = opts.conf.argv.remain

  if (argv.length &gt;= 4) return cb()

  if (argv.length === 3) {
    // either specified a script locally, in which case, done,
    // or a package, in which case, complete against its scripts
    var json = path.join(npm.localPrefix, 'package.json')
    return readJson(json, function (er, d) {
      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
      if (er) d = {}
      var scripts = Object.keys(d.scripts || {})
      console.error('local scripts', scripts)
      if (scripts.indexOf(argv[2]) !== -1) return cb()
      // ok, try to find out which package it was, then
      var pref = npm.config.get('global') ? npm.config.get('prefix')
               : npm.localPrefix
      var pkgDir = path.resolve(pref, 'node_modules', argv[2], 'package.json')
      readJson(pkgDir, function (er, d) {
        if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
        if (er) d = {}
        var scripts = Object.keys(d.scripts || {})
        return cb(null, scripts)
      })
    })
  }

  readJson(path.join(npm.localPrefix, 'package.json'), function (er, d) {
    if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
    d = d || {}
    cb(null, Object.keys(d.scripts || {}))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.saml" id="apidoc.module.npm.saml">module npm.saml</a></h1>


    <h2>
        <a href="#apidoc.element.npm.saml.login" id="apidoc.element.npm.saml.login">
        function <span class="apidocSignatureSpan">npm.saml.</span>login
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function login() {
  npm.config.set('sso-type', 'saml')
  ssoAuth.login.apply(this, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log.disableProgress()

try {
  var auth = require('./auth/' + npm.config.get('auth-type'))
} catch (e) {
  return cb(new Error('no such auth module'))
}
auth.<span class="apidocCodeKeywordSpan">login</span>(creds, registry, scope, function (err, newCreds) {
  if (err) return cb(err)

  npm.config.del('_token', 'user') // prevent legacy pollution
  if (scope) npm.config.set(scope + ':registry', registry, 'user')
  npm.config.setCredentialsByURI(registry, newCreds)
  npm.config.save('user', cb)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.save" id="apidoc.module.npm.save">module npm.save</a></h1>


    <h2>
        <a href="#apidoc.element.npm.save.getSaveType" id="apidoc.element.npm.save.getSaveType">
        function <span class="apidocSignatureSpan">npm.save.</span>getSaveType
        <span class="apidocSignatureSpan">(tree, arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSaveType = function (tree, arg) {
  if (arguments.length) validate('OO', arguments)
  var globalInstall = npm.config.get('global')
  var noSaveFlags = !npm.config.get('save') &amp;&amp;
                    !npm.config.get('save-dev') &amp;&amp;
                    !npm.config.get('save-prod') &amp;&amp;
                    !npm.config.get('save-optional')
  if (globalInstall || noSaveFlags) return null

  if (npm.config.get('save-optional')) {
    return 'optionalDependencies'
  } else if (npm.config.get('save-dev')) {
    return 'devDependencies'
  } else if (npm.config.get('save-prod')) {
    return 'dependencies'
  } else {
    if (arg) {
      var name = moduleName(arg)
      if (tree.package.optionalDependencies[name]) {
        return 'optionalDependencies'
      } else if (tree.package.devDependencies[name]) {
        return 'devDependencies'
      }
    }
    return 'dependencies'
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.save.saveRequested" id="apidoc.element.npm.save.saveRequested">
        function <span class="apidocSignatureSpan">npm.save.</span>saveRequested
        <span class="apidocSignatureSpan">(tree, andReturn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveRequested = function (tree, andReturn) {
  validate('OF', arguments)
  savePackageJson(tree, andWarnErrors(andSaveShrinkwrap(tree, andReturn)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.save.saveShrinkwrap" id="apidoc.element.npm.save.saveShrinkwrap">
        function <span class="apidocSignatureSpan">npm.save.</span>saveShrinkwrap
        <span class="apidocSignatureSpan">(tree, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function saveShrinkwrap(tree, next) {
  validate('OF', arguments)
  if (!npm.config.get('shrinkwrap') || !npm.config.get('package-lock')) {
    next()
  }
  createShrinkwrap(tree, {silent: false}, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.save_stack" id="apidoc.module.npm.save_stack">module npm.save_stack</a></h1>


    <h2>
        <a href="#apidoc.element.npm.save_stack.save_stack" id="apidoc.element.npm.save_stack.save_stack">
        function <span class="apidocSignatureSpan">npm.</span>save_stack
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SaveStack(fn) {
  Error.call(this)
  Error.captureStackTrace(this, fn || SaveStack)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.save_stack.super_" id="apidoc.element.npm.save_stack.super_">
        function <span class="apidocSignatureSpan">npm.save_stack.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.save_stack.prototype" id="apidoc.module.npm.save_stack.prototype">module npm.save_stack.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.npm.save_stack.prototype.completeWith" id="apidoc.element.npm.save_stack.prototype.completeWith">
        function <span class="apidocSignatureSpan">npm.save_stack.prototype.</span>completeWith
        <span class="apidocSignatureSpan">(er)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completeWith = function (er) {
  this['__' + 'proto' + '__'] = er
  this.stack = this.stack + '\n\n' + er.stack
  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.search" id="apidoc.module.npm.search">module npm.search</a></h1>


    <h2>
        <a href="#apidoc.element.npm.search.search" id="apidoc.element.npm.search.search">
        function <span class="apidocSignatureSpan">npm.</span>search
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function search(args, cb) {
  var searchOpts = {
    description: npm.config.get('description'),
    exclude: prepareExcludes(npm.config.get('searchexclude')),
    include: prepareIncludes(args, npm.config.get('searchopts')),
    limit: npm.config.get('searchlimit'),
    log: log,
    staleness: npm.config.get('searchstaleness'),
    unicode: npm.config.get('unicode')
  }

  if (searchOpts.include.length === 0) {
    return cb(new Error('search must be called with arguments'))
  }

  // Used later to figure out whether we had any packages go out
  var anyOutput = false

  var entriesStream = ms.through.obj()

  var esearchWritten = false
  esearch(searchOpts).on('data', function (pkg) {
    entriesStream.write(pkg)
    !esearchWritten &amp;&amp; (esearchWritten = true)
  }).on('error', function (e) {
    if (esearchWritten) {
      // If esearch errored after already starting output, we can't fall back.
      return entriesStream.emit('error', e)
    }
    log.warn('search', 'fast search endpoint errored. Using old search.')
    allPackageSearch(searchOpts).on('data', function (pkg) {
      entriesStream.write(pkg)
    }).on('error', function (e) {
      entriesStream.emit('error', e)
    }).on('end', function () {
      entriesStream.end()
    })
  }).on('end', function () {
    entriesStream.end()
  })

  // Grab a configured output stream that will spit out packages in the
  // desired format.
  var outputStream = formatPackageStream({
    args: args, // --searchinclude options are not highlighted
    long: npm.config.get('long'),
    description: npm.config.get('description'),
    json: npm.config.get('json'),
    parseable: npm.config.get('parseable'),
    color: npm.color
  })
  outputStream.on('data', function (chunk) {
    if (!anyOutput) { anyOutput = true }
    output(chunk.toString('utf8'))
  })

  log.silly('search', 'searching packages')
  ms.pipe(entriesStream, outputStream, function (er) {
    if (er) return cb(er)
    if (!anyOutput &amp;&amp; !npm.config.get('json') &amp;&amp; !npm.config.get('parseable')) {
      output('No matches found for ' + (args.map(JSON.stringify).join(' ')))
    }
    log.silly('search', 'search completed')
    log.clearProgress()
    cb(null, {})
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.search.completion" id="apidoc.element.npm.search.completion">
        function <span class="apidocSignatureSpan">npm.search.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  cb(null, [])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.shrinkwrap" id="apidoc.module.npm.shrinkwrap">module npm.shrinkwrap</a></h1>


    <h2>
        <a href="#apidoc.element.npm.shrinkwrap.shrinkwrap" id="apidoc.element.npm.shrinkwrap.shrinkwrap">
        function <span class="apidocSignatureSpan">npm.</span>shrinkwrap
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shrinkwrap(args, silent, cb) {
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }

  if (args.length) {
    log.warn('shrinkwrap', "doesn't take positional args")
  }

  move(
    path.resolve(npm.prefix, PKGLOCK),
    path.resolve(npm.prefix, SHRINKWRAP),
    { Promise: BB }
  ).then(() =&gt; {
    log.notice('', `${PKGLOCK} has been renamed to ${SHRINKWRAP}. ${SHRINKWRAP} will be used for future installations.`)
    return readFile(path.resolve(npm.prefix, SHRINKWRAP)).then((d) =&gt; {
      return JSON.parse(d)
    })
  }, (err) =&gt; {
    if (err.code !== 'ENOENT') {
      throw err
    } else {
      return readPackageTree(npm.localPrefix).then(
        id.computeMetadata
      ).then((tree) =&gt; {
        return BB.fromNode((cb) =&gt; {
          createShrinkwrap(tree, {
            silent,
            defaultFile: SHRINKWRAP
          }, cb)
        })
      })
    }
  }).then((data) =&gt; cb(null, data), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.shrinkwrap.createShrinkwrap" id="apidoc.element.npm.shrinkwrap.createShrinkwrap">
        function <span class="apidocSignatureSpan">npm.shrinkwrap.</span>createShrinkwrap
        <span class="apidocSignatureSpan">(tree, opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createShrinkwrap(tree, opts, cb) {
  opts = opts || {}
  lifecycle(tree.package, 'preshrinkwrap', tree.path, function () {
    const pkginfo = treeToShrinkwrap(tree)
    chain([
      [lifecycle, tree.package, 'shrinkwrap', tree.path],
      [shrinkwrap_, tree.path, pkginfo, opts],
      [lifecycle, tree.package, 'postshrinkwrap', tree.path]
    ], iferr(cb, function (data) {
      cb(null, pkginfo)
    }))
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.sso" id="apidoc.module.npm.sso">module npm.sso</a></h1>


    <h2>
        <a href="#apidoc.element.npm.sso.login" id="apidoc.element.npm.sso.login">
        function <span class="apidocSignatureSpan">npm.sso.</span>login
        <span class="apidocSignatureSpan">(creds, registry, scope, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function login(creds, registry, scope, cb) {
  var ssoType = npm.config.get('sso-type')
  if (!ssoType) { return cb(new Error('Missing option: sso-type')) }

  var params = {
    // We're reusing the legacy login endpoint, so we need some dummy
    // stuff here to pass validation. They're never used.
    auth: {
      username: 'npm_' + ssoType + '_auth_dummy_user',
      password: 'placeholder',
      email: 'support@npmjs.com',
      authType: ssoType
    }
  }
  npm.registry.adduser(registry, params, function (er, doc) {
    if (er) return cb(er)
    if (!doc || !doc.token) return cb(new Error('no SSO token returned'))
    if (!doc.sso) return cb(new Error('no SSO URL returned by services'))

    output('If your browser doesn\'t open, visit ' +
           doc.sso +
           ' to complete authentication')
    opener(doc.sso, { command: npm.config.get('browser') }, function () {
      pollForSession(registry, doc.token, function (err, username) {
        if (err) return cb(err)

        log.info('adduser', 'Authorized user %s', username)
        var scopeMessage = scope ? ' to scope ' + scope : ''
        output('Logged in as %s%s on %s.', username, scopeMessage, registry)

        cb(null, { token: doc.token })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
log.disableProgress()

try {
  var auth = require('./auth/' + npm.config.get('auth-type'))
} catch (e) {
  return cb(new Error('no such auth module'))
}
auth.<span class="apidocCodeKeywordSpan">login</span>(creds, registry, scope, function (err, newCreds) {
  if (err) return cb(err)

  npm.config.del('_token', 'user') // prevent legacy pollution
  if (scope) npm.config.set(scope + ':registry', registry, 'user')
  npm.config.setCredentialsByURI(registry, newCreds)
  npm.config.save('user', cb)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.star" id="apidoc.module.npm.star">module npm.star</a></h1>


    <h2>
        <a href="#apidoc.element.npm.star.star" id="apidoc.element.npm.star.star">
        function <span class="apidocSignatureSpan">npm.</span>star
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function star(args, cb) {
  if (!args.length) return cb(star.usage)
  var s = npm.config.get('unicode') ? '\u2605 ' : '(*)'
  var u = npm.config.get('unicode') ? '\u2606 ' : '( )'
  var using = !(npm.command.match(/^un/))
  if (!using) s = u
  asyncMap(args, function (pkg, cb) {
    mapToRegistry(pkg, npm.config, function (er, uri, auth) {
      if (er) return cb(er)

      var params = {
        starred: using,
        auth: auth
      }
      npm.registry.star(uri, params, function (er, data, raw, req) {
        if (!er) {
          output(s + ' ' + pkg)
          log.verbose('star', data)
        }
        cb(er, data, raw, req)
      })
    })
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
mapToRegistry(pkg, npm.config, function (er, uri, auth) {
  if (er) return cb(er)

  var params = {
    starred: using,
    auth: auth
  }
  npm.registry.<span class="apidocCodeKeywordSpan">star</span>(uri, params, function (er, data, raw, req) {
    if (!er) {
      output(s + ' ' + pkg)
      log.verbose('star', data)
    }
    cb(er, data, raw, req)
  })
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.star.completion" id="apidoc.element.npm.star.completion">
        function <span class="apidocSignatureSpan">npm.star.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  // FIXME: there used to be registry completion here, but it stopped making
  // sense somewhere around 50,000 packages on the registry
  cb()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.start" id="apidoc.module.npm.start">module npm.start</a></h1>


    <h2>
        <a href="#apidoc.element.npm.start.start" id="apidoc.element.npm.start.start">
        function <span class="apidocSignatureSpan">npm.</span>start
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands['run-script']([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.start.completion" id="apidoc.element.npm.start.completion">
        function <span class="apidocSignatureSpan">npm.start.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  installedShallow(opts, function (d) {
    return d.scripts &amp;&amp; d.scripts[stage]
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.stop" id="apidoc.module.npm.stop">module npm.stop</a></h1>


    <h2>
        <a href="#apidoc.element.npm.stop.stop" id="apidoc.element.npm.stop.stop">
        function <span class="apidocSignatureSpan">npm.</span>stop
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CMD(args, cb) {
  npm.commands['run-script']([stage].concat(args), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.stop.completion" id="apidoc.element.npm.stop.completion">
        function <span class="apidocSignatureSpan">npm.stop.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  installedShallow(opts, function (d) {
    return d.scripts &amp;&amp; d.scripts[stage]
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.team" id="apidoc.module.npm.team">module npm.team</a></h1>


    <h2>
        <a href="#apidoc.element.npm.team.team" id="apidoc.element.npm.team.team">
        function <span class="apidocSignatureSpan">npm.</span>team
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function team(args, cb) {
  // Entities are in the format &lt;scope&gt;:&lt;team&gt;
  var cmd = args.shift()
  var entity = (args.shift() || '').split(':')
  return mapToRegistry('/', npm.config, function (err, uri, auth) {
    if (err) { return cb(err) }
    try {
      return npm.registry.team(cmd, uri, {
        auth: auth,
        scope: entity[0],
        team: entity[1],
        user: args.shift()
      }, function (err, data) {
        !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))
        cb(err, data)
      })
    } catch (e) {
      cb(e.message + '\n\nUsage:\n' + team.usage)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function team (args, cb) {
// Entities are in the format &lt;scope&gt;:&lt;team&gt;
var cmd = args.shift()
var entity = (args.shift() || '').split(':')
return mapToRegistry('/', npm.config, function (err, uri, auth) {
  if (err) { return cb(err) }
  try {
    return npm.registry.<span class="apidocCodeKeywordSpan">team</span>(cmd, uri, {
      auth: auth,
      scope: entity[0],
      team: entity[1],
      user: args.shift()
    }, function (err, data) {
      !err &amp;&amp; data &amp;&amp; output(JSON.stringify(data, undefined, 2))
      cb(err, data)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.team.completion" id="apidoc.element.npm.team.completion">
        function <span class="apidocSignatureSpan">npm.team.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain
  if (argv.length === 2) {
    return cb(null, team.subcommands)
  }
  switch (argv[2]) {
    case 'ls':
    case 'create':
    case 'destroy':
    case 'add':
    case 'rm':
    case 'edit':
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + ' not recognized'))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.token" id="apidoc.module.npm.token">module npm.token</a></h1>


    <h2>
        <a href="#apidoc.element.npm.token.token" id="apidoc.element.npm.token.token">
        function <span class="apidocSignatureSpan">npm.</span>token
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function token(args, cb) {
  log.gauge.show('token')
  if (args.length === 0) return withCb(list([]), cb)
  switch (args[0]) {
    case 'list':
    case 'ls':
      withCb(list(), cb)
      break
    case 'delete':
    case 'revoke':
    case 'remove':
    case 'rm':
      withCb(rm(args.slice(1)), cb)
      break
    case 'create':
      withCb(create(args.slice(1)), cb)
      break
    default:
      cb(new Error('Unknown profile command: ' + args[0]))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.token._validateCIDRList" id="apidoc.element.npm.token._validateCIDRList">
        function <span class="apidocSignatureSpan">npm.token.</span>_validateCIDRList
        <span class="apidocSignatureSpan">(cidrs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateCIDRList(cidrs) {
  const maybeList = cidrs ? (Array.isArray(cidrs) ? cidrs : [cidrs]) : []
  const list = maybeList.length === 1 ? maybeList[0].split(/,\s*/) : maybeList
  list.forEach(validateCIDR)
  return list
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.token.completion" id="apidoc.element.npm.token.completion">
        function <span class="apidocSignatureSpan">npm.token.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  var argv = opts.conf.argv.remain

  switch (argv[2]) {
    case 'list':
    case 'revoke':
    case 'create':
      return cb(null, [])
    default:
      return cb(new Error(argv[2] + ' not recognized'))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.umask" id="apidoc.module.npm.umask">module npm.umask</a></h1>


    <h2>
        <a href="#apidoc.element.npm.umask.fromString" id="apidoc.element.npm.umask.fromString">
        function <span class="apidocSignatureSpan">npm.umask.</span>fromString
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromString = function (val) {
  _fromString(val, function (err, result) {
    if (err) {
      npmlog.warn('invalid umask', err.message)
    }
    val = result
  })

  return val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    val = ''
  }
}
key = key.trim()
val = val.trim()
log.info('config', 'set %j %j', key, val)
var where = npm.config.get('global') ? 'global' : 'user'
if (key.match(/umask/)) val = umask.<span class="apidocCodeKeywordSpan">fromString</span>(val)
npm.config.set(key, val, where)
npm.config.save(where, cb)
}

function get (key, cb) {
if (!key) return list(cb)
if (!publicVar(key)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.umask.toString" id="apidoc.element.npm.umask.toString">
        function <span class="apidocSignatureSpan">npm.umask.</span>toString
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString(val) {
    val = val.toString(8);
    while (val.length &lt; 4) {
        val = "0" + val;
    }
    return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function get (key, cb) {
  if (!key) return list(cb)
  if (!publicVar(key)) {
    return cb(new Error('---sekretz---'))
  }
  var val = npm.config.get(key)
  if (key.match(/umask/)) val = umask.<span class="apidocCodeKeywordSpan">toString</span>(val)
  output(val)
  cb()
}

function sort (a, b) {
  return a &gt; b ? 1 : -1
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.umask.validate" id="apidoc.element.npm.umask.validate">
        function <span class="apidocSignatureSpan">npm.umask.</span>validate
        <span class="apidocSignatureSpan">(data, k, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validate(data, k, val) {
    // must be either an integer or an octal string.
    if (typeof val === "number" &amp;&amp; !isNaN(val)) {
        data[k] = val;
        return true;
    }

    if (typeof val === "string") {
        if (val.charAt(0) !== "0") {
            return false;
        }
        data[k] = parseInt(val, 8);
        return true;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.warn(m + ' ' + util.format.apply(util, [].slice.call(arguments, 1)))
  } }
}

exports.Umask = Umask
function Umask () {}
function validateUmask (data, k, val) {
  return umask.<span class="apidocCodeKeywordSpan">validate</span>(data, k, val)
}

function validateSemver (data, k, val) {
  if (!semver.valid(val)) return false
  data[k] = semver.valid(val)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.unbuild" id="apidoc.module.npm.unbuild">module npm.unbuild</a></h1>


    <h2>
        <a href="#apidoc.element.npm.unbuild.unbuild" id="apidoc.element.npm.unbuild.unbuild">
        function <span class="apidocSignatureSpan">npm.</span>unbuild
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unbuild(args, silent, cb) {
  if (typeof silent === 'function') {
    cb = silent
    silent = false
  }
  asyncMap(args, unbuild_(silent), cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unbuild.rmStuff" id="apidoc.element.npm.unbuild.rmStuff">
        function <span class="apidocSignatureSpan">npm.unbuild.</span>rmStuff
        <span class="apidocSignatureSpan">(pkg, folder, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rmStuff(pkg, folder, cb) {
  // if it's global, and folder is in {prefix}/node_modules,
  // then bins are in {prefix}/bin
  // otherwise, then bins are in folder/../.bin
  var parent = pkg.name[0] === '@' ? path.dirname(path.dirname(folder)) : path.dirname(folder)
  var gnm = npm.dir
  // gnm might be an absolute path, parent might be relative
  // this checks they're the same directory regardless
  var top = path.relative(gnm, parent) === ''

  log.verbose('unbuild rmStuff', pkg._id, 'from', gnm)
  if (!top) log.verbose('unbuild rmStuff', 'in', parent)
  asyncMap([rmBins, rmMans], function (fn, cb) {
    fn(pkg, folder, parent, top, cb)
  }, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.uninstall" id="apidoc.module.npm.uninstall">module npm.uninstall</a></h1>


    <h2>
        <a href="#apidoc.element.npm.uninstall.uninstall" id="apidoc.element.npm.uninstall.uninstall">
        function <span class="apidocSignatureSpan">npm.</span>uninstall
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function uninstall(args, cb) {
  validate('AF', arguments)
  // the /path/to/node_modules/..
  const dryrun = !!npm.config.get('dry-run')

  if (args.length === 1 &amp;&amp; args[0] === '.') args = []

  const where = npm.config.get('global') || !args.length
            ? path.resolve(npm.globalDir, '..')
            : npm.prefix

  args = args.filter(function (a) {
    return path.resolve(a) !== where
  })

  if (args.length) {
    new Uninstaller(where, dryrun, args).run(cb)
  } else {
    // remove this package from the global space, if it's installed there
    readJson(path.resolve(npm.localPrefix, 'package.json'), function (er, pkg) {
      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
      if (er) return cb(uninstall.usage)
      new Uninstaller(where, dryrun, [pkg.name]).run(cb)
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.uninstall.Uninstaller" id="apidoc.element.npm.uninstall.Uninstaller">
        function <span class="apidocSignatureSpan">npm.uninstall.</span>Uninstaller
        <span class="apidocSignatureSpan">(where, dryrun, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Uninstaller extends Installer {
  constructor (where, dryrun, args) {
    super(where, dryrun, args)
    this.remove = []
  }

  loadArgMetadata (next) {
    this.args = this.args.map(function (arg) { return {name: arg} })
    next()
  }

  loadAllDepsIntoIdealTree (cb) {
    validate('F', arguments)
    this.remove = this.args
    this.args = []
    log.silly('uninstall', 'loadAllDepsIntoIdealTree')
    const saveDeps = getSaveType()

    super.loadAllDepsIntoIdealTree(iferr(cb, () =&gt; {
      removeDeps(this.remove, this.idealTree, saveDeps, cb)
    }))
  }

  // no top level lifecycles on rm
  runPreinstallTopLevelLifecycles (cb) { cb() }
  runPostinstallTopLevelLifecycles (cb) { cb() }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.uninstall.completion" id="apidoc.element.npm.uninstall.completion">
        function <span class="apidocSignatureSpan">npm.uninstall.</span>completion
        <span class="apidocSignatureSpan">(opts, filter, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installedShallow(opts, filter, cb) {
  if (typeof cb !== 'function') {
    cb = filter
    filter = null
  }
  var conf = opts.conf
  var args = conf.argv.remain
  if (args.length &gt; 3) return cb()
  var local
  var global
  var localDir = npm.dir
  var globalDir = npm.globalDir
  if (npm.config.get('global')) {
    local = []
    next()
  } else {
    fs.readdir(localDir, function (er, pkgs) {
      local = (pkgs || []).filter(function (p) {
        return p.charAt(0) !== '.'
      })
      next()
    })
  }

  fs.readdir(globalDir, function (er, pkgs) {
    global = (pkgs || []).filter(function (p) {
      return p.charAt(0) !== '.'
    })
    next()
  })
  function next () {
    if (!local || !global) return
    filterInstalled(local, global, filter, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.unpublish" id="apidoc.module.npm.unpublish">module npm.unpublish</a></h1>


    <h2>
        <a href="#apidoc.element.npm.unpublish.unpublish" id="apidoc.element.npm.unpublish.unpublish">
        function <span class="apidocSignatureSpan">npm.</span>unpublish
        <span class="apidocSignatureSpan">(args, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unpublish(args, cb) {
  if (args.length &gt; 1) return cb(unpublish.usage)

  var thing = args.length ? npa(args[0]) : {}
  var project = thing.name
  var version = thing.rawSpec

  log.silly('unpublish', 'args[0]', args[0])
  log.silly('unpublish', 'thing', thing)
  if (!version &amp;&amp; !npm.config.get('force')) {
    return cb(
      'Refusing to delete entire project.\n' +
      'Run with --force to do this.\n' +
      unpublish.usage
    )
  }

  if (!project || path.resolve(project) === npm.localPrefix) {
    // if there's a package.json in the current folder, then
    // read the package name and version out of that.
    var cwdJson = path.join(npm.localPrefix, 'package.json')
    return readJson(cwdJson, function (er, data) {
      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
      if (er) return cb('Usage:\n' + unpublish.usage)
      log.verbose('unpublish', data)
      gotProject(data.name, data.version, data.publishConfig, cb)
    })
  }
  return gotProject(project, version, cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (
  err.code === 'EPUBLISHCONFLICT' &amp;&amp;
  npm.config.get('force') &amp;&amp;
  !isRetry
) {
  log.warn('publish', 'Forced publish over ' + pkg._id)
  return BB.fromNode((cb) =&gt; {
    npm.commands.<span class="apidocCodeKeywordSpan">unpublish</span>([pkg._id], cb)
  }).finally(() =&gt; {
    // ignore errors.  Use the force.  Reach out with your feelings.
    return upload(arg, pkg, true, cached).catch(() =&gt; {
      // but if it fails again, then report the first error.
      throw err
    })
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unpublish.completion" id="apidoc.element.npm.unpublish.completion">
        function <span class="apidocSignatureSpan">npm.unpublish.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  if (opts.conf.argv.remain.length &gt;= 3) return cb()
  npm.commands.whoami([], true, function (er, username) {
    if (er) return cb()

    var un = encodeURIComponent(username)
    if (!un) return cb()
    var byUser = '-/by-user/' + un
    mapToRegistry(byUser, npm.config, function (er, uri, auth) {
      if (er) return cb(er)

      npm.registry.get(uri, { auth: auth }, function (er, pkgs) {
        // do a bit of filtering at this point, so that we don't need
        // to fetch versions for more than one thing, but also don't
        // accidentally a whole project.
        pkgs = pkgs[un]
        if (!pkgs || !pkgs.length) return cb()
        var pp = npa(opts.partialWord).name
        pkgs = pkgs.filter(function (p) {
          return p.indexOf(pp) === 0
        })
        if (pkgs.length &gt; 1) return cb(null, pkgs)
        mapToRegistry(pkgs[0], npm.config, function (er, uri, auth) {
          if (er) return cb(er)

          npm.registry.get(uri, { auth: auth }, function (er, d) {
            if (er) return cb(er)
            var vers = Object.keys(d.versions)
            if (!vers.length) return cb(null, pkgs)
            return cb(null, vers.map(function (v) {
              return pkgs[0] + '@' + v
            }))
          })
        })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.unsupported" id="apidoc.module.npm.unsupported">module npm.unsupported</a></h1>


    <h2>
        <a href="#apidoc.element.npm.unsupported.checkForBrokenNode" id="apidoc.element.npm.unsupported.checkForBrokenNode">
        function <span class="apidocSignatureSpan">npm.unsupported.</span>checkForBrokenNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForBrokenNode = function () {
  var nodejs = checkVersion(process.version)
  if (nodejs.broken) {
    console.error('ERROR: npm is known not to run on Node.js ' + process.version)
    supportedNode.forEach(function (rel) {
      if (semver.satisfies(nodejs.version, rel.ver)) {
        console.error('Node.js ' + rel.ver + " is supported but the specific version you're running has")
        console.error('a bug known to break npm. Please update to at least ' + rel.min + ' to use this')
        console.error('version of npm. You can find the latest release of Node.js at https://nodejs.org/')
        process.exit(1)
      }
    })
    var supportedMajors = supportedNode.map(function (n) { return n.ver }).join(', ')
    console.error("You'll need to upgrade to a newer version in order to use this")
    console.error('version of npm. Supported versions are ' + supportedMajors + '. You can find the')
    console.error('latest version at https://nodejs.org/')
    process.exit(1)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  WScript.quit(1)
  return
}

process.title = 'npm'

var unsupported = require('../lib/utils/unsupported.js')
unsupported.<span class="apidocCodeKeywordSpan">checkForBrokenNode</span>()

var log = require('npmlog')
log.pause() // will be unpaused when config is loaded.
log.info('it worked if it ends with', 'ok')

unsupported.checkForUnsupportedNode()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unsupported.checkForUnsupportedNode" id="apidoc.element.npm.unsupported.checkForUnsupportedNode">
        function <span class="apidocSignatureSpan">npm.unsupported.</span>checkForUnsupportedNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkForUnsupportedNode = function () {
  var nodejs = checkVersion(process.version)
  if (nodejs.unsupported) {
    var log = require('npmlog')
    var supportedMajors = supportedNode.map(function (n) { return n.ver }).join(', ')
    log.warn('npm', 'npm does not support Node.js ' + process.version)
    log.warn('npm', 'You should probably upgrade to a newer version of node as we')
    log.warn('npm', "can't make any promises that npm will work with this version.")
    log.warn('npm', 'Supported releases of Node.js are the latest release of ' + supportedMajors + '.')
    log.warn('npm', 'You can find the latest version at https://nodejs.org/')
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var unsupported = require('../lib/utils/unsupported.js')
unsupported.checkForBrokenNode()

var log = require('npmlog')
log.pause() // will be unpaused when config is loaded.
log.info('it worked if it ends with', 'ok')

unsupported.<span class="apidocCodeKeywordSpan">checkForUnsupportedNode</span>()

if (!unsupported.checkVersion(process.version).unsupported) {
  var updater = require('update-notifier')
  var pkg = require('../package.json')
  updater({pkg: pkg}).notify({defer: true})
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.unsupported.checkVersion" id="apidoc.element.npm.unsupported.checkVersion">
        function <span class="apidocSignatureSpan">npm.unsupported.</span>checkVersion
        <span class="apidocSignatureSpan">(version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkVersion = function (version) {
  var versionNoPrerelease = version.replace(/-.*$/, '')
  return {
    version: versionNoPrerelease,
    broken: semver.satisfies(versionNoPrerelease, knownBroken),
    unsupported: !semver.satisfies(versionNoPrerelease, supportedNode.map(function (n) { return '^' + n.min }).join('||'))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var log = require('npmlog')
log.pause() // will be unpaused when config is loaded.
log.info('it worked if it ends with', 'ok')

unsupported.checkForUnsupportedNode()

if (!unsupported.<span class="apidocCodeKeywordSpan">checkVersion</span>(process.version).unsupported) {
  var updater = require('update-notifier')
  var pkg = require('../package.json')
  updater({pkg: pkg}).notify({defer: true})
}

var path = require('path')
var npm = require('../lib/npm.js')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.validate_args" id="apidoc.module.npm.validate_args">module npm.validate_args</a></h1>


    <h2>
        <a href="#apidoc.element.npm.validate_args.validate_args" id="apidoc.element.npm.validate_args.validate_args">
        function <span class="apidocSignatureSpan">npm.</span>validate_args
        <span class="apidocSignatureSpan">(idealTree, args, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate_args = function (idealTree, args, next) {
  validate('OAF', arguments)
  var force = npm.config.get('force')

  asyncMap(args, function (pkg, done) {
    chain([
      [hasMinimumFields, pkg],
      [checkSelf, idealTree, pkg, force],
      [isInstallable, pkg]
    ], done)
  }, next)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.validate_args.isInstallable" id="apidoc.element.npm.validate_args.isInstallable">
        function <span class="apidocSignatureSpan">npm.validate_args.</span>isInstallable
        <span class="apidocSignatureSpan">(pkg, next)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInstallable = function (pkg, next) {
  var force = npm.config.get('force')
  var nodeVersion = npm.config.get('node-version')
  if (/-/.test(nodeVersion)) {
    // for the purposes of validation, if the node version is a prerelease,
    // strip that. We check and warn about this sceanrio over in validate-tree.
    nodeVersion = nodeVersion.replace(/-.*/, '')
  }
  var strict = npm.config.get('engine-strict')
  checkEngine(pkg, npm.version, nodeVersion, force, strict, iferr(next, thenWarnEngineIssues))
  function thenWarnEngineIssues (warn) {
    if (warn) getWarnings(pkg).push(warn)
    checkPlatform(pkg, force, next)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.view" id="apidoc.module.npm.view">module npm.view</a></h1>


    <h2>
        <a href="#apidoc.element.npm.view.view" id="apidoc.element.npm.view.view">
        function <span class="apidocSignatureSpan">npm.</span>view
        <span class="apidocSignatureSpan">(args, silent, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function view(args, silent, cb) {
  if (typeof cb !== 'function') {
    cb = silent
    silent = false
  }

  if (!args.length) args = ['.']

  var pkg = args.shift()
  var nv
  if (/^[.]@/.test(pkg)) {
    nv = npa.resolve(null, pkg.slice(2))
  } else {
    nv = npa(pkg)
  }
  var name = nv.name
  var local = (name === '.' || !name)

  if (npm.config.get('global') &amp;&amp; local) {
    return cb(new Error('Cannot use view command in global mode.'))
  }

  if (local) {
    var dir = npm.prefix
    readJson(path.resolve(dir, 'package.json'), function (er, d) {
      d = d || {}
      if (er &amp;&amp; er.code !== 'ENOENT' &amp;&amp; er.code !== 'ENOTDIR') return cb(er)
      if (!d.name) return cb(new Error('Invalid package.json'))

      var p = d.name
      nv = npa(p)
      if (pkg &amp;&amp; ~pkg.indexOf('@')) {
        nv.rawSpec = pkg.split('@')[pkg.indexOf('@')]
      }

      fetchAndRead(nv, args, silent, cb)
    })
  } else {
    fetchAndRead(nv, args, silent, cb)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.view.completion" id="apidoc.element.npm.view.completion">
        function <span class="apidocSignatureSpan">npm.view.</span>completion
        <span class="apidocSignatureSpan">(opts, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">completion = function (opts, cb) {
  if (opts.conf.argv.remain.length &lt;= 2) {
    // FIXME: there used to be registry completion here, but it stopped making
    // sense somewhere around 50,000 packages on the registry
    return cb()
  }
  // have the package, get the fields.
  var tag = npm.config.get('tag')
  mapToRegistry(opts.conf.argv.remain[2], npm.config, function (er, uri, auth) {
    if (er) return cb(er)

    npm.registry.get(uri, { auth: auth }, function (er, d) {
      if (er) return cb(er)
      var dv = d.versions[d['dist-tags'][tag]]
      var fields = []
      d.versions = Object.keys(d.versions).sort(semver.compareLoose)
      fields = getFields(d).concat(getFields(dv))
      cb(null, fields)
    })
  })

  function getFields (d, f, pref) {
    f = f || []
    if (!d) return f
    pref = pref || []
    Object.keys(d).forEach(function (k) {
      if (k.charAt(0) === '_' || k.indexOf('.') !== -1) return
      var p = pref.concat(k).join('.')
      f.push(p)
      if (Array.isArray(d[k])) {
        d[k].forEach(function (val, i) {
          var pi = p + '[' + i + ']'
          if (val &amp;&amp; typeof val === 'object') getFields(val, f, [p])
          else f.push(pi)
        })
        return
      }
      if (typeof d[k] === 'object') getFields(d[k], f, [p])
    })
    return f
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  npm.config.set(k, parsed[k])
})

// at this point, if words[1] is some kind of npm command,
// then complete on it.
// otherwise, do nothing
cmd = npm.commands[cmd]
if (cmd &amp;&amp; cmd.completion) return cmd.<span class="apidocCodeKeywordSpan">completion</span>(opts, cb)

// nothing to do.
cb()
}

function dumpScript (cb) {
var fs = require('graceful-fs')
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.npm.writable" id="apidoc.module.npm.writable">module npm.writable</a></h1>


    <h2>
        <a href="#apidoc.element.npm.writable.writable" id="apidoc.element.npm.writable.writable">
        function <span class="apidocSignatureSpan">npm.</span>writable
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight('writable:' + dir, done)
  if (!done) return
  fs.access(dir, fs.W_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.writable.fsAccessImplementation" id="apidoc.element.npm.writable.fsAccessImplementation">
        function <span class="apidocSignatureSpan">npm.writable.</span>fsAccessImplementation
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsAccessImplementation(dir, done) {
  done = inflight('writable:' + dir, done)
  if (!done) return
  fs.access(dir, fs.W_OK, done)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.npm.writable.fsOpenImplementation" id="apidoc.element.npm.writable.fsOpenImplementation">
        function <span class="apidocSignatureSpan">npm.writable.</span>fsOpenImplementation
        <span class="apidocSignatureSpan">(dir, done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsOpenImplementation(dir, done) {
  done = inflight('writable:' + dir, done)
  if (!done) return
  var tmp = path.join(dir, '.npm.check.permissions')
  fs.open(tmp, 'w', function (er, fd) {
    if (er) return done(accessError(dir, er))
    fs.close(fd, function () {
      fs.unlink(tmp, andIgnoreErrors(done))
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>